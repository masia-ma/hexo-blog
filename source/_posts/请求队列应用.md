---
title: 监视属性
categories: 
  - js
  - vue
tags: 
  - js
  - vue
---

## 请求队列
<!-- more -->
### 问题描述
云桌面、云主机规格价格计算
1. 每次点击选中不同的参数时都会引起价格的重新计算（比如选择CPU规格2核、4核等），价格的计算采用的方式是调取后台的价格计算接口;
2. 不同维度的参数具有一些依赖关系
> + 比如，vCPU依赖资源池，内存依赖vCPU（这个也非常好理解，比如兰州这个节点下面没有性能较高的主机，那么也没有比如32核的vCPU，但是杭州这个节点下面有；不同规格的vCPU有与内存之间建立的对应关系，弹性云主机的选择比较注重cpu与内存的比例，比如cpu与内存比是1：4的，就是偏向于存储型的云主机，2：4的就是偏计算型的云主机）
3. 每次拿到参数列表时都会默认选中一个
> 1. 比如，选中资源池为兰州 
> 2. -> 调取获取vCPU列表接口，重新获取vCPU的列表为 `const vCPUList = [1, 2, 4, 8, 16]`
> 3. 执行selectVCPU(1)，默认选中第一个（1核）
> 4. -> 调取获取内存列表接口，重新获取内存列表为`const memList = [1, 2, 4, 8]`
> 5. 执行selectMem(1)，默认选中第一个（1G）
> 6. 可以看出 资源池 > vCPU > Memsize 这个三个参数的选择的顺序上是同步的，并且存在从后想前的依赖关系，所以可以在`selectMem`方法体中去执行价格计算方法`calcPrice()`
4. 不同维度的参数不具有依赖关系
> + 比如，数据盘容量与公网带宽和上面三种参数不具有关联关系，那么当这两种参数改变的时候去哪里执行价格计算呢？
> + 肯定是在点击事件的回调中去执行价格计算
5. 有依赖关系的参数与没有依赖关系的参数混合起来使用的时候，该在哪里调用价格计算？
> 1. 在第一次初始化参数的时候，假设 资源池、vCPU、内存 归结位一条参数选择线A，命名为`selectLineA` ；当然，数据盘类型和容量也分别有相应的初始值，那我们把数据盘类型、数据盘容量归结为参数选择线B，命名为`selectLineB`；
> 当内存选择完成之后，我们称`selectLineA`完成，当数据盘容量选择完成之后，我们称`selectLineB`完成
> 2. 虽然我们可以去强行控制这两条线的执行顺序，比如让`selectLineB`在`selectLineA`完成之后执行，但是这样其实是在强行建立无意义的依赖关系，而且执行重复的接口调用，浪费资源，比如选择了内存之后，`selectLineA`完成，又执行`selectLineB`，这样还会把用户在之前选择的数据盘类型和容量重新赋初始值，用户体验很差。
> 3. 在那我们很容易联想到`selectLineA`和`selectLineB`都完成的时候，再去计算价格就可以了，这里我想到的思路就是使用Promise.all()去实现。但其实这种方式只适用于第一次初始化两条线的时候，比如我在初始化之后的某个时间点去改变数据盘容量，`selectLineB`，但是`selectLineA`压根就没有执行，怎么会引起Promise.all()的执行呢？
> 4. 那我们就让`selectLineA`和`selectLineB`分别执行就好了，也不要管什么顺序了，他们完成之后分别去执行价格计算就好了，可以不?
> 分别执行价格计算是可以的，但是不能忽略顺序，因为价格计算最后要将资源池、vCPU、内存、数据盘类型、数据盘容量等参数一起提交给后台，不然后台会返回错误信息。假设同时执行`selectLineA`和`selectLineB`，`selectLineA`已经完成，但是`selectLineB`还没有完成，这是在`selectLineA`中去执行跳去价格计算接口，数据就会返回错误，返回错误其实比较好的情况，因为至少不会给数据赋值。
> 5. 还有一种情况，执行多次`selectLineB`，每次选中的数据盘容量不一样，但是每次选择后调取价格计算接口返回的顺序不一致，就会导致选择的容量与最后价格对不上的情况。比如：第1次选择40G，期待计算正确应该是40元，第2次选择80G，期待计算正确应该是80元，但是有可能第2次请求虽然后发，先返回了数据80元，并且给数据模型赋值80元，随后第1次请求完成，返回数据40元，并且给数据模型赋值40元。这样，程序就出现了逻辑错误，让用户觉得选中了较小的数据盘反而价格变低，当然这样不影响最后下单需要支付的费用，因为支付费用还是要根据的具体的参数算价格，这里在网页上算的价格只是展示给用户看的。

### 解决方案使用请求队列
请求队列解决多个相同异步请求的执行顺序问题和重复请求问题
> + 假设：
> 1. 请求A的请求时间是5s（这里稍微夸张一点），即 reqPendingTime = 5s
> 2. 在3s的时间内依次发起请求 reqA1， reqA2， reqA3，reqA4， reqA5，显然全部发起这些请求是无意义的，因为我们只要最新的`reqA`返回的结果
> 3. reqA就好比一个价格计算接口，reqA1 ~ reqA5 是用户在3s的时间内选择不同的参数之后执行的价格计算
> + 解决思路：
> 1. 在调取价格请求之前，找个数组去保存 reqA1 ~ reqA5 这样一些状态，比如：reqQue = [reqA1, reqA2, reqA3, reqA4, reqA5,];
> 2. 如果队列长度不为0，则执行 reqA1；
> 3. 在执行完成reqA1之后（这里不管是成功还是失败），检查队列的长度，如果大于1，说明在reqA1请求的这段时间里，有新的请求加入了队列；
> 4. 移出包括自己在内的就请求，只留下最新的一个请求，也就是队尾的那个，我们假设此时队尾的请求为reqA5；
> 5. 如果队列长度不为1，执行 reqA5；
> 6. 在执行完成reqA1之后（这里不管是成功还是失败），检查队列的长度，如果大于1，重复第3步，否则，说明没有新的请求加入队列，此时清空队列。
> + 代码模型实现：
```javascript 
const reqQue = [];

// 调取接口前的队列检查函数
function checkReqQue() { // 每次要调接口之前都会先加进队列
  if (!reqQue.length) { // 如果队列为空，
    reqQue.push(reqA); // 则 加入队列
    reqQue[0](); // 且执行
  } else { // 否则
    reqQue.push(reqA); // 只加入队列
  }

  // 或者
  /*
  this.reqQue.push(this.priceCalculateNext); // 加入队列
  if (this.reqQue.length == 1) {
    this.reqQue[0]();
  }
  */
}

// 模拟请求函数
function reqA(random) {
  // 请求结果模拟，随机成功或者失败
  const random = Math.ceil(Math.random()*10);
  if (random < 7) { // 5分之4的概率成功
    setTimeout(() => { // 成功回调，返回随机数
      console.log('成功的回调');
      // 判断请求队列
      if (reqQue.length > 1) { // 如果请求队列长度大于1，那证明在当前请求请求的这段时间内，又有后续的请求加进来
        reQue.splice(0, reqQue.length - 1); // 只留下最后一个请求
        reqQue[reqQue.length - 1](); // 执行最后一个请求
      } else { // 如果请求队列长度等于1 ，那证明当前的请求队列只包含当前请求
        reQue.splice(0, reqQue.length); // 因为当前请求已经执行过了，所以清空给队列
      }
      
      return;
    }, 5000);
  } else { // 5分之1概率失败
    setTimeout(() => { // 成功回调，返回随机数
      console.log('失败的回调');

      // 判断请求队列
      if (reqQue.length > 1) {
        reQue.splice(0, reqQue.length - 1);
        reqQue[reqQue.length - 1]();
      } else {
        reQue.splice(0, reqQue.length);
      }

      return;
    }, 5000); 
  }
}

```
### 请求队列与节流结合使用
假设选择数据盘的方式是输入数字型的，每当输入的时候都会重新计算价格，那么当用户要输入的目标值是500时，首先会在键盘键入5，其次是0，然后是0，如果我们给input绑定input事件，那么就会触发3次input事件函数，如果在该函数中调用calcPrice()，实际上在短时间内调用了3次价格计算且前面两次是没有意义的。
> 使用节流函数，当用户将要调用某一个函数的时候，延迟 500ms 的时间在去调用，如果在500ms内用户重复调用该函数，那就继续延迟500ms
> 代码模型实现
```javascript
const timer = null; // 定义一个全局的定时器

function debounce() {
  timer && clearTimeout(timer); // 每次调用 都会先检查全局的定时器，如果有定时任务，则清除
  timer = setTimeout(() => { // 重新定义定时任务
    checkReqQue(); // 执行当前定时任务任务主体
  }, 500);
}

```