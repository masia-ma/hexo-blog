{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/header.jpg","path":"images/header.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"b1fe5bda204049c85938a007006bb57d3661eb7a","modified":1579506302000},{"_id":"source/README.md","hash":"7d2ea12feec4c3e62c8a31c8bba48cfb6efa786e","modified":1579506302000},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1579506325000},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1579506326000},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1579506326000},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1579506326000},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1579506326000},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1579506327000},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1579506327000},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1579506327000},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1579506328000},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1579506328000},{"_id":"themes/next/README.cn.md","hash":"b878b73f3fcdef47849453c94420871903d487b3","modified":1579506329000},{"_id":"themes/next/README.md","hash":"efcdc4b0ca791c3fc64afa28c8721e137f2d11ea","modified":1579506329000},{"_id":"themes/next/_config.yml","hash":"a3160cdcbf939a85d4c40c21c57bed21896557c7","modified":1579506329000},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1579506328000},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1579506328000},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1579506329000},{"_id":"source/about/index.md","hash":"c2c0d20d317c92446b786a67e115497c48b67910","modified":1579506303000},{"_id":"source/categories/index.md","hash":"883e57e173488fa3f84e9dd4d057b07589db6643","modified":1579506303000},{"_id":"source/_posts/ES5继承.md","hash":"a3e91e0eeb950459b4bb267450072661f76b0448","modified":1579506304000},{"_id":"source/_posts/ES6梳理-Decorator.md","hash":"e4b8e4eca510afed70822e74e6c41adcb014cfc1","modified":1579506304000},{"_id":"source/_posts/ES6梳理-Generator.md","hash":"934358416a7dee6b0fa0b99cd64683cad2315173","modified":1579506304000},{"_id":"source/_posts/ES6梳理-Iterator.md","hash":"80a44cf9f13892ba504847fce01b21b1f1f1cde5","modified":1579506304000},{"_id":"source/_posts/ES6梳理-Proxy和Reflect.md","hash":"9e1b753bd00a8fe5017348e04810c13ad7efe0c6","modified":1579506305000},{"_id":"source/_posts/ES6梳理-Symbol.md","hash":"0be9194c24d1b3ab125bbcbee2afb2b6b24075c2","modified":1579506305000},{"_id":"source/_posts/ES6梳理-promise.md","hash":"f084c2f88d3e7a8c90ee115e2a5f3fd4357e8bc5","modified":1579506304000},{"_id":"source/_posts/ES6梳理-函数扩展.md","hash":"0af352090edc9c8ade6837d0a73befc6f1f47c81","modified":1579506305000},{"_id":"source/_posts/ES6梳理-字符串扩展.md","hash":"ed24678ee154b588fb7840804d6e342c379b761a","modified":1579506305000},{"_id":"source/_posts/ES6梳理-对象扩展.md","hash":"25cac4ac7666b27d6bb06b942d97159c39fdbf55","modified":1579506306000},{"_id":"source/_posts/ES6梳理-数值扩展.md","hash":"152fcf1a02061e805607918d3bb9acf19abfb599","modified":1579506306000},{"_id":"source/_posts/ES6梳理-数据结构.md","hash":"de4232c96d98ab9f754a55b39d33f213e5100fd3","modified":1579506306000},{"_id":"source/_posts/ES6梳理-数据结构对比.md","hash":"b8799e2ff4e8abea61ca92a2b873a88d7578d9c4","modified":1579506306000},{"_id":"source/_posts/ES6梳理-数组扩展.md","hash":"b4b0da12ad38703427970ee1827188c2918db710","modified":1579506307000},{"_id":"source/_posts/ES6梳理-模块化.md","hash":"5495bf1af8cd1fdf594e9def869995736cc4422a","modified":1579506307000},{"_id":"source/_posts/ES6梳理-正则扩展.md","hash":"607982da0337b962d37e75804775eea405ffbd06","modified":1579506307000},{"_id":"source/_posts/ES6梳理-类.md","hash":"a8fb3845a08aa7c3ce271f5e68e0149dd9f6c0f4","modified":1579506307000},{"_id":"source/_posts/ES6梳理-解构赋值.md","hash":"2336dfa780c21e4adb9bdf7c9257f1d1c6b0ed3f","modified":1579506308000},{"_id":"source/_posts/Function原型对象中的call、apply、bind.md","hash":"8992ed222ca0447332c158313a01d272fe81fb5c","modified":1579506308000},{"_id":"source/_posts/MVVM双向数据绑定原理.md","hash":"b18f44080b75cfa6af942fd2d55b66579f6a5893","modified":1579508918890},{"_id":"source/_posts/Object.md","hash":"553a8677eb586215ea1d9800f38dd41e96e06f0d","modified":1579506312000},{"_id":"source/_posts/React在事件绑定中bind的使用.md","hash":"7d3e98497ea0e00937e352e3c018427092948efa","modified":1579506312000},{"_id":"source/_posts/React学习-组件生命周期.md","hash":"da393b4ee84db1fd8f6c069c6cbdd177452e4e01","modified":1579506312000},{"_id":"source/_posts/React学习-高阶组件.md","hash":"e912df3054468dd1d6731aa324f27b73dfeb662c","modified":1579506312000},{"_id":"source/_posts/chrome-plugins.md","hash":"623e6455c8a21d669f22a3e23dbd384d2876e29c","modified":1579506303000},{"_id":"source/_posts/async和await的妙用-异步方法同步执行.md","hash":"a5e9150687beade4bb9bf117b6ebb2aac215a08f","modified":1579506303000},{"_id":"source/_posts/css技巧总结.md","hash":"b3b79d95c3f9f0e2fc5af3e7b540903daee76be3","modified":1579506303000},{"_id":"source/_posts/http-tcp.md","hash":"c9247ff33ac27338bb108cbea5ff2c27936d9119","modified":1579506308000},{"_id":"source/_posts/ie下vue问题总结.md","hash":"e6dc41ebf53447e970fe52f0fbd6712724079475","modified":1579506308000},{"_id":"source/_posts/js知识点集合.md","hash":"26a5cb0f5e1e9a6cdf3e9dd4f0896876e736714e","modified":1579506308000},{"_id":"source/_posts/js继承2.md","hash":"718a93d6953fac798a1f9385f66bf2114079578d","modified":1579506309000},{"_id":"source/_posts/js设计模式.md","hash":"868ecbf91e3a760004cf32d32dde3f7d118d1f2f","modified":1579506309000},{"_id":"source/_posts/js遍历数组的方法.md","hash":"4d0b2a8a1a591eae2163038261c2656aed2f0a21","modified":1579506309000},{"_id":"source/_posts/let关键字使用.md","hash":"32f9a5b0ebdcf98703553da7f159424f3c21cff3","modified":1579506309000},{"_id":"source/_posts/masia.md","hash":"fd62c79adfe4598f797a85c547199679f9dd3844","modified":1579506309000},{"_id":"source/_posts/mongoose使用.md","hash":"b4323f46204861ed481101a5298c99bdc7456413","modified":1579506310000},{"_id":"source/_posts/node-install.md","hash":"26b37e3c77c25328f3bbe937757bdb7838c8c303","modified":1579506310000},{"_id":"source/_posts/nodejs_review1.md","hash":"14353e4e759008424c3d6f2a218364241beabb9d","modified":1579506310000},{"_id":"source/_posts/nodejs_review2.md","hash":"e9d0c0c0b12402d7a1331913696398befd130e04","modified":1579506310000},{"_id":"source/_posts/nodejs_review3.md","hash":"b431d8034432f47e907bce4d010552f413054765","modified":1579506311000},{"_id":"source/_posts/nodejs_review4.md","hash":"8bcabc670ce76cbfad35af3d20e653021087e7b7","modified":1579506311000},{"_id":"source/_posts/nodejs_review5.md","hash":"4dbe447fc83a983d2ae290c22177c988fc3b0e52","modified":1579506311000},{"_id":"source/_posts/nodejs_review6.md","hash":"b708d6c753cb90f0c5e117d2cadc6823a95c5626","modified":1579506311000},{"_id":"source/_posts/nvm安装.md","hash":"252aa1c5f8ddf694484a154664d66cda2928add8","modified":1579506311000},{"_id":"source/_posts/sass的使用.md","hash":"b5fdd76b0b3bf564e45f7206d0830c11ff097d96","modified":1579506313000},{"_id":"source/_posts/scss使用心得.md","hash":"5d2041ac54f54c4e3394e5043a0936c7370d012b","modified":1579506313000},{"_id":"source/_posts/sublime使用.md","hash":"382b2b91701a4ecd2f96c14cb26f8ffc808d56e8","modified":1579506313000},{"_id":"source/_posts/vue-awesome-swiper使用.md","hash":"d56ccc470699dfb81a5b81519445c7aa2f8d76ed","modified":1579506313000},{"_id":"source/_posts/vue-cli3.0使用.md","hash":"66a2a44e2b4f20b612797e729cfc41fa925efc32","modified":1579506313000},{"_id":"source/_posts/vue_solution1.md","hash":"9359567ce44a30b873899a061249acca494b1b94","modified":1579506314000},{"_id":"source/_posts/vuex中遇到的问题1.md","hash":"9c1367474bffca2e3ea5922bd1e41c31211bc41c","modified":1579506314000},{"_id":"source/_posts/vuex使用-两个action依次执行.md","hash":"a06a1327e698bb132813afd6dbf3bc78e9ac725e","modified":1579506314000},{"_id":"source/_posts/vuex使用.md","hash":"39dfcb64a6c3a4d7f6e4ead1d193dcf985dac401","modified":1579506314000},{"_id":"source/_posts/vuex在登录中的应用.md","hash":"4260f8f853b7115aa6f684390cb791745ce733ff","modified":1579506314000},{"_id":"source/_posts/vue中axios封装.md","hash":"4d448471876c6af056f40df4b967bd845e858260","modified":1579506315000},{"_id":"source/_posts/vue引入多个局部使用的ui库.md","hash":"65de72d992f43dcb8a256b694abaaf78c04a5b0a","modified":1579506315000},{"_id":"source/_posts/vue强制刷新dom.md","hash":"b488cb252c0c4b3c03986aa16a30d96d2a40d5d5","modified":1579506315000},{"_id":"source/_posts/vue技术栈梳理-状态管理篇.md","hash":"0b457f2a337215399d45cca8c9f444b329914646","modified":1579506315000},{"_id":"source/_posts/vue技术栈梳理-路由篇.md","hash":"6aab466e0853c20f852615bb15654deffa509fb1","modified":1579506316000},{"_id":"source/_posts/vue本地代理配置.md","hash":"82085220160216864f6fb3c9f76edc54ed4bb4e1","modified":1579506316000},{"_id":"source/_posts/事件捕获和冒泡原理及其应用.md","hash":"b64aa7a0ecd62042e90ba3780f931bf92f297cb9","modified":1579506316000},{"_id":"source/_posts/字符串的常用方法.md","hash":"0d2743be72417540b0ba97b97a1077a02eed742d","modified":1579506317000},{"_id":"source/_posts/对象和数组的深度复制.md","hash":"8de3ce97584b741a96fa92ee4a2674364cabc60a","modified":1579506317000},{"_id":"source/_posts/数组和字符串易混淆方法集合.md","hash":"85aef34a29e574e26657b98f2963f75ab2ea4071","modified":1579506317000},{"_id":"source/_posts/正则表达式.md","hash":"8cb04defce28315d52f502180bc994505fa26af2","modified":1579506317000},{"_id":"source/_posts/登录组件的见解.md","hash":"c1480634a21fabb3c36cd7d7abec3f40da462794","modified":1579506318000},{"_id":"source/_posts/监视属性.md","hash":"e394732566a0a75141498fcfdc3d189bae9fe101","modified":1579506318000},{"_id":"source/_posts/神经网络学习.md","hash":"e5af242be910577e3612d6b4a985ea659a77a989","modified":1579506318000},{"_id":"source/_posts/请求队列应用.md","hash":"cbc4d6d070f9f2a429e14b4341dc3ff8d6ce0dc3","modified":1579506319000},{"_id":"source/_posts/闭包.md","hash":"6482490691824db5600f7a1accfbeb8dcdad84cc","modified":1579506319000},{"_id":"source/tags/index.md","hash":"9ff7cfc6f086b3df1da2a576ddd9971f2c7804e1","modified":1579506303000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1579506330000},{"_id":"themes/next/.git/config","hash":"340cff4364d9733a32042fdb93097c334a781c93","modified":1579506330000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1579506330000},{"_id":"themes/next/.git/index","hash":"230232c4bc4e680b35ae6d53afdd0d3f9a5fda57","modified":1579506330000},{"_id":"themes/next/.git/packed-refs","hash":"ae421c3c59b504716340fe85ae852ebd4aed1b8d","modified":1579506331000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1579506335000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1579506336000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1579506336000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1579506335000},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1579506336000},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1579506336000},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1579506336000},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1579506337000},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1579506337000},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1579506337000},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1579506337000},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1579506337000},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1579506338000},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1579506338000},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1579506338000},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1579506338000},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1579506338000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1579506339000},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1579506339000},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1579506339000},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1579506341000},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1579506339000},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1579506340000},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1579506340000},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1579506340000},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1579506340000},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1579506340000},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1579506341000},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1579506355000},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1579506355000},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1579506406000},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1579506407000},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1579506407000},{"_id":"source/_posts/ES6梳理-Generator/Generator1.png","hash":"3139f3531b7501b25dac0c2f19f73e63de26efa7","modified":1579506319000},{"_id":"source/_posts/ES6梳理-Iterator/Iterator_obj.png","hash":"6562d25341a4826e8de7eb18050210c71312c53c","modified":1579506320000},{"_id":"source/_posts/ES6梳理-Symbol/Symbol.png","hash":"760387024d9545bb692c368d05dd42f35ae85cad","modified":1579506320000},{"_id":"source/_posts/ES6梳理-对象扩展/Object.entries().png","hash":"d9a845ca98f1cde9d7152ac407c9b34ced977c88","modified":1579506320000},{"_id":"source/_posts/ES6梳理-数据结构/Map([]).png","hash":"c2713777aa3bb5f7bf0da470719af2a7c7619773","modified":1579506320000},{"_id":"source/_posts/ES6梳理-数据结构/Set(arr).png","hash":"815d6c6703b716bec4e558650e08fbde1a05bd29","modified":1579506321000},{"_id":"source/_posts/ES6梳理-数据结构/WeakSet().png","hash":"a04d2b27438afd9b506323cd560d9dac4c5881b3","modified":1579506321000},{"_id":"source/_posts/ES6梳理-数据结构/set.png","hash":"8aa69b507b22e5b8d196ddcfb3d923a268c48314","modified":1579506321000},{"_id":"source/_posts/ES6梳理-数组扩展/Array.from().png","hash":"6e19b6811daf97be6788d38b4b4118e910abba68","modified":1579506321000},{"_id":"source/_posts/ES6梳理-数组扩展/ArrayObj.reduce().png","hash":"ffa1354215a718a6eba1dda208d16b29dbeca85a","modified":1579506321000},{"_id":"source/_posts/ES6梳理-类/class_compare1.png","hash":"c2affbff5572dd4b7c30660d306b08ae7b96c2dc","modified":1579506322000},{"_id":"source/_posts/ES6梳理-类/class_simple.png","hash":"15264e34d39333c22896555568429183e9b11554","modified":1579506322000},{"_id":"source/_posts/ES6梳理-类/static1.png","hash":"b52b98ae4ef3416b7311c0f0d9921d5527b6293f","modified":1579506322000},{"_id":"source/_posts/MVVM双向数据绑定原理/obj1.png","hash":"fe355704727fa8703da0480032646bcdebb14c8a","modified":1579506323000},{"_id":"source/_posts/MVVM双向数据绑定原理/数据劫持.png","hash":"fdeae3c52b47be5702d025f53e7b6567729a382b","modified":1579506323000},{"_id":"source/_posts/React学习-高阶组件/react_higher_component1.png","hash":"564d4971361c0e2a6b503a25d7e97db609e86a42","modified":1579506324000},{"_id":"source/_posts/React学习-高阶组件/react_higher_component2.png","hash":"a8634fad5408b03fbcddd67679bfb80642d0a7b9","modified":1579506325000},{"_id":"source/_posts/js继承2/extends1.png","hash":"3b92b6673b211ccdd9b1466c5fe0667436cd1b9d","modified":1579506323000},{"_id":"source/_posts/nvm安装/nvm_install2.png","hash":"c090698539fd4034a1bcec0e6e0f41e64e03225d","modified":1579506324000},{"_id":"source/_posts/nvm安装/nvm_install3.png","hash":"be23276c24730836523877f6989e2c0ee2b5fe9c","modified":1579506324000},{"_id":"source/_posts/nvm安装/nvm_install4.png","hash":"e00c835c08742ec2198d3f20a3c6a8bfd1030a7c","modified":1579506324000},{"_id":"source/_posts/nvm安装/nvm_install5.png","hash":"251816016a165f07a6b2e0597ba23d03607e5093","modified":1579506324000},{"_id":"source/_posts/请求队列应用/yun1.png","hash":"779674ae8d28a69cfdd1de70d952a597270b5154","modified":1579506325000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1579506331000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1579506331000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1579506331000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1579506331000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1579506332000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1579506332000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1579506332000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1579506332000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1579506332000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1579506333000},{"_id":"themes/next/.git/logs/HEAD","hash":"ad237c3fdad00381bb9c2abe2b2eabcdfe1b999d","modified":1579506333000},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1579506341000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1579506342000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1579506342000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1579506342000},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1579506342000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1579506342000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1579506343000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1579506343000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1579506343000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1579506343000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1579506343000},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1579506344000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1579506344000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1579506344000},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1579506344000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1579506346000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1579506346000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1579506347000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1579506348000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1579506348000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1579506348000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1579506348000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1579506349000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1579506349000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1579506349000},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1579506356000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1579506356000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1579506356000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1579506356000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1579506356000},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1579506357000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1579506357000},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1579506357000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1579506357000},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1579506358000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1579506381000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1579506381000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1579506381000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1579506381000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1579506382000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1579506382000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1579506382000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1579506382000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1579506382000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1579506383000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1579506383000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1579506383000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579506383000},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1579506383000},{"_id":"themes/next/source/images/header.jpg","hash":"17c877f3384f1a611357d8c33a117fa7e6893dde","modified":1579506383000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579506384000},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1579506384000},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1579506384000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1579506384000},{"_id":"source/_posts/ES5继承/ES5_extends.png","hash":"12622c4d75b08b396a817d21f32df0720a6b9c36","modified":1579506319000},{"_id":"source/_posts/ES5继承/ES5_extends2.png","hash":"b7253513b9f3cf5332178345e04195f30ffaa0a6","modified":1579506319000},{"_id":"source/_posts/ES6梳理-Generator/Generator2.png","hash":"52c024aa803aa02583f73823b6def0303e5cf2d9","modified":1579506320000},{"_id":"source/_posts/ES6梳理-类/class_compare2.png","hash":"17755fd9f27da3f383a7a2728ccae4b5367e524e","modified":1579506322000},{"_id":"source/_posts/ES6梳理-类/class_compare3.png","hash":"ca108c358a9d5c731c74fee2dd7adb97fc0525e9","modified":1579506322000},{"_id":"source/_posts/nvm安装/nvm_install1.png","hash":"5437c4b7383d5b7259a2b96a07585cd579246ee9","modified":1579506323000},{"_id":"source/_posts/ES6梳理-Generator/Generator3.png","hash":"1c01adc9073e50bc667a8aa0ad251d46d4d68e1e","modified":1579506320000},{"_id":"themes/next/.git/refs/heads/master","hash":"3c959678e3fe6e51e935526c19927d21443a3be3","modified":1579506335000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1579506344000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1579506345000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1579506345000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1579506345000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1579506345000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1579506345000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1579506346000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1579506346000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1579506346000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1579506347000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1579506347000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1579506348000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1579506349000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1579506350000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1579506350000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1579506350000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1579506350000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1579506350000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1579506351000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1579506351000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1579506351000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1579506351000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1579506351000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1579506351000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1579506352000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1579506352000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1579506352000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1579506352000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1579506353000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1579506353000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1579506353000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1579506353000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1579506353000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1579506354000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1579506354000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1579506354000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1579506355000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"13b95cdbecbd56d1538cd71578c68e96d290a5c0","modified":1579506374000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1579506374000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1579506375000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1579506374000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1579506380000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1579506380000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1579506381000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1579506380000},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1579506384000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1579506385000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1579506385000},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1579506385000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1579506385000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1579506385000},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1579506386000},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1579506386000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1579506386000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1579506386000},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1579506386000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1579506387000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1579506388000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1579506388000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1579506388000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1579506388000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1579506392000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1579506392000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1579506392000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1579506392000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1579506393000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1579506393000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1579506394000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1579506394000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1579506394000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1579506399000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1579506399000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1579506400000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1579506400000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1579506399000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1579506400000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1579506400000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1579506401000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1579506401000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1579506401000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1579506401000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1579506402000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1579506402000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1579506402000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1579506402000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1579506402000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1579506403000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1579506403000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1579506403000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1579506403000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1579506403000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1579506404000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1579506404000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1579506404000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1579506404000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1579506404000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1579506405000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1579506405000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1579506406000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1579506406000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1579506406000},{"_id":"source/_posts/React学习-组件生命周期/component_life.png","hash":"376bdb97ac5f5771dae90871b4b4590f96edb1f8","modified":1579506324000},{"_id":"source/_posts/http-tcp/tcp3.png","hash":"41b6f8965872ddcffaa35408f2cde6f303783ddf","modified":1579506323000},{"_id":"source/_posts/事件捕获和冒泡原理及其应用/propagation.png","hash":"98ad0ed3a73f33146bb7de77fc90dae16a28672f","modified":1579506325000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1579506352000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1579506399000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1579506401000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"ad237c3fdad00381bb9c2abe2b2eabcdfe1b999d","modified":1579506333000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1579506335000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1579506354000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1579506355000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1579506358000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1579506359000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1579506359000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1579506359000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1579506359000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1579506360000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1579506360000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1579506373000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1579506373000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1579506373000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1579506373000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1579506373000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1579506374000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1579506374000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1579506375000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1579506376000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1579506376000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1579506376000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1579506376000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1579506377000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1579506377000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1579506376000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1579506378000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1579506378000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1579506378000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1579506378000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1579506377000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1579506379000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1579506379000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1579506379000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1579506379000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1579506379000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1579506379000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1579506386000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1579506397000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1579506397000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1579506389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1579506389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1579506389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1579506390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1579506390000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1579506390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1579506390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1579506390000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1579506390000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1579506393000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1579506394000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1579506395000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1579506405000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1579506405000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1579506397000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1579506393000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1579506394000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1579506396000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1579506396000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"ad237c3fdad00381bb9c2abe2b2eabcdfe1b999d","modified":1579506333000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1579506360000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1579506360000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1579506361000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1579506361000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1579506361000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1579506361000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1579506361000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1579506362000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1579506362000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1579506362000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1579506362000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1579506362000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1579506362000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1579506363000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1579506363000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1579506363000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1579506363000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1579506363000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1579506364000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1579506364000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1579506364000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1579506364000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1579506365000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1579506365000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1579506365000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1579506365000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1579506365000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1579506365000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1579506366000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1579506366000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1579506366000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1579506367000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1579506366000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1579506366000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1579506367000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1579506367000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1579506367000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1579506368000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1579506368000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1579506368000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1579506369000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1579506369000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1579506369000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1579506369000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1579506370000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1579506370000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1579506370000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1579506370000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1579506371000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1579506371000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1579506371000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1579506371000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1579506371000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1579506372000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1579506372000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1579506372000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1579506372000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1579506372000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1579506377000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1579506377000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1579506378000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1579506398000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1579506398000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1579506398000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1579506398000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1579506399000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1579506397000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1579506391000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1579506391000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1579506391000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1579506391000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1579506391000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1579506392000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1579506396000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1579506406000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1579506395000},{"_id":"themes/next/.git/objects/pack/pack-ac608cd16660603485e32e361724d51e80b35c47.idx","hash":"7b82d108f646520faa92de62b252d2ea2b939ad6","modified":1579506334000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1579506395000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1579506388000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1579506395000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1579506405000},{"_id":"themes/next/.git/objects/pack/pack-ac608cd16660603485e32e361724d51e80b35c47.pack","hash":"be3feef370d330d4c50b45fa0410f0847e4cb99b","modified":1579506334000}],"Category":[{"name":"ES5","_id":"ck5m75ghc0005lktvbx5235zl"},{"name":"ES6","_id":"ck5m75ghj000blktvnxmx6snx"},{"name":"继承","parent":"ck5m75ghc0005lktvbx5235zl","_id":"ck5m75ghq000plktvfd1foc68"},{"name":"Symbol","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75ghv000zlktv6hgaq1yg"},{"name":"Decorator","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75ghy0016lktv05sdtj0f"},{"name":"Promise","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi1001dlktvokxbqeaz"},{"name":"函数扩展","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi3001llktvfnlz95ht"},{"name":"Generator","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi5001rlktvhjls8z76"},{"name":"字符串扩展","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi80020lktv05cxkkeo"},{"name":"对象扩展","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gib0027lktvqh317sut"},{"name":"Iterator","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gid002flktvk86vwawi"},{"name":"数值扩展","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gif002llktvqpx6ssy3"},{"name":"数据结构","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gih002tlktvqljei58g"},{"name":"数组扩展","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gik0033lktvaumv3flz"},{"name":"Proxy和Reflect","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gim003blktvbm5jhh2t"},{"name":"模块化","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gio003jlktv8lnqefde"},{"name":"正则扩展","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gir003slktvy7q1aq60"},{"name":"类","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75giw0041lktvyb9nhwov"},{"name":"解构赋值","parent":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75giy0049lktvjci1t4hp"},{"name":"javascript","_id":"ck5m75gj1004hlktvivwo3pdp"},{"name":"js","_id":"ck5m75gj3004plktvbjuyneih"},{"name":"安装","_id":"ck5m75gjf005glktv5ppikq2e"},{"name":"http","_id":"ck5m75gjk005qlktv42etsx35"},{"name":"html","_id":"ck5m75gjm005wlktvtwp3dqjm"},{"name":"vue","_id":"ck5m75gjn0060lktvzwysrb47"},{"name":"数组和对象的深度复制","_id":"ck5m75gjs006blktvxpfub3k3"},{"name":"关于我","_id":"ck5m75gjt006glktvvp22di9d"},{"name":"node.js","_id":"ck5m75gju006jlktvqe5w0qy7"},{"name":"css","_id":"ck5m75gk2007glktv9hbgeovo"},{"name":"工具","_id":"ck5m75gk3007mlktv9xbfos4e"},{"name":"总结","_id":"ck5m75gk5007wlktvhcts5zxl"},{"name":"Function","parent":"ck5m75gj1004hlktvivwo3pdp","_id":"ck5m75gk70088lktvqz9580ou"},{"name":"MVVM","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gk8008hlktvw6zm5nyb"},{"name":"Object","parent":"ck5m75gj1004hlktvivwo3pdp","_id":"ck5m75gka008ulktvggzfrcbr"},{"name":"react","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkc0096lktvdnnkk166"},{"name":"事件","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkd009clktv0d0o0d3j"},{"name":"React","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gke009hlktvk827rs1f"},{"name":"数组和字符串","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkf009klktvxlqt4t51"},{"name":"正则表达式","_id":"ck5m75gkh009ylktvkbtcmdx8"},{"name":"async-await","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gki00a6lktvg9vjv1hw"},{"name":"vue","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkj00ablktvkz43mf5u"},{"name":"闭包","parent":"ck5m75gj1004hlktvivwo3pdp","_id":"ck5m75gkk00aglktvbjd2sgww"},{"name":"css","parent":"ck5m75gjm005wlktvtwp3dqjm","_id":"ck5m75gkk00aklktv76h59ly4"},{"name":"ie","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkl00aolktvjhesjbsf"},{"name":"继承","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkm00aulktv8emhrsa3"},{"name":"设计模式","parent":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkn00azlktvsi31huai"},{"name":"mongodb","parent":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gkn00b5lktvymeveawn"},{"name":"ajax","parent":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gko00b8lktvpl5hwscp"},{"name":"加密方式","parent":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gko00bclktvj9almpx5"},{"name":"nvm","parent":"ck5m75gjf005glktv5ppikq2e","_id":"ck5m75gkq00bjlktv4wfxo82k"},{"name":"sass","parent":"ck5m75gk2007glktv9hbgeovo","_id":"ck5m75gkr00bplktvsmt2nqi4"},{"name":"scss","parent":"ck5m75gk2007glktv9hbgeovo","_id":"ck5m75gks00btlktvgxs247et"},{"name":"vue-awesome-swiper","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gks00bylktvpthoaz4y"},{"name":"vue-cli3.0","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkt00c4lktvob5gb0tx"},{"name":"vue","parent":"ck5m75gk5007wlktvhcts5zxl","_id":"ck5m75gku00c8lktvu53jmqgy"},{"name":"vuex","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkv00cglktvymne60c1"},{"name":"axios","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkx00culktvlp2bjeg4"},{"name":"vue-router","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkz00d6lktv5m548zs0"},{"name":"webpack","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl000ddlktvfhqjiz46"},{"name":"component","parent":"ck5m75gke009hlktvk827rs1f","_id":"ck5m75gl100dhlktvyxosedu9"},{"name":"字符串","parent":"ck5m75gkf009klktvxlqt4t51","_id":"ck5m75gl100dnlktve4vjhmgw"},{"name":"watch","parent":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl300dxlktvhasy4hyg"},{"name":"面向对象","parent":"ck5m75gkn00azlktvsi31huai","_id":"ck5m75gl300e3lktvb7mif0t3"},{"name":"mongoose","parent":"ck5m75gkn00b5lktvymeveawn","_id":"ck5m75gl400e7lktvvv1yy68h"},{"name":"swiper","parent":"ck5m75gks00bylktvpthoaz4y","_id":"ck5m75gl600eklktvejhxquky"},{"name":"vuex","parent":"ck5m75gku00c8lktvu53jmqgy","_id":"ck5m75gl600erlktv50fxojf8"},{"name":"ajax","parent":"ck5m75gkx00culktvlp2bjeg4","_id":"ck5m75gl700evlktv1mm3cjae"}],"Data":[],"Page":[{"_content":"##\n```bash\nhexo clean // 清理缓存\nhexo g // 构建yemian\nhexo s // 启动本地服务器，实现本地预览\nhexo s // 发布到github\n```","source":"README.md","raw":"##\n```bash\nhexo clean // 清理缓存\nhexo g // 构建yemian\nhexo s // 启动本地服务器，实现本地预览\nhexo s // 发布到github\n```","date":"2020-01-20T08:21:18.686Z","updated":"2020-01-20T07:45:02.000Z","path":"README.html","title":"","comments":1,"layout":"page","_id":"ck5m75gd60000lktve9vfwyta"},{"title":"关于我","date":"2019-05-13T08:56:56.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2019-05-13 16:56:56\n---\n","updated":"2020-01-20T07:45:03.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck5m75gh70001lktvlplvucg0"},{"title":"文章分类","date":"2019-04-24T07:35:50.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-04-24 15:35:50\ntype: \"categories\"\n---","updated":"2020-01-20T07:45:03.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck5m75gha0003lktvubbwway1"},{"title":"标签","date":"2019-04-24T07:48:41.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-04-24 15:48:41\ntype: \"tags\"\n---","updated":"2020-01-20T07:45:03.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck5m75ghe0007lktv3jg22p85"}],"Post":[{"title":"ES5继承","date":"2019-04-29T03:00:00.000Z","_content":"\n## ES5继承\n<!-- more -->\n{% asset_img ES5_extends.png ES5构造函数继承和原型链继承组合继承 %}\n事实上，以下代码应该是实现了多态\n```javascript\n{\n  function Person (name, age) {\n    this.name = name;\n    this.age = age;\n    this.getName = function () {\n      console.log(this.name);\n    }\n  }\n  Object.assign(Person.prototype, {\n    sleep () {\n      console.log(\"sleepping\");\n    }\n  })\n  function Student (name, age) {\n    Person.call(this, name, age) // 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。\n  }\n  Student.prototype = new Person(); // 更好的实现方式是，可以把Student的prototype对象变成Person的实例对象，\n  // 则Student.prototype.__proto__ == Person.prototype，这样一来，Student的实例对象就可以通过查找\n  // 两层原型链的方式来调用Person原型上的方法了，即stu.__proto__.__proto__  =  Person.prototype,\n  // 这样的话，在Student中的原型链中也可以重写Person中的方法\n  Object.assign(Student.prototype, {\n    studentSleep () {\n      console.log(\"studentSleep\");\n    }\n  })\n  var stu = new Student('masia', 66);\n  console.log(stu)\n  console.log(stu.constructor.name) // 输出Person，\n  // 分析：stu是Student的实例对象，但是我们知道stu中没有constructor这个属性，\n  // 所以就会顺着原型链往上查找，即找到stu.__proto__，查看这个对象中有没有，\n  // 一般情况下是stu.__proto__对象就是Student.prototype对象，所以应该会有一个\n  // 名为constructor的属性，并且值位Student这个函数本身，\n  // 但是我们改变了Student.prototype的指向，并且把他指向了一个新的Person实例对象，\n  // 那自然Student.prototype这个对象的__proto__属性就不是指向Object构造函数的Prototype了，\n  // 而是Person的Prototype\n  // stu.__proto__.__proto__指向了Person.prototype\n  // 由于刚刚在stu.__proto__中没有找到constructor，拿就继续向上查找，并且\n  // 找到了stu.__proto__.__proto__,很显然，在这个对象中找到了constructor，\n  // 并且指向的是Person函数本身\n}\n```\n通过修改子类.prototype.__proto__实现继承，并且保证了子类的实例对象的constructor属性是创建他的类\n{% asset_img ES5_extends2.png ES5构造函数继承和原型链继承组合继承 %}\n\n```javascript\n{\n  function Person (name, age) {\n    this.name = name;\n    this.age = age;\n    this.getName = function () {\n      console.log(this.name);\n    }\n  }\n  Object.assign(Person.prototype, {\n    sleep () {\n      console.log(\"sleepping\");\n    }\n  })\n  function Student (name, age) {\n    Person.call(this, name, age) // 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。\n  }\n  Student.prototype.__proto__ = new Person(); // 只需要把这里修改一下，就可以了，\n  // 从而总结出一种思路：可以让子类的prototype.__proto__指向父类的实例对象从而实现继承，\n  // 虽然这样做，浪费了一定的空间，比如父类实例对象中的this.name 或者 this.age 这些属性加到子类的prototype.__proto__，\n  // 但其实我们在访问stu.name的时候，早在stu的实例对象就访问到了，所以也就意味着不会因为访问stu.name而一直顺着原型链网上找，\n  // 所以Student.prototype.__proto__.name永远不会被访问，但他依然占据空间。\n  Object.assign(Student.prototype, {\n    studentSleep () {\n      console.log(\"studentSleep\");\n    }\n  })\n  var stu = new Student('masia', 66);\n  console.log(stu)\n  console.log(stu.constructor.name) // Student\n}\n```","source":"_posts/ES5继承.md","raw":"---\ntitle: ES5继承\ncategories:\n  - ES5\n  - 继承\ntags:\n  - ES5\n  - 继承\ndate: 2019-04-29 11:00:00\n---\n\n## ES5继承\n<!-- more -->\n{% asset_img ES5_extends.png ES5构造函数继承和原型链继承组合继承 %}\n事实上，以下代码应该是实现了多态\n```javascript\n{\n  function Person (name, age) {\n    this.name = name;\n    this.age = age;\n    this.getName = function () {\n      console.log(this.name);\n    }\n  }\n  Object.assign(Person.prototype, {\n    sleep () {\n      console.log(\"sleepping\");\n    }\n  })\n  function Student (name, age) {\n    Person.call(this, name, age) // 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。\n  }\n  Student.prototype = new Person(); // 更好的实现方式是，可以把Student的prototype对象变成Person的实例对象，\n  // 则Student.prototype.__proto__ == Person.prototype，这样一来，Student的实例对象就可以通过查找\n  // 两层原型链的方式来调用Person原型上的方法了，即stu.__proto__.__proto__  =  Person.prototype,\n  // 这样的话，在Student中的原型链中也可以重写Person中的方法\n  Object.assign(Student.prototype, {\n    studentSleep () {\n      console.log(\"studentSleep\");\n    }\n  })\n  var stu = new Student('masia', 66);\n  console.log(stu)\n  console.log(stu.constructor.name) // 输出Person，\n  // 分析：stu是Student的实例对象，但是我们知道stu中没有constructor这个属性，\n  // 所以就会顺着原型链往上查找，即找到stu.__proto__，查看这个对象中有没有，\n  // 一般情况下是stu.__proto__对象就是Student.prototype对象，所以应该会有一个\n  // 名为constructor的属性，并且值位Student这个函数本身，\n  // 但是我们改变了Student.prototype的指向，并且把他指向了一个新的Person实例对象，\n  // 那自然Student.prototype这个对象的__proto__属性就不是指向Object构造函数的Prototype了，\n  // 而是Person的Prototype\n  // stu.__proto__.__proto__指向了Person.prototype\n  // 由于刚刚在stu.__proto__中没有找到constructor，拿就继续向上查找，并且\n  // 找到了stu.__proto__.__proto__,很显然，在这个对象中找到了constructor，\n  // 并且指向的是Person函数本身\n}\n```\n通过修改子类.prototype.__proto__实现继承，并且保证了子类的实例对象的constructor属性是创建他的类\n{% asset_img ES5_extends2.png ES5构造函数继承和原型链继承组合继承 %}\n\n```javascript\n{\n  function Person (name, age) {\n    this.name = name;\n    this.age = age;\n    this.getName = function () {\n      console.log(this.name);\n    }\n  }\n  Object.assign(Person.prototype, {\n    sleep () {\n      console.log(\"sleepping\");\n    }\n  })\n  function Student (name, age) {\n    Person.call(this, name, age) // 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。\n  }\n  Student.prototype.__proto__ = new Person(); // 只需要把这里修改一下，就可以了，\n  // 从而总结出一种思路：可以让子类的prototype.__proto__指向父类的实例对象从而实现继承，\n  // 虽然这样做，浪费了一定的空间，比如父类实例对象中的this.name 或者 this.age 这些属性加到子类的prototype.__proto__，\n  // 但其实我们在访问stu.name的时候，早在stu的实例对象就访问到了，所以也就意味着不会因为访问stu.name而一直顺着原型链网上找，\n  // 所以Student.prototype.__proto__.name永远不会被访问，但他依然占据空间。\n  Object.assign(Student.prototype, {\n    studentSleep () {\n      console.log(\"studentSleep\");\n    }\n  })\n  var stu = new Student('masia', 66);\n  console.log(stu)\n  console.log(stu.constructor.name) // Student\n}\n```","slug":"ES5继承","published":1,"updated":"2020-01-20T07:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gh70002lktvk4aan9gm","content":"<h2 id=\"ES5继承\"><a href=\"#ES5继承\" class=\"headerlink\" title=\"ES5继承\"></a>ES5继承</h2><a id=\"more\"></a>\n<img src=\"/2019/04/29/ES5继承/ES5_extends.png\" title=\"ES5构造函数继承和原型链继承组合继承\">\n<p>事实上，以下代码应该是实现了多态<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Person.prototype, &#123;</span><br><span class=\"line\">    sleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"sleepping\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name, age) <span class=\"comment\">// 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Student.prototype = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">// 更好的实现方式是，可以把Student的prototype对象变成Person的实例对象，</span></span><br><span class=\"line\">  <span class=\"comment\">// 则Student.prototype.__proto__ == Person.prototype，这样一来，Student的实例对象就可以通过查找</span></span><br><span class=\"line\">  <span class=\"comment\">// 两层原型链的方式来调用Person原型上的方法了，即stu.__proto__.__proto__  =  Person.prototype,</span></span><br><span class=\"line\">  <span class=\"comment\">// 这样的话，在Student中的原型链中也可以重写Person中的方法</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Student.prototype, &#123;</span><br><span class=\"line\">    studentSleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"studentSleep\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stu = <span class=\"keyword\">new</span> Student(<span class=\"string\">'masia'</span>, <span class=\"number\">66</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu.constructor.name) <span class=\"comment\">// 输出Person，</span></span><br><span class=\"line\">  <span class=\"comment\">// 分析：stu是Student的实例对象，但是我们知道stu中没有constructor这个属性，</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以就会顺着原型链往上查找，即找到stu.__proto__，查看这个对象中有没有，</span></span><br><span class=\"line\">  <span class=\"comment\">// 一般情况下是stu.__proto__对象就是Student.prototype对象，所以应该会有一个</span></span><br><span class=\"line\">  <span class=\"comment\">// 名为constructor的属性，并且值位Student这个函数本身，</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是我们改变了Student.prototype的指向，并且把他指向了一个新的Person实例对象，</span></span><br><span class=\"line\">  <span class=\"comment\">// 那自然Student.prototype这个对象的__proto__属性就不是指向Object构造函数的Prototype了，</span></span><br><span class=\"line\">  <span class=\"comment\">// 而是Person的Prototype</span></span><br><span class=\"line\">  <span class=\"comment\">// stu.__proto__.__proto__指向了Person.prototype</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于刚刚在stu.__proto__中没有找到constructor，拿就继续向上查找，并且</span></span><br><span class=\"line\">  <span class=\"comment\">// 找到了stu.__proto__.__proto__,很显然，在这个对象中找到了constructor，</span></span><br><span class=\"line\">  <span class=\"comment\">// 并且指向的是Person函数本身</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过修改子类.prototype.<strong>proto</strong>实现继承，并且保证了子类的实例对象的constructor属性是创建他的类<br><img src=\"/2019/04/29/ES5继承/ES5_extends2.png\" title=\"ES5构造函数继承和原型链继承组合继承\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Person.prototype, &#123;</span><br><span class=\"line\">    sleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"sleepping\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name, age) <span class=\"comment\">// 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Student.prototype.__proto__ = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">// 只需要把这里修改一下，就可以了，</span></span><br><span class=\"line\">  <span class=\"comment\">// 从而总结出一种思路：可以让子类的prototype.__proto__指向父类的实例对象从而实现继承，</span></span><br><span class=\"line\">  <span class=\"comment\">// 虽然这样做，浪费了一定的空间，比如父类实例对象中的this.name 或者 this.age 这些属性加到子类的prototype.__proto__，</span></span><br><span class=\"line\">  <span class=\"comment\">// 但其实我们在访问stu.name的时候，早在stu的实例对象就访问到了，所以也就意味着不会因为访问stu.name而一直顺着原型链网上找，</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以Student.prototype.__proto__.name永远不会被访问，但他依然占据空间。</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Student.prototype, &#123;</span><br><span class=\"line\">    studentSleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"studentSleep\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stu = <span class=\"keyword\">new</span> Student(<span class=\"string\">'masia'</span>, <span class=\"number\">66</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu.constructor.name) <span class=\"comment\">// Student</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"ES5继承\"><a href=\"#ES5继承\" class=\"headerlink\" title=\"ES5继承\"></a>ES5继承</h2>","more":"<img src=\"/2019/04/29/ES5继承/ES5_extends.png\" title=\"ES5构造函数继承和原型链继承组合继承\">\n<p>事实上，以下代码应该是实现了多态<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Person.prototype, &#123;</span><br><span class=\"line\">    sleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"sleepping\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name, age) <span class=\"comment\">// 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Student.prototype = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">// 更好的实现方式是，可以把Student的prototype对象变成Person的实例对象，</span></span><br><span class=\"line\">  <span class=\"comment\">// 则Student.prototype.__proto__ == Person.prototype，这样一来，Student的实例对象就可以通过查找</span></span><br><span class=\"line\">  <span class=\"comment\">// 两层原型链的方式来调用Person原型上的方法了，即stu.__proto__.__proto__  =  Person.prototype,</span></span><br><span class=\"line\">  <span class=\"comment\">// 这样的话，在Student中的原型链中也可以重写Person中的方法</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Student.prototype, &#123;</span><br><span class=\"line\">    studentSleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"studentSleep\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stu = <span class=\"keyword\">new</span> Student(<span class=\"string\">'masia'</span>, <span class=\"number\">66</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu.constructor.name) <span class=\"comment\">// 输出Person，</span></span><br><span class=\"line\">  <span class=\"comment\">// 分析：stu是Student的实例对象，但是我们知道stu中没有constructor这个属性，</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以就会顺着原型链往上查找，即找到stu.__proto__，查看这个对象中有没有，</span></span><br><span class=\"line\">  <span class=\"comment\">// 一般情况下是stu.__proto__对象就是Student.prototype对象，所以应该会有一个</span></span><br><span class=\"line\">  <span class=\"comment\">// 名为constructor的属性，并且值位Student这个函数本身，</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是我们改变了Student.prototype的指向，并且把他指向了一个新的Person实例对象，</span></span><br><span class=\"line\">  <span class=\"comment\">// 那自然Student.prototype这个对象的__proto__属性就不是指向Object构造函数的Prototype了，</span></span><br><span class=\"line\">  <span class=\"comment\">// 而是Person的Prototype</span></span><br><span class=\"line\">  <span class=\"comment\">// stu.__proto__.__proto__指向了Person.prototype</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于刚刚在stu.__proto__中没有找到constructor，拿就继续向上查找，并且</span></span><br><span class=\"line\">  <span class=\"comment\">// 找到了stu.__proto__.__proto__,很显然，在这个对象中找到了constructor，</span></span><br><span class=\"line\">  <span class=\"comment\">// 并且指向的是Person函数本身</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过修改子类.prototype.<strong>proto</strong>实现继承，并且保证了子类的实例对象的constructor属性是创建他的类<br><img src=\"/2019/04/29/ES5继承/ES5_extends2.png\" title=\"ES5构造函数继承和原型链继承组合继承\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Person.prototype, &#123;</span><br><span class=\"line\">    sleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"sleepping\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name, age) <span class=\"comment\">// 先继承Person构造函数中的属性，在这一句之后也可以改写Person构造函数中的属性，但这种方式不能继承父类原型对象上的属性。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Student.prototype.__proto__ = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">// 只需要把这里修改一下，就可以了，</span></span><br><span class=\"line\">  <span class=\"comment\">// 从而总结出一种思路：可以让子类的prototype.__proto__指向父类的实例对象从而实现继承，</span></span><br><span class=\"line\">  <span class=\"comment\">// 虽然这样做，浪费了一定的空间，比如父类实例对象中的this.name 或者 this.age 这些属性加到子类的prototype.__proto__，</span></span><br><span class=\"line\">  <span class=\"comment\">// 但其实我们在访问stu.name的时候，早在stu的实例对象就访问到了，所以也就意味着不会因为访问stu.name而一直顺着原型链网上找，</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以Student.prototype.__proto__.name永远不会被访问，但他依然占据空间。</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.assign(Student.prototype, &#123;</span><br><span class=\"line\">    studentSleep () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"studentSleep\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stu = <span class=\"keyword\">new</span> Student(<span class=\"string\">'masia'</span>, <span class=\"number\">66</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(stu.constructor.name) <span class=\"comment\">// Student</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ES6梳理-Decorator","date":"2019-07-11T02:48:33.000Z","_content":"\n# Decorator（修饰器的意思）\n+ 基本概念\n+ 基本用法\n<!-- more -->\n### 基本概念\nDecorator是一个函数，用来修改类的行为。\n### 基本用法\n需要额外安装包 babel-plugin-transform-decorators-legacy \n```javascript\n// 修饰器放在方法前面\n{\n  // 限制某个属性是只读的\n  let readonly = function (target, name, descriptor) {\n                          // target是目标类本身\n                          // name是要修改的属性\n                          // descriptor是要改动的配置\n    descriptor.writable = false;\n    return descriptor\n  }\n\n  class Test {\n    @readonly\n    time () {\n      return '2017-03-11';\n    }\n  }\n  \n  let test = new Test();\n  console.log(test.time()); // '2017-03-11'\n  test.time = function () {} // 不允许修改\n}  \n// 修饰器放在类前面\n{\n  let typename = function (target, name, descriptor) {\n    target.myName = 'hello';\n  }\n\n  @typename\n  class Test {\n\n  }\n\n  console.log('类修饰符', Test.myName);// 类修饰符 hello\n}\n```\n### 使用第三方修饰器的js库：core-decorators\nnpm i core-decorators\n```javascript\n// 日志系统\n {\n  let log = (type) => {\n    return function (target, name, descriptor) {\n      let src_method = descriptor.value; // 原始的方法体\n      descriptor.value = (...arg) => {\n        src_method.apply(target, arg);\n        console.info(`log ${type}`);\n      }\n    }\n  }\n\n  // 广告类\n  class AD {\n    @log('show')\n    show () {\n      console.info('ad is show');\n    }\n    @log('click')\n    click () {\n      console.info('ad is click');\n    }\n  }\n}\n```","source":"_posts/ES6梳理-Decorator.md","raw":"---\ntitle: ES6梳理-Decorator\ndate: 2019-07-11 10:48:33\ncategories:\n  - ES6\n  - Decorator\ntags:\n  - ES6\n  - Decorator\n---\n\n# Decorator（修饰器的意思）\n+ 基本概念\n+ 基本用法\n<!-- more -->\n### 基本概念\nDecorator是一个函数，用来修改类的行为。\n### 基本用法\n需要额外安装包 babel-plugin-transform-decorators-legacy \n```javascript\n// 修饰器放在方法前面\n{\n  // 限制某个属性是只读的\n  let readonly = function (target, name, descriptor) {\n                          // target是目标类本身\n                          // name是要修改的属性\n                          // descriptor是要改动的配置\n    descriptor.writable = false;\n    return descriptor\n  }\n\n  class Test {\n    @readonly\n    time () {\n      return '2017-03-11';\n    }\n  }\n  \n  let test = new Test();\n  console.log(test.time()); // '2017-03-11'\n  test.time = function () {} // 不允许修改\n}  \n// 修饰器放在类前面\n{\n  let typename = function (target, name, descriptor) {\n    target.myName = 'hello';\n  }\n\n  @typename\n  class Test {\n\n  }\n\n  console.log('类修饰符', Test.myName);// 类修饰符 hello\n}\n```\n### 使用第三方修饰器的js库：core-decorators\nnpm i core-decorators\n```javascript\n// 日志系统\n {\n  let log = (type) => {\n    return function (target, name, descriptor) {\n      let src_method = descriptor.value; // 原始的方法体\n      descriptor.value = (...arg) => {\n        src_method.apply(target, arg);\n        console.info(`log ${type}`);\n      }\n    }\n  }\n\n  // 广告类\n  class AD {\n    @log('show')\n    show () {\n      console.info('ad is show');\n    }\n    @log('click')\n    click () {\n      console.info('ad is click');\n    }\n  }\n}\n```","slug":"ES6梳理-Decorator","published":1,"updated":"2020-01-20T07:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gha0004lktv8u0xikyv"},{"title":"ES6梳理-Generator","date":"2019-07-10T10:48:33.000Z","_content":"\n# Generator\n+ 基本概念\n+ next函数的用法\n+ yield*的语法\n\n<!-- more -->\n### 基本概念\nGenerator通俗的来讲，就是异步编程的一种解决方案，比回调函数以及Promise更加高级\n### next函数\n```javascript\n{\n  let tell = function* () {\n    yield 'a';\n    yield 'b';\n    return 'c';\n  }\n  let k = tell();\n  console.log(k.next());\n  console.log(k.next());\n  console.log(k.next());\n  console.log(k.next());\n}\n```\n{% asset_img Generator1.png console.log(k.next()); %}\n### yield*的语法\n\n### 使用Generator也可以作为遍历器的返回值\n```javascript\n{\n  let obj = {};\n  // 不同通过手写Iterator的方式，而是通过创建Generator函数的方式实现对象的遍历器\n  // 写法比自定义编写的形式简单\n  obj[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n  }\n  for (let value of obj) {\n    console.log(value);\n    /*\n      1\n      2\n      3\n    */\n  }\n}\n```\n### Generator状态机\nGenerator状态机的运用，假如只有A、B、C三种状态\n```javascript\n{\n  let state = function* () {\n    while (1) {\n      yield 'A',\n      yield 'B',\n      yield 'C'\n    }\n  }\n  let status = state();\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // {value: \"B\", done: false}\n  console.log(status.next()); // {value: \"C\", done: false}\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // .. \n  console.log(status.next()); // {value: \"A\", done: false}\n}\n```\n### 利用闭包模拟实现状态机\n```javascript\n{\n  function mockStatemachine (arr) {\n    let arrLen = arr.length;\n    let index = 0;\n    return {\n      next () {\n        return {\n          value: arr[index++%arrLen],\n          done: false\n        }\n      }\n    }\n  }\n  let state = mockStatemachine(['A', 'B', 'C', 'D']);\n  console.log(state.next()); // {value: \"A\", done: false}\n  console.log(state.next()); // {value: \"B\", done: false}\n  console.log(state.next()); // {value: \"C\", done: false}\n  console.log(state.next()); // {value: \"D\", done: false}\n  console.log(state.next()); // {value: \"A\", done: false}\n  console.log(state.next()); // {value: \"B\", done: false}\n  console.log(state.next()); // {value: \"C\", done: false}\n  console.log(state.next()); // {value: \"D\", done: false}\n}\n```\n### Generator中的async\n```javascript\n{\n  let state = async function () {\n    while (1) {\n      await 'A',\n      await 'B',\n      await 'C'\n    }\n  }\n  let status = state();\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // {value: \"B\", done: false}\n  console.log(status.next()); // {value: \"C\", done: false}\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // .. \n  console.log(status.next()); // {value: \"A\", done: false}\n}\n```\n### 什么情况下，Generator有他最大的作用，适用场景\n+ 问题：\n假如有一个抽奖的业务逻辑，比如当前用户下可抽奖的次数有5次，用户点击一个，可抽奖次数变为4次，再点一次，可抽奖次数变为3次，这个剩余抽奖次数的逻辑，前端和后端都要做限制。\n+ 思路： \n之前的做法是设置一个全局变量，去保存抽奖的次数，\n  1. 但其实是不安全的，因为一旦用户知道记录抽奖次数的变量，并且做一些修改，你就不能限制用户的抽奖次数了\n  2. 尽量少写全局变量，影响性能\n```javascript\n{\n  let draw = function (count) {\n    // 具体抽奖逻辑，这里要注意的是，这里完全是验证是否中奖的逻辑，并且和可抽奖次数的判断完全隔离开，\n    // 并且通过Generator来控制可抽奖次数\n    console.info(`剩余${count}次`);\n  }\n  let residue = function* (count) {\n    while (count) {\n      count --;\n      yield draw(count);\n    }\n  }\n  let star = residue(5);\n  let btn = document.createElement('button');\n  btn.id = 'start';\n  btn.innerText = '抽奖';\n  btn.addEventListener('click', function () {\n    star.next();\n  })\n  document.body.appendChild(btn);\n\n  // 点击5次答应的结果\n  // 剩余4次\n  // 剩余3次\n  // 剩余2次\n  // 剩余1次\n  // 剩余1次\n}\n```\n+ 问题2:（长轮询）\n服务端的某一个数据定期的发生变化，前端需要定期的去后端取数据，因为http是无状态的连接，我们要怎么去实时获取后端变化的数据呢？一种是长轮询，还有一种是webSocket，因为webSocket对浏览器支持的不好。原来的长轮询是利用定时器去实现，现在使用Generator函数去实现，会让程序变的更加优雅。\n```javascript\n{\n  // 长论询\n  let ajax = function* () {\n    yield new Promise(function (resolve, reject) {\n      setTimeout(function () { // 这部分模拟的是获取真实接口数据\n        resolve({code: 1})\n      }, 200);  \n    })\n  }\n\n  let pull = function () {\n    let generator = ajax(); // 对Generator实例化\n    let step = generator.next();\n    step.value.then(function (d) {\n      if (d.code!=0) {\n        setTimeout(function () {\n          console.log('wait');\n          pull();\n        }, 1000)\n      } else {\n        console.log(d)\n      }\n    })\n  }\n  pull();\n}\n\n```\n\n### 使用Generator和不使用Generator做对比\n```javascript\n// 使用Generator\n{\n  let state = function* (arr) {\n    for (item of arr) {\n      yield item;\n    }\n  }\n  let k = state([111, 222, 333]);\n  console.log(k.next()); // {value: 111, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: undefined, done: true}\n}\n// 不使用Generator\n{\n  let state = function (arr) {\n    let index = 0;\n    return {\n      next () {\n        while (index < arr.length) {\n          return {\n            value: arr[index++],\n            done: false\n          } \n        }\n        return {\n          value: arr[index],\n          done: true\n        }\n      }\n    }\n  }\n  let k = state([111, 222, 333]);\n  console.log(k.next()); // {value: 111, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: undefined, done: true}\n}\n```\n### yield使用对应关系\n{% asset_img Generator2.png yield使用对应关系 %}\n{% asset_img Generator3.png 使用Generator和不使用Generator %}","source":"_posts/ES6梳理-Generator.md","raw":"---\ntitle: ES6梳理-Generator\ndate: 2019-07-10 18:48:33\ncategories:\n  - ES6\n  - Generator\ntags:\n  - ES6\n  - Generator\n---\n\n# Generator\n+ 基本概念\n+ next函数的用法\n+ yield*的语法\n\n<!-- more -->\n### 基本概念\nGenerator通俗的来讲，就是异步编程的一种解决方案，比回调函数以及Promise更加高级\n### next函数\n```javascript\n{\n  let tell = function* () {\n    yield 'a';\n    yield 'b';\n    return 'c';\n  }\n  let k = tell();\n  console.log(k.next());\n  console.log(k.next());\n  console.log(k.next());\n  console.log(k.next());\n}\n```\n{% asset_img Generator1.png console.log(k.next()); %}\n### yield*的语法\n\n### 使用Generator也可以作为遍历器的返回值\n```javascript\n{\n  let obj = {};\n  // 不同通过手写Iterator的方式，而是通过创建Generator函数的方式实现对象的遍历器\n  // 写法比自定义编写的形式简单\n  obj[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n  }\n  for (let value of obj) {\n    console.log(value);\n    /*\n      1\n      2\n      3\n    */\n  }\n}\n```\n### Generator状态机\nGenerator状态机的运用，假如只有A、B、C三种状态\n```javascript\n{\n  let state = function* () {\n    while (1) {\n      yield 'A',\n      yield 'B',\n      yield 'C'\n    }\n  }\n  let status = state();\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // {value: \"B\", done: false}\n  console.log(status.next()); // {value: \"C\", done: false}\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // .. \n  console.log(status.next()); // {value: \"A\", done: false}\n}\n```\n### 利用闭包模拟实现状态机\n```javascript\n{\n  function mockStatemachine (arr) {\n    let arrLen = arr.length;\n    let index = 0;\n    return {\n      next () {\n        return {\n          value: arr[index++%arrLen],\n          done: false\n        }\n      }\n    }\n  }\n  let state = mockStatemachine(['A', 'B', 'C', 'D']);\n  console.log(state.next()); // {value: \"A\", done: false}\n  console.log(state.next()); // {value: \"B\", done: false}\n  console.log(state.next()); // {value: \"C\", done: false}\n  console.log(state.next()); // {value: \"D\", done: false}\n  console.log(state.next()); // {value: \"A\", done: false}\n  console.log(state.next()); // {value: \"B\", done: false}\n  console.log(state.next()); // {value: \"C\", done: false}\n  console.log(state.next()); // {value: \"D\", done: false}\n}\n```\n### Generator中的async\n```javascript\n{\n  let state = async function () {\n    while (1) {\n      await 'A',\n      await 'B',\n      await 'C'\n    }\n  }\n  let status = state();\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // {value: \"B\", done: false}\n  console.log(status.next()); // {value: \"C\", done: false}\n  console.log(status.next()); // {value: \"A\", done: false}\n  console.log(status.next()); // .. \n  console.log(status.next()); // {value: \"A\", done: false}\n}\n```\n### 什么情况下，Generator有他最大的作用，适用场景\n+ 问题：\n假如有一个抽奖的业务逻辑，比如当前用户下可抽奖的次数有5次，用户点击一个，可抽奖次数变为4次，再点一次，可抽奖次数变为3次，这个剩余抽奖次数的逻辑，前端和后端都要做限制。\n+ 思路： \n之前的做法是设置一个全局变量，去保存抽奖的次数，\n  1. 但其实是不安全的，因为一旦用户知道记录抽奖次数的变量，并且做一些修改，你就不能限制用户的抽奖次数了\n  2. 尽量少写全局变量，影响性能\n```javascript\n{\n  let draw = function (count) {\n    // 具体抽奖逻辑，这里要注意的是，这里完全是验证是否中奖的逻辑，并且和可抽奖次数的判断完全隔离开，\n    // 并且通过Generator来控制可抽奖次数\n    console.info(`剩余${count}次`);\n  }\n  let residue = function* (count) {\n    while (count) {\n      count --;\n      yield draw(count);\n    }\n  }\n  let star = residue(5);\n  let btn = document.createElement('button');\n  btn.id = 'start';\n  btn.innerText = '抽奖';\n  btn.addEventListener('click', function () {\n    star.next();\n  })\n  document.body.appendChild(btn);\n\n  // 点击5次答应的结果\n  // 剩余4次\n  // 剩余3次\n  // 剩余2次\n  // 剩余1次\n  // 剩余1次\n}\n```\n+ 问题2:（长轮询）\n服务端的某一个数据定期的发生变化，前端需要定期的去后端取数据，因为http是无状态的连接，我们要怎么去实时获取后端变化的数据呢？一种是长轮询，还有一种是webSocket，因为webSocket对浏览器支持的不好。原来的长轮询是利用定时器去实现，现在使用Generator函数去实现，会让程序变的更加优雅。\n```javascript\n{\n  // 长论询\n  let ajax = function* () {\n    yield new Promise(function (resolve, reject) {\n      setTimeout(function () { // 这部分模拟的是获取真实接口数据\n        resolve({code: 1})\n      }, 200);  \n    })\n  }\n\n  let pull = function () {\n    let generator = ajax(); // 对Generator实例化\n    let step = generator.next();\n    step.value.then(function (d) {\n      if (d.code!=0) {\n        setTimeout(function () {\n          console.log('wait');\n          pull();\n        }, 1000)\n      } else {\n        console.log(d)\n      }\n    })\n  }\n  pull();\n}\n\n```\n\n### 使用Generator和不使用Generator做对比\n```javascript\n// 使用Generator\n{\n  let state = function* (arr) {\n    for (item of arr) {\n      yield item;\n    }\n  }\n  let k = state([111, 222, 333]);\n  console.log(k.next()); // {value: 111, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: undefined, done: true}\n}\n// 不使用Generator\n{\n  let state = function (arr) {\n    let index = 0;\n    return {\n      next () {\n        while (index < arr.length) {\n          return {\n            value: arr[index++],\n            done: false\n          } \n        }\n        return {\n          value: arr[index],\n          done: true\n        }\n      }\n    }\n  }\n  let k = state([111, 222, 333]);\n  console.log(k.next()); // {value: 111, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: 222, done: false}\n  console.log(k.next()); // {value: undefined, done: true}\n}\n```\n### yield使用对应关系\n{% asset_img Generator2.png yield使用对应关系 %}\n{% asset_img Generator3.png 使用Generator和不使用Generator %}","slug":"ES6梳理-Generator","published":1,"updated":"2020-01-20T07:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghe0008lktv3jy65u90"},{"title":"ES6梳理-Iterator","date":"2019-07-10T10:48:33.000Z","_content":"# Iterator\n数组和对象数据结构本来是不同的，那么怎么样使不同的数据结构操作变得统一起来\n<!-- more -->\n### for of 实现的原理实际上就是不断调用Iterator的过程\n```javascript\n// 数组对象默认定义了Iterator接口\n{\n  let arr = ['hello', 'world'];\n  let map = arr[Symbol.iterator]();\n  console.log(map.next()); // {value: \"hello\", done: false}\n  console.log(map.next()); // {value: \"world\", done: false}\n  console.log(map.next()); // {value: undefined, done: true}\n}  \n// obj本身没有默认定义Iterator接口，所以不能使用for of，但是自定了Iterator之后，就可以使用for of了\n{\n  let obj = {\n    start: [1, 3, 2],\n    end: [7, 8, 9],\n\n    // 定义一个iterator接口方法\n    [Symbol.iterator] () {\n      let self = this;\n      let index = 0;\n      let arr = self.start.concat(self.end);\n      let len = arr.length;\n      return {\n        next () {\n          if (index < len) {\n            return {\n              value: arr[index++],\n              done: false\n            }\n          } else {\n            return {\n              value: arr[index++],\n              done: true\n            }\n          }\n        }\n      }\n    }\n  }\n  // 输出obj，见图\n  console.log(obj);\n  // 使用for of 自动迭代\n  for (let key of obj) {\n    console.log(key); // 但是只输出了value\n    /*\n      1\n      3\n      2\n      7\n      8\n      9\n    */\n  }\n\n  // 手动迭代\n  let objMap = obj[Symbol.iterator](); // 其实就是利用闭包，形成了一个不可销毁的作用域\n  console.log(objMap.next()); // {value: 1, done: false}\n  console.log(objMap.next()); // {value: 3, done: false}\n  console.log(objMap.next()); // {value: 2, done: false}\n  console.log(objMap.next()); // {value: 7, done: false}\n  console.log(objMap.next()); // {value: 8, done: false}\n  console.log(objMap.next()); // {value: 9, done: false}\n  console.log(objMap.next()); // {value: undefined, done: true} \n}\n```\n{% asset_img Iterator_obj.png console.log(obj) %}\n\n### 手动模拟一个Iterator\n原理就是利用函数的闭包，把函数内部的引用成员保存到了函数的外部，是得函数本身的执行栈不可释放，进而还可以继续使用函数内部的变量实现的。\n```javascript\n{\n  let obj = {\n    start: [1, 2, 3, 4],\n    end: [5, 6, 7],\n    iterator () {\n      let self = this;\n      let arr = self.start.concat(self.end);\n      let index = 0;\n      return {\n        next () {\n          if (index < arr.length) {\n            return {\n              value: arr[index++],\n              done: false\n            }\n          } else {\n            return {\n              value: arr[index++],\n              done: true\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let iterator = obj.iterator();\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n}\n```\n### 利用高阶函数实现抽奖，并且封闭了抽奖次数变量\n```javascript\n{\n  // 1. 实现抽奖次数限制\n  function residue () {\n    let count = 5; // 初始化抽奖次数\n    return {\n      next () {\n        while (count>0) {\n          return {\n            count: --count,\n            done: false\n          }\n        }\n        return {\n          count: --count, // 应该是-1了\n          done: true\n        }\n      }\n    }\n  }\n\n  // 1. 抽奖点击功能\n  function prizeDraw (iteratorObj) {\n    let btn = document.createElement('button');\n    btn.innerText = \"抽奖\";\n    btn.addEventListener('click', function () {\n      remainder(iteratorObj.next());\n    })\n    document.body.appendChild(btn);\n  } \n\n  // 2. 判断抽奖剩余次数\n  function remainder (iteratorNext) {\n    if (!iteratorNext.done) {\n      console.log('还剩余'+iteratorNext.count+'次');\n    } else {\n      console.log('你没机会了')\n    }\n  }\n  \n  // * 初始化抽奖功能\n  prizeDraw(residue());\n  \n}\n```","source":"_posts/ES6梳理-Iterator.md","raw":"---\ntitle: ES6梳理-Iterator\ndate: 2019-07-10 18:48:33\ncategories:\n  - ES6\n  - Iterator\ntags:\n  - ES6\n  - Iterator\n---\n# Iterator\n数组和对象数据结构本来是不同的，那么怎么样使不同的数据结构操作变得统一起来\n<!-- more -->\n### for of 实现的原理实际上就是不断调用Iterator的过程\n```javascript\n// 数组对象默认定义了Iterator接口\n{\n  let arr = ['hello', 'world'];\n  let map = arr[Symbol.iterator]();\n  console.log(map.next()); // {value: \"hello\", done: false}\n  console.log(map.next()); // {value: \"world\", done: false}\n  console.log(map.next()); // {value: undefined, done: true}\n}  \n// obj本身没有默认定义Iterator接口，所以不能使用for of，但是自定了Iterator之后，就可以使用for of了\n{\n  let obj = {\n    start: [1, 3, 2],\n    end: [7, 8, 9],\n\n    // 定义一个iterator接口方法\n    [Symbol.iterator] () {\n      let self = this;\n      let index = 0;\n      let arr = self.start.concat(self.end);\n      let len = arr.length;\n      return {\n        next () {\n          if (index < len) {\n            return {\n              value: arr[index++],\n              done: false\n            }\n          } else {\n            return {\n              value: arr[index++],\n              done: true\n            }\n          }\n        }\n      }\n    }\n  }\n  // 输出obj，见图\n  console.log(obj);\n  // 使用for of 自动迭代\n  for (let key of obj) {\n    console.log(key); // 但是只输出了value\n    /*\n      1\n      3\n      2\n      7\n      8\n      9\n    */\n  }\n\n  // 手动迭代\n  let objMap = obj[Symbol.iterator](); // 其实就是利用闭包，形成了一个不可销毁的作用域\n  console.log(objMap.next()); // {value: 1, done: false}\n  console.log(objMap.next()); // {value: 3, done: false}\n  console.log(objMap.next()); // {value: 2, done: false}\n  console.log(objMap.next()); // {value: 7, done: false}\n  console.log(objMap.next()); // {value: 8, done: false}\n  console.log(objMap.next()); // {value: 9, done: false}\n  console.log(objMap.next()); // {value: undefined, done: true} \n}\n```\n{% asset_img Iterator_obj.png console.log(obj) %}\n\n### 手动模拟一个Iterator\n原理就是利用函数的闭包，把函数内部的引用成员保存到了函数的外部，是得函数本身的执行栈不可释放，进而还可以继续使用函数内部的变量实现的。\n```javascript\n{\n  let obj = {\n    start: [1, 2, 3, 4],\n    end: [5, 6, 7],\n    iterator () {\n      let self = this;\n      let arr = self.start.concat(self.end);\n      let index = 0;\n      return {\n        next () {\n          if (index < arr.length) {\n            return {\n              value: arr[index++],\n              done: false\n            }\n          } else {\n            return {\n              value: arr[index++],\n              done: true\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let iterator = obj.iterator();\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n  console.log(iterator.next());\n}\n```\n### 利用高阶函数实现抽奖，并且封闭了抽奖次数变量\n```javascript\n{\n  // 1. 实现抽奖次数限制\n  function residue () {\n    let count = 5; // 初始化抽奖次数\n    return {\n      next () {\n        while (count>0) {\n          return {\n            count: --count,\n            done: false\n          }\n        }\n        return {\n          count: --count, // 应该是-1了\n          done: true\n        }\n      }\n    }\n  }\n\n  // 1. 抽奖点击功能\n  function prizeDraw (iteratorObj) {\n    let btn = document.createElement('button');\n    btn.innerText = \"抽奖\";\n    btn.addEventListener('click', function () {\n      remainder(iteratorObj.next());\n    })\n    document.body.appendChild(btn);\n  } \n\n  // 2. 判断抽奖剩余次数\n  function remainder (iteratorNext) {\n    if (!iteratorNext.done) {\n      console.log('还剩余'+iteratorNext.count+'次');\n    } else {\n      console.log('你没机会了')\n    }\n  }\n  \n  // * 初始化抽奖功能\n  prizeDraw(residue());\n  \n}\n```","slug":"ES6梳理-Iterator","published":1,"updated":"2020-01-20T07:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghh0009lktvnkwg064w"},{"title":"ES6梳理-Proxy和Reflect","date":"2019-07-08T09:57:54.000Z","_content":"\n# Proxy和Reflect\n+ Proxy和Reflect的概念\n+ Proxy和Reflect的适用场景 \n<!--  more -->\n## 概念：\n+ Proxy是代理的意思，连接了用户和对象之间的层，Reflect是反射的意思\n+ Proxy和Reflect的使用方法基本相同\n## Proxy使用\n+ 基本使用\n```javascript\n{\n  // 创建一个类似于供应商的对象\n  let obj = {\n    time: '2017-01-11',\n    name: 'net',\n    _r: 123\n  };\n  // 创建一个Proxy对象\n  let monitor = new Proxy(obj, {\n    // 拦截对象属性读取\n    get (target, key) {\n      return target[key].replace('2017', '2018')\n    },\n    // 拦截设置对象属性\n    set (target, key, value) {\n      // 假如我们做一个只能修改指定的属性name\n      if (key === 'name') {\n        return target[key] = value;\n      } else {\n        return target[key];\n      }\n    }\n  });\n  // 用户操作的是monitor对象，不管用户对monitor对象执行什么操作，都是由Proxy传递给obj对象\n  // 因为obj对象对于用户来说是不可见的，所以monitor.time这个操作被Proxy中的get方法拦截了，\n  // 意为读取obj中的某个属性，并且将这个属性的值做一些修改\n  console.log('get', monitor.time); // get 2018-01-11\n  monitor.time = '2018';\n  console.log(monitor.time); // 2018-01-11 发现没有修改为 '2018'\n  monitor.name = 'masia'; \n  console.log(monitor.name); // masia 发现修改成功了\n}\n```\n+ 常用属性\n```javascript\n{\n  // 创建一个类似于供应商的对象\n  let obj = {\n    time: '2017-01-11',\n    name: 'net',\n    _r: 123\n  };\n  // 创建一个Proxy对象\n  let monitor = new Proxy(obj, {\n    // 拦截对象属性读取\n    get (target, key) {\n      return target[key].replace('2017', '2018')\n    },\n    // 拦截设置对象属性\n    set (target, key, value) {\n      // 假如我们做一个只能修改指定的属性name\n      if (key === 'name') {\n        return target[key] = value;\n      } else {\n        return target[key];\n      }\n    },\n    // 暴露指定属性name,其他的都不暴露（这里暴露指的是使用in关键字找不到设置限制的属性）\n    has (target, key) {\n      if (key === 'name') {\n        return target[key];\n      } else {\n        return false;\n      }\n    },\n    // 拦截删除\n    deleteProperty (target, key) {\n      // 比如指定属性是\"_\"开头的，允许删除，其他的则不允许\n      if (key.indexOf('_') > -1) {\n        delete target[key];\n      } else {\n        return target[key];\n      }\n    },\n    // 拦截Object.keys, ObjectgetOwnPropertySymbols, Object.getOwnPropertyNames\n    ownKeys (target) {\n      return Object.keys(target).filter(item=>item!='time')\n    }\n  });\n  console.log(monitor.name); // masia \n  console.log(monitor.time); // 2018-01-11 设置了has,但是依然可以访问到\n  console.log('name' in monitor) // true \n  console.log('time' in monitor) // false 但是使用in关键字检查对象中是否包含某个属性时，却找不到 \n  \n  // 尝试删除time属性\n  delete monitor.time;\n  console.log(monitor); // Proxy {time: \"2017-01-11\", name: \"net\", _r: 123} 发现time属性还在\n  delete monitor._r;\n  console.log(monitor); // Proxy {time: \"2017-01-11\", name: \"net\"} 发现_r属性被删除了\n\n  // \n  console.log('ownKeys', Object.keys(monitor)); // ownKeys [\"name\"] 把name属性拦截掉了\n}\n```\n## Reflect使用\n```javascript\n{\n  // 创建一个类似于供应商的对象\n  let obj = {\n    time: '2017-01-11',\n    name: 'net',\n    _r: 123\n  };\n\n  // ES5 使用obj.time来取值\n  // Proxy还要通过创建实例monitor来取值\n  // Reflect要使用以下的方式来取值\n  console.log('Reflect get', Reflect.get(obj, 'time')); // Reflect get 2017-01-11\n  Reflect.set(obj, 'name', 'masia');\n  console.log(obj.name); // masia\n  console.log(Reflect.has(obj, 'name')); // true\n}\n```\n\n## Proxy和Reflect的使用场景\n```javascript\n{\n  // 在开发过程中经常要对一些信息进行校验，比如登录的时候手机号格式是否正确\n  // 解耦校验模块\n  function validator (target, validator) {\n    return new Proxy (target, {\n      _validator: validator,\n      set (target, key, value, proxy) {\n        // 判断当前对象有没有指定的key值，如果没有则不能对他赋值\n        if (target.hasOwnProperty(key)) {\n          let va = this._validator[key];\n          if (!!va(value)) {\n            return Reflect.set(target, key, value, proxy); \n          } else {\n            throw Error(`不能设置${key}到${value}`)\n          }\n        } else {\n          throw Error(`${key} 不存在`)\n        }\n      }\n    })\n  }\n\n  const personValidators = {\n    name (val) {\n      return typeof val === 'string';\n    },\n    age (val) {\n      return typeof val === 'number' && val > 18\n    }\n  }\n  \n  class Person {\n    constructor (name, age) {\n      this.name = name;\n      this.age = age;\n      return validator(this, personValidators); // Proxy对象代理了Person对象实例\n    }\n  }\n\n  const person = new Person('lilei', 30);\n  console.info(person); // Proxy {name: \"lilei\", age: 30}\n  // person.name = 48; // Uncaught Error: 不能设置name到48\n  // 因为有了代理，就不能对对象的实例属性做一些随意的操作了，这在ES5中是不能实现的\n  person.name = 'han mei';\n  console.info(person); // Proxy {name: \"han mei\", age: 30}\n  /* 总结：传统的做法，对某个属性进行赋值的时候，要对赋值的属性进行一些判断，\n    通常这些操作是在创建完了对象之后做的，并没有在使用类定义的时候做这件事情，\n    这就好比这个对象创建出来的时候是完整且干净的，就好比一块原材料，而我们后天\n    往上加饰的雕琢，使他有了更多的功能和限制。\n    但使用Proxy代理的方式，相当于我们拿到的原材料已经是半成品甚至成品，他已经包含了\n    我们需要的一些功能和限制。这样跟易于我们后期的维护和扩展，因为我们不需要\n    在多个地方使用的时候，搬运我们后天添加的验证或者限制权限的一些方法。而需要做的仅仅是\n    使用new关键字创建一个实例对象。这个实例对象一出生就已经自带了验证方法。\n    使得代码复用性、健壮性更强\n  */\n}\n```","source":"_posts/ES6梳理-Proxy和Reflect.md","raw":"---\ntitle: ES6梳理-Proxy和Reflect\ndate: 2019-07-08 17:57:54\ntags:\n - ES6\n - Proxy和Reflect\ncategories: \n - ES6\n - Proxy和Reflect\n---\n\n# Proxy和Reflect\n+ Proxy和Reflect的概念\n+ Proxy和Reflect的适用场景 \n<!--  more -->\n## 概念：\n+ Proxy是代理的意思，连接了用户和对象之间的层，Reflect是反射的意思\n+ Proxy和Reflect的使用方法基本相同\n## Proxy使用\n+ 基本使用\n```javascript\n{\n  // 创建一个类似于供应商的对象\n  let obj = {\n    time: '2017-01-11',\n    name: 'net',\n    _r: 123\n  };\n  // 创建一个Proxy对象\n  let monitor = new Proxy(obj, {\n    // 拦截对象属性读取\n    get (target, key) {\n      return target[key].replace('2017', '2018')\n    },\n    // 拦截设置对象属性\n    set (target, key, value) {\n      // 假如我们做一个只能修改指定的属性name\n      if (key === 'name') {\n        return target[key] = value;\n      } else {\n        return target[key];\n      }\n    }\n  });\n  // 用户操作的是monitor对象，不管用户对monitor对象执行什么操作，都是由Proxy传递给obj对象\n  // 因为obj对象对于用户来说是不可见的，所以monitor.time这个操作被Proxy中的get方法拦截了，\n  // 意为读取obj中的某个属性，并且将这个属性的值做一些修改\n  console.log('get', monitor.time); // get 2018-01-11\n  monitor.time = '2018';\n  console.log(monitor.time); // 2018-01-11 发现没有修改为 '2018'\n  monitor.name = 'masia'; \n  console.log(monitor.name); // masia 发现修改成功了\n}\n```\n+ 常用属性\n```javascript\n{\n  // 创建一个类似于供应商的对象\n  let obj = {\n    time: '2017-01-11',\n    name: 'net',\n    _r: 123\n  };\n  // 创建一个Proxy对象\n  let monitor = new Proxy(obj, {\n    // 拦截对象属性读取\n    get (target, key) {\n      return target[key].replace('2017', '2018')\n    },\n    // 拦截设置对象属性\n    set (target, key, value) {\n      // 假如我们做一个只能修改指定的属性name\n      if (key === 'name') {\n        return target[key] = value;\n      } else {\n        return target[key];\n      }\n    },\n    // 暴露指定属性name,其他的都不暴露（这里暴露指的是使用in关键字找不到设置限制的属性）\n    has (target, key) {\n      if (key === 'name') {\n        return target[key];\n      } else {\n        return false;\n      }\n    },\n    // 拦截删除\n    deleteProperty (target, key) {\n      // 比如指定属性是\"_\"开头的，允许删除，其他的则不允许\n      if (key.indexOf('_') > -1) {\n        delete target[key];\n      } else {\n        return target[key];\n      }\n    },\n    // 拦截Object.keys, ObjectgetOwnPropertySymbols, Object.getOwnPropertyNames\n    ownKeys (target) {\n      return Object.keys(target).filter(item=>item!='time')\n    }\n  });\n  console.log(monitor.name); // masia \n  console.log(monitor.time); // 2018-01-11 设置了has,但是依然可以访问到\n  console.log('name' in monitor) // true \n  console.log('time' in monitor) // false 但是使用in关键字检查对象中是否包含某个属性时，却找不到 \n  \n  // 尝试删除time属性\n  delete monitor.time;\n  console.log(monitor); // Proxy {time: \"2017-01-11\", name: \"net\", _r: 123} 发现time属性还在\n  delete monitor._r;\n  console.log(monitor); // Proxy {time: \"2017-01-11\", name: \"net\"} 发现_r属性被删除了\n\n  // \n  console.log('ownKeys', Object.keys(monitor)); // ownKeys [\"name\"] 把name属性拦截掉了\n}\n```\n## Reflect使用\n```javascript\n{\n  // 创建一个类似于供应商的对象\n  let obj = {\n    time: '2017-01-11',\n    name: 'net',\n    _r: 123\n  };\n\n  // ES5 使用obj.time来取值\n  // Proxy还要通过创建实例monitor来取值\n  // Reflect要使用以下的方式来取值\n  console.log('Reflect get', Reflect.get(obj, 'time')); // Reflect get 2017-01-11\n  Reflect.set(obj, 'name', 'masia');\n  console.log(obj.name); // masia\n  console.log(Reflect.has(obj, 'name')); // true\n}\n```\n\n## Proxy和Reflect的使用场景\n```javascript\n{\n  // 在开发过程中经常要对一些信息进行校验，比如登录的时候手机号格式是否正确\n  // 解耦校验模块\n  function validator (target, validator) {\n    return new Proxy (target, {\n      _validator: validator,\n      set (target, key, value, proxy) {\n        // 判断当前对象有没有指定的key值，如果没有则不能对他赋值\n        if (target.hasOwnProperty(key)) {\n          let va = this._validator[key];\n          if (!!va(value)) {\n            return Reflect.set(target, key, value, proxy); \n          } else {\n            throw Error(`不能设置${key}到${value}`)\n          }\n        } else {\n          throw Error(`${key} 不存在`)\n        }\n      }\n    })\n  }\n\n  const personValidators = {\n    name (val) {\n      return typeof val === 'string';\n    },\n    age (val) {\n      return typeof val === 'number' && val > 18\n    }\n  }\n  \n  class Person {\n    constructor (name, age) {\n      this.name = name;\n      this.age = age;\n      return validator(this, personValidators); // Proxy对象代理了Person对象实例\n    }\n  }\n\n  const person = new Person('lilei', 30);\n  console.info(person); // Proxy {name: \"lilei\", age: 30}\n  // person.name = 48; // Uncaught Error: 不能设置name到48\n  // 因为有了代理，就不能对对象的实例属性做一些随意的操作了，这在ES5中是不能实现的\n  person.name = 'han mei';\n  console.info(person); // Proxy {name: \"han mei\", age: 30}\n  /* 总结：传统的做法，对某个属性进行赋值的时候，要对赋值的属性进行一些判断，\n    通常这些操作是在创建完了对象之后做的，并没有在使用类定义的时候做这件事情，\n    这就好比这个对象创建出来的时候是完整且干净的，就好比一块原材料，而我们后天\n    往上加饰的雕琢，使他有了更多的功能和限制。\n    但使用Proxy代理的方式，相当于我们拿到的原材料已经是半成品甚至成品，他已经包含了\n    我们需要的一些功能和限制。这样跟易于我们后期的维护和扩展，因为我们不需要\n    在多个地方使用的时候，搬运我们后天添加的验证或者限制权限的一些方法。而需要做的仅仅是\n    使用new关键字创建一个实例对象。这个实例对象一出生就已经自带了验证方法。\n    使得代码复用性、健壮性更强\n  */\n}\n```","slug":"ES6梳理-Proxy和Reflect","published":1,"updated":"2020-01-20T07:45:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghi000alktvcf92yx25"},{"title":"ES6梳理-Symbol","date":"2019-07-08T07:11:21.000Z","_content":"# Symbol\n+ Symbol概念：\n生成一个独一无二的值\n<!-- more -->\n```javascript\n{\n  // 声明\n  let a1 = Symbol(); // 并没有使用new关键字，而是直接当作函数去使用\n  let a2 = Symbol(); // 并没有使用new关键字，而是直接当作函数去使用\n  console.log(a1 === a2); // false\n  console.log(a1) // Symbol()红色的\n  console.log(a2) // Symbol()红色的\n\n  let a3 = Symbol.for('a3'); // 如果a3变量声明过且类型是Symbol类型，那就返回变量a3的值\n  // 否则则创建一个Symbol对象\n  let a4 = Symbol.for('a3'); \n  console.log(a3); // Symbol(a3)\n  console.log(a4); // Symbol(a3)\n  console.log(a3 == a4); // true\n}  \n```\n+ Symbol的作用：\n注意： 如果一个对象中使用Symbol对象做对象的key时，使用for in或者let of是检索不到的\n```javascript\n{\n  let a1 = Symbol.for('abc');\n  let obj = {\n    [a1]: '123',\n    'abc': 345,\n    'c': 456\n  }\n  for (let item in obj) {\n    console.log(item)\n    /*\n      abc\n      c\n    */\n  }\n  for (let [key, value] of Object.entries(obj)) {\n    console.log(key, value);\n    /*\n      abc 345\n      c 456\n    */\n  }\n  console.log(Object.keys(obj)); // [\"abc\", \"c\"]\n}\n```\n{% asset_img Symbol.png Symbol的作用 %}\n复习数组对象使用let of 和 entries()\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  console.log(arr.entries());\n  for (let [index, value] of arr.entries()) {\n    console.log(index, value);\n    /*\n      0 1\n      1 2\n      2 3\n      3 4\n    */\n  }\n}\n```\n+ Object.getOwnPropertySymbols(obj)\n这个方法用来取对象的key值为Symbol类型的key值本身，返回值为一个数组\n```javascript\n{\n  let a1 = Symbol.for('abc');\n  let a2 = Symbol();\n  let a3 = Symbol.for();\n  let obj = {\n    [a1]: '123',\n    [a2]: 'maisa',\n    [a3]: 'a3',\n    'abc': 345,\n    'c': 456\n  }\n  let arr = Object.getOwnPropertySymbols(obj);\n  console.log(arr); // [Symbol(abc), Symbol(), Symbol(undefined)]\n  arr.forEach(function (item) {\n    console.log(item, obj[item]); \n    /*\n      Symbol(abc) \"123\"\n      Symbol() \"maisa\"\n      Symbol(undefined) \"a3\"\n    */\n  })\n}\n```\n+ Reflect.ownKeys(obj)\n取出对象中的所有属性值（Symbol类型的key值），返回一个数组。\n```javascript\n{\n  let a1 = Symbol.for('abc');\n  let a2 = Symbol();\n  let a3 = Symbol.for();\n  let obj = {\n    [a1]: '123',\n    [a2]: 'maisa',\n    [a3]: 'a3',\n    'abc': 345,\n    'c': 456\n  }\n  let arr = Reflect.ownKeys(obj);\n  console.log(arr); //  [\"abc\", \"c\", Symbol(abc), Symbol(), Symbol(undefined)]\n  arr.forEach(function (item) {\n    console.log(item, obj[item]); \n    /*\n      abc 345\n      c 456\n      Symbol(abc) \"123\"\n      Symbol() \"maisa\"\n      Symbol(undefined) \"a3\"\n    */\n  })\n}\n```\n","source":"_posts/ES6梳理-Symbol.md","raw":"---\ntitle: ES6梳理-Symbol\ndate: 2019-07-08 15:11:21\ntags: \n - ES6\n - Symbol\ncategories: \n - ES6\n - Symbol\n---\n# Symbol\n+ Symbol概念：\n生成一个独一无二的值\n<!-- more -->\n```javascript\n{\n  // 声明\n  let a1 = Symbol(); // 并没有使用new关键字，而是直接当作函数去使用\n  let a2 = Symbol(); // 并没有使用new关键字，而是直接当作函数去使用\n  console.log(a1 === a2); // false\n  console.log(a1) // Symbol()红色的\n  console.log(a2) // Symbol()红色的\n\n  let a3 = Symbol.for('a3'); // 如果a3变量声明过且类型是Symbol类型，那就返回变量a3的值\n  // 否则则创建一个Symbol对象\n  let a4 = Symbol.for('a3'); \n  console.log(a3); // Symbol(a3)\n  console.log(a4); // Symbol(a3)\n  console.log(a3 == a4); // true\n}  \n```\n+ Symbol的作用：\n注意： 如果一个对象中使用Symbol对象做对象的key时，使用for in或者let of是检索不到的\n```javascript\n{\n  let a1 = Symbol.for('abc');\n  let obj = {\n    [a1]: '123',\n    'abc': 345,\n    'c': 456\n  }\n  for (let item in obj) {\n    console.log(item)\n    /*\n      abc\n      c\n    */\n  }\n  for (let [key, value] of Object.entries(obj)) {\n    console.log(key, value);\n    /*\n      abc 345\n      c 456\n    */\n  }\n  console.log(Object.keys(obj)); // [\"abc\", \"c\"]\n}\n```\n{% asset_img Symbol.png Symbol的作用 %}\n复习数组对象使用let of 和 entries()\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  console.log(arr.entries());\n  for (let [index, value] of arr.entries()) {\n    console.log(index, value);\n    /*\n      0 1\n      1 2\n      2 3\n      3 4\n    */\n  }\n}\n```\n+ Object.getOwnPropertySymbols(obj)\n这个方法用来取对象的key值为Symbol类型的key值本身，返回值为一个数组\n```javascript\n{\n  let a1 = Symbol.for('abc');\n  let a2 = Symbol();\n  let a3 = Symbol.for();\n  let obj = {\n    [a1]: '123',\n    [a2]: 'maisa',\n    [a3]: 'a3',\n    'abc': 345,\n    'c': 456\n  }\n  let arr = Object.getOwnPropertySymbols(obj);\n  console.log(arr); // [Symbol(abc), Symbol(), Symbol(undefined)]\n  arr.forEach(function (item) {\n    console.log(item, obj[item]); \n    /*\n      Symbol(abc) \"123\"\n      Symbol() \"maisa\"\n      Symbol(undefined) \"a3\"\n    */\n  })\n}\n```\n+ Reflect.ownKeys(obj)\n取出对象中的所有属性值（Symbol类型的key值），返回一个数组。\n```javascript\n{\n  let a1 = Symbol.for('abc');\n  let a2 = Symbol();\n  let a3 = Symbol.for();\n  let obj = {\n    [a1]: '123',\n    [a2]: 'maisa',\n    [a3]: 'a3',\n    'abc': 345,\n    'c': 456\n  }\n  let arr = Reflect.ownKeys(obj);\n  console.log(arr); //  [\"abc\", \"c\", Symbol(abc), Symbol(), Symbol(undefined)]\n  arr.forEach(function (item) {\n    console.log(item, obj[item]); \n    /*\n      abc 345\n      c 456\n      Symbol(abc) \"123\"\n      Symbol() \"maisa\"\n      Symbol(undefined) \"a3\"\n    */\n  })\n}\n```\n","slug":"ES6梳理-Symbol","published":1,"updated":"2020-01-20T07:45:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghj000dlktvk97rl68l"},{"title":"ES6梳理-Promise","date":"2019-07-10T02:48:33.000Z","_content":"\n# Promise\n<!-- more -->\n### ES5常规回调和Promise回调做对比\n```javascript\nvar fs = require('fs')\nvar path = require('path')\n\n// 读取文件函数\nfunction getfile (fpath, callback) {\n\tfs.readFile(path.join(__dirname, fpath), 'utf8', (err, data) => {\n\t\t// if (err) throw err //终止程序执行，并且在控制台答应错误信息。这种方式不太好用，代码健壮性不好，不能因为获取不到文件而耽误整个程序的执行\n\t\tif (err) return callback(err) //把错误通过回调函数返回，程序依然可以正常进行下面的，但其实这种方式也是不好的，因为你的回调函数并不知道你返回的是错误信息还是真正所需的数据\n\t\tcallback(data)\n\t})\n}\n// 1、异步读取文件，不能决定读取文件的顺序\ngetfile('./5.txt', function (data) {\n\tconsole.log(data)\n})\ngetfile('./2.txt', function (data) {\n\tconsole.log(data)\n})\ngetfile('./3.txt', function (data) {\n\tconsole.log(data)\n})\n\n// 2、按照先后顺序读取多个文件\ngetfile('./5.txt', function (data) {\n\tconsole.log(data)\n\tgetfile('./2.txt', function (data) {\n\t\tconsole.log(data)\n\t\tgetfile('./3.txt', function (data) {\n\t\t\tconsole.log(data)\n\t\t})\n\t})\n})\n\n// 3、使用promise对象封装一个函数，优化代码结构，文件读取顺序执行\nfunction promiseGetfile (fpath) {\n\treturn new Promise(function (resolve, reject) {\n\t\tfs.readFile(path.join(__dirname, fpath), 'utf8', function (err, data) {\n\t\t\tif (err) {\n\t\t\t\treject(err)\n\t\t\t} else {\n\t\t\t\tresolve(data)\n\t\t\t}\n\t\t})\n\t})\n}\n\npromiseGetfile('./1.txt')\n\t.then(function (data) {\n\t\tconsole.log(data)\n\t\treturn promiseGetfile('./2.txt')\n\t})\n\t.then(function (data) {\n\t\tconsole.log(data)\n\t\treturn promiseGetfile('./3.txt')\n\t})\n\t.then(function (data) {\n\t\tconsole.log(data)\n\t})\n```\n\n### Promise使用场景\n+ 对axios进行二次封装，统一post和get请求的操作，该层面的封装属于系统层面的封装\n```javascript\nimport axios from 'axios'\n\nexport default function ajax (url, data = {}, type = 'GET') {\n  // 这里统一了post和get方式请求接口传参的形式，即都为对象。而且还可以设置默认参数\n  return new Promise((resolve, reject) => {\n    let promise\n    if (type === 'GET') {\n      let dataStr = ''\n      Object.keys(data).forEach(key => {\n        dataStr += key + '=' + data[key] + '&'\n      })\n      if (dataStr !== '') {\n        dataStr = dataStr.substring(0, dataStr.lastIndexOf('&'))\n        url = url + '?' + dataStr\n      }\n      promise = axios.get(url)\n    } else {\n      promise = axios.post(url, data)\n    }\n    promise.then(res => {\n      resolve(res.data)\n    }).catch(err => {\n      reject(err.data)\n    })\n  })\n}\n```\n+ 在index.js进行第三次封装\n对请求进行第三次封装，该层面属于业务层面的封装，封装了请求接口地址，只需要传入查询参数对象formData，使用reqRegister\n```javascript\nimport ajax from './ajax'\n\nconst BASE_URL_API = '/api'\nconst BASE_URL_USERS = '/users'\n\n// 1.注册\nexport const reqRegister = (formData) => ajax(`${BASE_URL_USERS}/register`, formData, 'post') \n(formData)调用即可\n// 2.登录\nexport const reqLogin = (formData) => ajax(`${BASE_URL_USERS}/login`, formData, 'post')\n// 3.个人中心信息\nexport const reqProfile = () => ajax(`${BASE_URL_USERS}/profile`)\n\n// 4.获取位置\nexport const reqPosition = (position) => ajax(`${BASE_URL_API}/position/${position}`)\n\n// 5.获取产品列表\nexport const reqShopLists = () => ajax(`/shopLists`)\n\n// 6. 获取店家商品列表\nexport const reqGoodsLists = () => ajax('/goods')\n```\n### catch使用\n```javascript\n{\n  let ajax = function (num) {\n    return new Promise((resolve, reject) => {\n      if (num > 5) {\n        resolve(num);\n      } else {\n        throw new Error('出错了');\n      }\n    })\n  }\n\n  // 1. 使用catch\n  ajax(1)\n    .then((data) => {\n      console.log(data+\"正确\");\n    })\n    .catch((err) => {\n      console.log(err);\n      /*\n        Error: 出错了\n        at promise.html:17\n        at new Promise (<anonymous>)\n        at ajax (promise.html:13)\n        at promise.html:21\n      */\n    })\n  \n  // 2. 不使用catch\n  ajax(1)\n    .then((data) => {\n      console.log(data+\"正确\");\n    }, (err) => { \n      /*虽然没有在Promise对象中合适的位置调用reject()，\n        但是调用了throw new Error('出错了');\n        所以中的err就是new Error('出错了')\n      */\n      console.log(err);\n      /*\n        Error: 出错了\n        at promise.html:17\n        at new Promise (<anonymous>)\n        at ajax (promise.html:13)\n        at promise.html:21\n      */\n    })\n\n  // 3. then中的第二个回调和catch共存，则只会执行then的第二个回调。\n  ajax(1)\n    .then((data) => {\n      console.log(data+\"正确\");\n    }, (err) => { \n      console.log(err);\n      /*\n        Error: 出错了\n        at promise.html:17\n        at new Promise (<anonymous>)\n        at ajax (promise.html:13)\n        at promise.html:21\n      */\n    })\n    .catch((err) => { // 不执行\n      console.log(err);\n    }) \n} \n```\n### Promise高级用法\n+ Promise.all\n+ Promise.rece()\n\nPromise.all()使用场景：\n```javascript\n/*使用场景:假如一个cell中有三张图，我们的三张图片是异步加载的，并且来自不同的接口，\n如果每张图片一旦获取成功，就加载到页面中。由于三张的获取成功顺序将不能确定，\n但是他们在页面上的先后位置顺序是固定的，那就极有可能出现第二张图加载完成，\n第一张图还没有加载完成的现象，这样的用户体验很不好。\n所以，我们要规定三张图的异步加载顺序，用户看不到图片加载的过程，也看不到闪动\n我们需要做：三张图都获取到了之后，再一起加载到页面\n*/\n{\n  // 所有图片全部获取完成之后在添加到到页面\n  function loadImg (src) {\n    return new Promise ((resolve, reject) => {\n      let img = document.createElement('img');\n      img.src = src;\n      img.onload = function () {\n        resolve(img); // 把创建好的img DOM元素对象传给成功的回调\n      } \n      img.onerror = function (err) {\n        reject(err)\n      }\n    })\n  }\n\n  function showImgs (imgs) {\n    imgs.forEach(img => {\n      document.body.appendChild(img);\n    })\n  }\n\n  // 数组中传入多个Promise实例对象，当所有传入的Promise对象的状态发生变化后，这个Promise对象集合才会调用then方法\n  Promise.all([\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633416&di=41de4b9fc2024e278c77d5a4ae6135c2&imgtype=0&src=http%3A%2F%2Fwww.chinapoesy.com%2FUploadFiles%2FPoesy%2F20141015_92b4978b-973a-472c-b4e8-33d89e01853f.jpg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562760007124&di=f447518c90caf2859e2c5e1fb0fef39c&imgtype=jpg&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190122%2Ff24ab1f776974b41bb83cbd86353f702.jpeg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633411&di=6b3012be166e8f06ecbe49bbc175a94f&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F09%2F20161009140358_3S8cz.jpeg')\n  ]).then(showImgs)\n}\n```\n```javascript\n// 图片实现不了，用div模拟\n{\n  function loadDiv (text) {\n    return new Promise ((resolve, reject) => {\n      if (!text) {\n        throw new Error(\"出错了\"); \n        /*\n          Error: 出错了\n          at promise.html:43\n          at new Promise (<anonymous>)\n          at loadDiv (promise.html:41)\n          at promise.html:70  \n        */\n        reject('出错了'); // 出错了\n      }\n      let div = document.createElement('div');\n      div.style.color = 'red';\n      div.innerText = text;\n      resolve(div);\n    })\n  }\n\n  function showDivs (divs) {\n    divs.forEach(div => document.body.appendChild(div));\n  }\n  Promise.all([\n    loadDiv('1 div'),\n    loadDiv('2 div'),\n    loadDiv('3 div'),\n    loadDiv('4 div')\n  ])\n  .then(showDivs);\n}\n```\nPromise.race()使用场景：\n```javascript\n/*\n  假如有三张图片，来自不同的接口，哪个网速好，先获取到了，我就优先显示哪张图片\n*/\n{\n  // 所有图片全部获取完成之后在添加到到页面\n  function loadImg (src) {\n    return new Promise ((resolve, reject) => {\n      let img = document.createElement('img');\n      img.src = src;\n      img.onload = function () {\n        resolve(img); // 把创建好的img DOM元素对象传给成功的回调\n      } \n      img.onerror = function (err) {\n        reject(err)\n      }\n    })\n  }\n\n  function showImg (imgs) {\n    document.body.appendChild(img);\n  }\n\n  // 数组中传入多个Promise实例对象，当所有传入的Promise对象的状态发生变化后，这个Promise对象集合才会调用then方法\n  Promise.race([\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633416&di=41de4b9fc2024e278c77d5a4ae6135c2&imgtype=0&src=http%3A%2F%2Fwww.chinapoesy.com%2FUploadFiles%2FPoesy%2F20141015_92b4978b-973a-472c-b4e8-33d89e01853f.jpg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562760007124&di=f447518c90caf2859e2c5e1fb0fef39c&imgtype=jpg&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190122%2Ff24ab1f776974b41bb83cbd86353f702.jpeg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633411&di=6b3012be166e8f06ecbe49bbc175a94f&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F09%2F20161009140358_3S8cz.jpeg')\n  ]).then(showImg)\n\n  // 页面上只显示了一张图片\n}\n```","source":"_posts/ES6梳理-promise.md","raw":"---\ntitle: ES6梳理-Promise\ndate: 2019-07-10 10:48:33\ncategories:\n  - ES6\n  - Promise\ntags:\n  - ES6\n  - Promise\n---\n\n# Promise\n<!-- more -->\n### ES5常规回调和Promise回调做对比\n```javascript\nvar fs = require('fs')\nvar path = require('path')\n\n// 读取文件函数\nfunction getfile (fpath, callback) {\n\tfs.readFile(path.join(__dirname, fpath), 'utf8', (err, data) => {\n\t\t// if (err) throw err //终止程序执行，并且在控制台答应错误信息。这种方式不太好用，代码健壮性不好，不能因为获取不到文件而耽误整个程序的执行\n\t\tif (err) return callback(err) //把错误通过回调函数返回，程序依然可以正常进行下面的，但其实这种方式也是不好的，因为你的回调函数并不知道你返回的是错误信息还是真正所需的数据\n\t\tcallback(data)\n\t})\n}\n// 1、异步读取文件，不能决定读取文件的顺序\ngetfile('./5.txt', function (data) {\n\tconsole.log(data)\n})\ngetfile('./2.txt', function (data) {\n\tconsole.log(data)\n})\ngetfile('./3.txt', function (data) {\n\tconsole.log(data)\n})\n\n// 2、按照先后顺序读取多个文件\ngetfile('./5.txt', function (data) {\n\tconsole.log(data)\n\tgetfile('./2.txt', function (data) {\n\t\tconsole.log(data)\n\t\tgetfile('./3.txt', function (data) {\n\t\t\tconsole.log(data)\n\t\t})\n\t})\n})\n\n// 3、使用promise对象封装一个函数，优化代码结构，文件读取顺序执行\nfunction promiseGetfile (fpath) {\n\treturn new Promise(function (resolve, reject) {\n\t\tfs.readFile(path.join(__dirname, fpath), 'utf8', function (err, data) {\n\t\t\tif (err) {\n\t\t\t\treject(err)\n\t\t\t} else {\n\t\t\t\tresolve(data)\n\t\t\t}\n\t\t})\n\t})\n}\n\npromiseGetfile('./1.txt')\n\t.then(function (data) {\n\t\tconsole.log(data)\n\t\treturn promiseGetfile('./2.txt')\n\t})\n\t.then(function (data) {\n\t\tconsole.log(data)\n\t\treturn promiseGetfile('./3.txt')\n\t})\n\t.then(function (data) {\n\t\tconsole.log(data)\n\t})\n```\n\n### Promise使用场景\n+ 对axios进行二次封装，统一post和get请求的操作，该层面的封装属于系统层面的封装\n```javascript\nimport axios from 'axios'\n\nexport default function ajax (url, data = {}, type = 'GET') {\n  // 这里统一了post和get方式请求接口传参的形式，即都为对象。而且还可以设置默认参数\n  return new Promise((resolve, reject) => {\n    let promise\n    if (type === 'GET') {\n      let dataStr = ''\n      Object.keys(data).forEach(key => {\n        dataStr += key + '=' + data[key] + '&'\n      })\n      if (dataStr !== '') {\n        dataStr = dataStr.substring(0, dataStr.lastIndexOf('&'))\n        url = url + '?' + dataStr\n      }\n      promise = axios.get(url)\n    } else {\n      promise = axios.post(url, data)\n    }\n    promise.then(res => {\n      resolve(res.data)\n    }).catch(err => {\n      reject(err.data)\n    })\n  })\n}\n```\n+ 在index.js进行第三次封装\n对请求进行第三次封装，该层面属于业务层面的封装，封装了请求接口地址，只需要传入查询参数对象formData，使用reqRegister\n```javascript\nimport ajax from './ajax'\n\nconst BASE_URL_API = '/api'\nconst BASE_URL_USERS = '/users'\n\n// 1.注册\nexport const reqRegister = (formData) => ajax(`${BASE_URL_USERS}/register`, formData, 'post') \n(formData)调用即可\n// 2.登录\nexport const reqLogin = (formData) => ajax(`${BASE_URL_USERS}/login`, formData, 'post')\n// 3.个人中心信息\nexport const reqProfile = () => ajax(`${BASE_URL_USERS}/profile`)\n\n// 4.获取位置\nexport const reqPosition = (position) => ajax(`${BASE_URL_API}/position/${position}`)\n\n// 5.获取产品列表\nexport const reqShopLists = () => ajax(`/shopLists`)\n\n// 6. 获取店家商品列表\nexport const reqGoodsLists = () => ajax('/goods')\n```\n### catch使用\n```javascript\n{\n  let ajax = function (num) {\n    return new Promise((resolve, reject) => {\n      if (num > 5) {\n        resolve(num);\n      } else {\n        throw new Error('出错了');\n      }\n    })\n  }\n\n  // 1. 使用catch\n  ajax(1)\n    .then((data) => {\n      console.log(data+\"正确\");\n    })\n    .catch((err) => {\n      console.log(err);\n      /*\n        Error: 出错了\n        at promise.html:17\n        at new Promise (<anonymous>)\n        at ajax (promise.html:13)\n        at promise.html:21\n      */\n    })\n  \n  // 2. 不使用catch\n  ajax(1)\n    .then((data) => {\n      console.log(data+\"正确\");\n    }, (err) => { \n      /*虽然没有在Promise对象中合适的位置调用reject()，\n        但是调用了throw new Error('出错了');\n        所以中的err就是new Error('出错了')\n      */\n      console.log(err);\n      /*\n        Error: 出错了\n        at promise.html:17\n        at new Promise (<anonymous>)\n        at ajax (promise.html:13)\n        at promise.html:21\n      */\n    })\n\n  // 3. then中的第二个回调和catch共存，则只会执行then的第二个回调。\n  ajax(1)\n    .then((data) => {\n      console.log(data+\"正确\");\n    }, (err) => { \n      console.log(err);\n      /*\n        Error: 出错了\n        at promise.html:17\n        at new Promise (<anonymous>)\n        at ajax (promise.html:13)\n        at promise.html:21\n      */\n    })\n    .catch((err) => { // 不执行\n      console.log(err);\n    }) \n} \n```\n### Promise高级用法\n+ Promise.all\n+ Promise.rece()\n\nPromise.all()使用场景：\n```javascript\n/*使用场景:假如一个cell中有三张图，我们的三张图片是异步加载的，并且来自不同的接口，\n如果每张图片一旦获取成功，就加载到页面中。由于三张的获取成功顺序将不能确定，\n但是他们在页面上的先后位置顺序是固定的，那就极有可能出现第二张图加载完成，\n第一张图还没有加载完成的现象，这样的用户体验很不好。\n所以，我们要规定三张图的异步加载顺序，用户看不到图片加载的过程，也看不到闪动\n我们需要做：三张图都获取到了之后，再一起加载到页面\n*/\n{\n  // 所有图片全部获取完成之后在添加到到页面\n  function loadImg (src) {\n    return new Promise ((resolve, reject) => {\n      let img = document.createElement('img');\n      img.src = src;\n      img.onload = function () {\n        resolve(img); // 把创建好的img DOM元素对象传给成功的回调\n      } \n      img.onerror = function (err) {\n        reject(err)\n      }\n    })\n  }\n\n  function showImgs (imgs) {\n    imgs.forEach(img => {\n      document.body.appendChild(img);\n    })\n  }\n\n  // 数组中传入多个Promise实例对象，当所有传入的Promise对象的状态发生变化后，这个Promise对象集合才会调用then方法\n  Promise.all([\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633416&di=41de4b9fc2024e278c77d5a4ae6135c2&imgtype=0&src=http%3A%2F%2Fwww.chinapoesy.com%2FUploadFiles%2FPoesy%2F20141015_92b4978b-973a-472c-b4e8-33d89e01853f.jpg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562760007124&di=f447518c90caf2859e2c5e1fb0fef39c&imgtype=jpg&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190122%2Ff24ab1f776974b41bb83cbd86353f702.jpeg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633411&di=6b3012be166e8f06ecbe49bbc175a94f&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F09%2F20161009140358_3S8cz.jpeg')\n  ]).then(showImgs)\n}\n```\n```javascript\n// 图片实现不了，用div模拟\n{\n  function loadDiv (text) {\n    return new Promise ((resolve, reject) => {\n      if (!text) {\n        throw new Error(\"出错了\"); \n        /*\n          Error: 出错了\n          at promise.html:43\n          at new Promise (<anonymous>)\n          at loadDiv (promise.html:41)\n          at promise.html:70  \n        */\n        reject('出错了'); // 出错了\n      }\n      let div = document.createElement('div');\n      div.style.color = 'red';\n      div.innerText = text;\n      resolve(div);\n    })\n  }\n\n  function showDivs (divs) {\n    divs.forEach(div => document.body.appendChild(div));\n  }\n  Promise.all([\n    loadDiv('1 div'),\n    loadDiv('2 div'),\n    loadDiv('3 div'),\n    loadDiv('4 div')\n  ])\n  .then(showDivs);\n}\n```\nPromise.race()使用场景：\n```javascript\n/*\n  假如有三张图片，来自不同的接口，哪个网速好，先获取到了，我就优先显示哪张图片\n*/\n{\n  // 所有图片全部获取完成之后在添加到到页面\n  function loadImg (src) {\n    return new Promise ((resolve, reject) => {\n      let img = document.createElement('img');\n      img.src = src;\n      img.onload = function () {\n        resolve(img); // 把创建好的img DOM元素对象传给成功的回调\n      } \n      img.onerror = function (err) {\n        reject(err)\n      }\n    })\n  }\n\n  function showImg (imgs) {\n    document.body.appendChild(img);\n  }\n\n  // 数组中传入多个Promise实例对象，当所有传入的Promise对象的状态发生变化后，这个Promise对象集合才会调用then方法\n  Promise.race([\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633416&di=41de4b9fc2024e278c77d5a4ae6135c2&imgtype=0&src=http%3A%2F%2Fwww.chinapoesy.com%2FUploadFiles%2FPoesy%2F20141015_92b4978b-973a-472c-b4e8-33d89e01853f.jpg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562760007124&di=f447518c90caf2859e2c5e1fb0fef39c&imgtype=jpg&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190122%2Ff24ab1f776974b41bb83cbd86353f702.jpeg'),\n    loadImg('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562759633411&di=6b3012be166e8f06ecbe49bbc175a94f&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F09%2F20161009140358_3S8cz.jpeg')\n  ]).then(showImg)\n\n  // 页面上只显示了一张图片\n}\n```","slug":"ES6梳理-promise","published":1,"updated":"2020-01-20T07:45:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghk000elktvxkhx5c61"},{"title":"ES6梳理-函数扩展","date":"2019-04-29T03:00:00.000Z","_content":"\n# 函数扩展\n+ 参数默认值\n+ rest参数\n+ 扩展运算符\n+ 箭头函数\n+ this绑定\n+ 尾调用\n<!-- more -->\n\n## 函数参数默认值\n```javascript\n{\n  {\n    function fn (x, y = 'masia', z=3) { // 在设置了默认值参数的后面，必须加没有默认值的参数\n      console.log(x, y, z); // 666 \"masia\"\n    }\n    fn(666, 222, 55);\n  }\n\n  // 注意点： 不要混着写，一般推荐把有默认值的参数都放在最后面，以免手动传默认值。\n  {\n    function fn (x, y = 'masia', z) { // 不要这样写\n      console.log(x, y, z); // 666 \"masia\"\n    }\n    fn(666);\n  }\n  \n}\n```\n## 作用域\n```javascript\n{\n  let x = 'test';\n  function test2 (x, y=x) {\n                    // 参数y的值是参数x的值，还是外部x变量的值？\n    console.log(x, y) \n  }\n  test2('kill'); // kill kill 答案是参数x的值\n  test2(); // undefined undefined\n  function test3 (c, y=x) {\n                // 单如果没有参数x，那么y的值是外部变量x的值\n    console.log(c, y);\n  }\n  test3('kill'); // kill test\n  test3(); // undefined \"test\"\n}\n```\n### rest参数\n```javascript\n{\n  function test (...arg) {\n    // ...arg在传入的参数数量不确定的时候，这个操作符号，把你传入的参数组合成了一个数组，名为arg\n    for (let v of arg) {\n      console.log('rest', v);\n    }\n    console.log(arg) // [1, 2, 3, 4, \"a\"] 数组\n    console.log(arguments) // 对象 ，Arguments(5) [1, 2, 3, 4, \"a\", callee: (...), Symbol(Symbol.iterator): ƒ]\n  }\n  test(1, 2, 3, 4, 'a');\n  // rest 1\n  // rest 2\n  // rest 3\n  // rest 4\n  // rest a\n}\n\n// 逆用\n{\n  // \"...\"操作符把一个数组拆成了一个个离散的值  \n  console.log(...[1, 2, 4]); // 1 2 4 \n  console.log('a', ...[1, 2, 4]); // a 1 2 4\n}\n\n// 实质（arg和对arguments做了数组转化一个道理）\n{\n  function fn (...arg) {\n    console.log(arg); // (4) [1, 2, 3, 4]\n    console.log(arguments); // Arguments(4) [1, 2, 3, 4, callee: (...), Symbol(Symbol.iterator): ƒ]\n    console.log(Array.from(arguments)); // (4) [1, 2, 3, 4]\n  }\n  fn(1, 2, 3, 4);\n}\n```\n### 箭头函数\n+ 简单使用\n```javascript\n{\n  // 有参数\n  let  arrow = arrow => console.log(arrow);\n  arrow('你好'); // 你好\n\n  // 等价写法： \n  let arrow2 = arrow2 => {\n    return console.log(arrow);\n  }\n  arrow('你好'); // 你好\n\n  //无参数\n  let arrow3 = () => console.log(5);\n}\n```\n+ 箭头函数中this到底指向谁？\n由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值\n```javascript\n{\n  function Person (name) {\n    this.name = name;\n    this.child = {\n      name: 'ming',\n      getFather: () => {\n        console.log(this.name);\n      },\n      getSeftName: function () {\n        console.log(this.name);\n      }\n    }\n  }\n  const person = new Person('masia');\n  person.child.getFather(); // masia\n  person.child.getSeftName(); // ming\n}\n\n{\n  function Person () {\n    this.age = 0;\n    setTimeout(function () {\n      console.log(this); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n    }, 1000)\n    setTimeout(() => {\n      console.log(this); // Person {age: 0}\n    }, 1000)\n  }\n  const p = new Person();\n}\n```\n\n### 尾调用\n函数式编程，函数的最后一句话是不是函数调用，尾调用可以提升函数的性能，之前的\n```javascript\n{\n  function tail (x) {\n    console.log('tail', x);\n  }\n  function fx (x) {\n    return tail(x);\n  }\n  fx('尾调用'); // tail 尾调用\n}\n```","source":"_posts/ES6梳理-函数扩展.md","raw":"---\ntitle: ES6梳理-函数扩展\ncategories:\n  - ES6\n  - 函数扩展\ntags:\n  - ES6\n  - 函数扩展\ndate: 2019-04-29 11:00:00\n---\n\n# 函数扩展\n+ 参数默认值\n+ rest参数\n+ 扩展运算符\n+ 箭头函数\n+ this绑定\n+ 尾调用\n<!-- more -->\n\n## 函数参数默认值\n```javascript\n{\n  {\n    function fn (x, y = 'masia', z=3) { // 在设置了默认值参数的后面，必须加没有默认值的参数\n      console.log(x, y, z); // 666 \"masia\"\n    }\n    fn(666, 222, 55);\n  }\n\n  // 注意点： 不要混着写，一般推荐把有默认值的参数都放在最后面，以免手动传默认值。\n  {\n    function fn (x, y = 'masia', z) { // 不要这样写\n      console.log(x, y, z); // 666 \"masia\"\n    }\n    fn(666);\n  }\n  \n}\n```\n## 作用域\n```javascript\n{\n  let x = 'test';\n  function test2 (x, y=x) {\n                    // 参数y的值是参数x的值，还是外部x变量的值？\n    console.log(x, y) \n  }\n  test2('kill'); // kill kill 答案是参数x的值\n  test2(); // undefined undefined\n  function test3 (c, y=x) {\n                // 单如果没有参数x，那么y的值是外部变量x的值\n    console.log(c, y);\n  }\n  test3('kill'); // kill test\n  test3(); // undefined \"test\"\n}\n```\n### rest参数\n```javascript\n{\n  function test (...arg) {\n    // ...arg在传入的参数数量不确定的时候，这个操作符号，把你传入的参数组合成了一个数组，名为arg\n    for (let v of arg) {\n      console.log('rest', v);\n    }\n    console.log(arg) // [1, 2, 3, 4, \"a\"] 数组\n    console.log(arguments) // 对象 ，Arguments(5) [1, 2, 3, 4, \"a\", callee: (...), Symbol(Symbol.iterator): ƒ]\n  }\n  test(1, 2, 3, 4, 'a');\n  // rest 1\n  // rest 2\n  // rest 3\n  // rest 4\n  // rest a\n}\n\n// 逆用\n{\n  // \"...\"操作符把一个数组拆成了一个个离散的值  \n  console.log(...[1, 2, 4]); // 1 2 4 \n  console.log('a', ...[1, 2, 4]); // a 1 2 4\n}\n\n// 实质（arg和对arguments做了数组转化一个道理）\n{\n  function fn (...arg) {\n    console.log(arg); // (4) [1, 2, 3, 4]\n    console.log(arguments); // Arguments(4) [1, 2, 3, 4, callee: (...), Symbol(Symbol.iterator): ƒ]\n    console.log(Array.from(arguments)); // (4) [1, 2, 3, 4]\n  }\n  fn(1, 2, 3, 4);\n}\n```\n### 箭头函数\n+ 简单使用\n```javascript\n{\n  // 有参数\n  let  arrow = arrow => console.log(arrow);\n  arrow('你好'); // 你好\n\n  // 等价写法： \n  let arrow2 = arrow2 => {\n    return console.log(arrow);\n  }\n  arrow('你好'); // 你好\n\n  //无参数\n  let arrow3 = () => console.log(5);\n}\n```\n+ 箭头函数中this到底指向谁？\n由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值\n```javascript\n{\n  function Person (name) {\n    this.name = name;\n    this.child = {\n      name: 'ming',\n      getFather: () => {\n        console.log(this.name);\n      },\n      getSeftName: function () {\n        console.log(this.name);\n      }\n    }\n  }\n  const person = new Person('masia');\n  person.child.getFather(); // masia\n  person.child.getSeftName(); // ming\n}\n\n{\n  function Person () {\n    this.age = 0;\n    setTimeout(function () {\n      console.log(this); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n    }, 1000)\n    setTimeout(() => {\n      console.log(this); // Person {age: 0}\n    }, 1000)\n  }\n  const p = new Person();\n}\n```\n\n### 尾调用\n函数式编程，函数的最后一句话是不是函数调用，尾调用可以提升函数的性能，之前的\n```javascript\n{\n  function tail (x) {\n    console.log('tail', x);\n  }\n  function fx (x) {\n    return tail(x);\n  }\n  fx('尾调用'); // tail 尾调用\n}\n```","slug":"ES6梳理-函数扩展","published":1,"updated":"2020-01-20T07:45:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghm000hlktv1yeoiao4"},{"title":"ES6梳理-字符串扩展","date":"2019-04-30T06:00:00.000Z","_content":"\n# 字符串新增的特性：\n+ Unicode表示法\n+ 遍历接口\n+ 模板字符串\n+ 新增方法（10种）\n<!-- more -->\n\n## Unicode表示法\n+ 引入： \n```javascript\n{\n  console.log('a', '\\u0061'); // a a\n  console.log('s', '\\u20BB7'); // s ₻7\n                    //这个超过了0xffff，也就是超过了2字节，他会把20BB和7分别拿出来解析，20BB不是unicode的编码，所以不能识别 \n} \n```\n+ 在ES6中处理超过2字节的unicode编码，使用{}包起来，比如：\n```javascript\n{\n  console.log('s', '\\u{20BB7}'); // s 𠮷\n} \n```\n+ ES5和ES6处理码值： \n```javascript\n{\n  let a = 'a'; \n  let s = '𠮷';\n  console.log(a.length) // 1\n  console.log(s.length) // 2\n  console.log('0', s.charAt(0)) // 0 � 取s的Unicode编码第1个位置的字符\n  console.log('1', s.charAt(1)) // 1 � 取s的Unicode编码第2个位置的字符\n  console.log('at0', s.charCodeAt(0).toString(16)) // at0 d842 \n  console.log('at1', s.charCodeAt(1).toString(16)) // at1 dfb7\n  console.log('a', a.charCodeAt(0).toString(16)) // a 61\n\n//ES6中的codePointeAt()\nlet s1 = '𠮷a'\nconsole.log(s1.length)\nconsole.log(s1.codePointAt(0).toString(16)) // 20bb7 取了4字节的码值，codePointAt()方法会先去判断指定字符是2字节的还是4字节的，然后再去获得Unicode编码\nconsole.log(s1.codePointAt(1).toString(16)) // dfb7\nconsole.log(s1.codePointAt(2).toString(16)) // 61\n}\n{\n  // ES5中方法\n  console.log(String.fromCharCode(\"0x20bb7\")); // ஷ\n  // ES6中方法\n  console.log(String.fromCodePoint(\"0x20bb7\")) // 𠮷\n\n  // 两者区别就是能否处理超过2字节的Unicode字符\n}\n```\n## ES5和ES6的字符串遍历\n```javascript\n{\n  // 常用的字符遍历器接口\n  let str = '\\u{20bb7}abc';\n  // ES6处理\n  for (let code of str) { \n    console.log('ES6', code) // ES6 𠮷\n                              // ES6 a\n                              // ES6 b  \n                              // ES6 c\n  }\n\n  // ES5不能处理\n  for (let i = 0; i < str.length; i++) {\n    console.log('es5', str[i]) // es5 �\n                                // es5 �\n                                // es5 a\n                                // es5 b\n                                // es5 c\n  }\n  let arr = str.split(\"\") // split(\"\")也是按照2个字节为一个字符来处理的，所以把1个4字节的字符识别成了2个2字节的字符\n  console.log(arr) // [\"�\", \"�\", \"a\", \"b\", \"c\"] \n  {\n    let str2 = \"你好\";\n    console.log(str2[1]) // \"好\"\n  }\n}\n```\n## ES6新增的经常使用的字符串处理API\n```javascript\n{\n  let str = \"string\";\n\n  // ES6对字符串进行简单查询\n  {\n    console.log(\"includes\", str.includes(\"r\")); // includes true\n    console.log(\"start\", str.startsWith('str')) // start true\n    console.log(\"end\", str.endsWith('ng')) // end true\n  }\n  \n  // ES6重复字符串\n  {\n    // ES6重复字符串\n    console.log(str.repeat(2)); // stringstring\n    // ES5重复字符串\n    let str2 = str\n    str2 += str;\n    console.log(str2) // stringstring\n    \n    // 为String添加一个mRepeat原型方法\n    String.prototype.mRepeat = function (n) {\n    let str = this.valueOf();\n    let str2 = \"\";\n    for (let i = 0; i < n; i ++) {\n      str2 += str\n    }\n    return str2;\n    }\n    console.log(str.mRepeat(2));\n  }\n\n  //模板字符串\n  {\n    let name = \"list\";\n    let info = \"hello world\";\n    let s = `I am ${name},${info}`;\n    console.log(s); // I am list,hello world\n  }\n\n  // String.raw()\n  {\n    console.log(String.raw`Hi\\n${1+2}`); // Hi\\n3 换行符并没有生效，也就是在\"\\\"前面又隐式的加了一个\"\\\", \\n  => \\\\n\n    // 等价于\n    console.log(`Hi\\\\n${1+2}`) // Hi\\n3\n\n    console.log(`Hi\\n${1+2}`); // Hi\n                                // 3 \n    console.log('ma\\\\n') // ma\\n \n  }\n\n  // ES7草案\n  {\n    // padStart和endStart方法非常实用，比如日期补白: 2019-6-2 => 2019-06-02\n    console.log('1', padStart(2, '0')); // 01\n    // padStart()谷歌识别不了，第一个参数指定字符串长度，如果不够用第二个字符参数往前补白\n    console.log('1', padEnd(2, '0')); // 10\n    // padEnd()向后补白\n  }\n}\n```\n## 标签模板\n作用：\n1. 防止xss攻击\n2. 多语言支持\n```javascript\n{\n  let user = {\n    name: 'list',\n    info: 'hello world'\n  };\n  let str = abc`I am ${user.name},${user.info}`;\n  console.log(str); // I am ,,,listhello world\n  function abc (s, v1, v2) {\n    console.log(s, v1, v2); // (3) [\"I am \", \",\", \"\", raw: Array(3)] \"list\" \"hello world\"\n    return s + v1 + v2;\n  }\n}\n```","source":"_posts/ES6梳理-字符串扩展.md","raw":"---\ntitle: ES6梳理-字符串扩展\ncategories:\n  - ES6\n  - 字符串扩展\ntags:\n  - ES6\n  - 字符串扩展\ndate: 2019-04-30 14:00:00\n---\n\n# 字符串新增的特性：\n+ Unicode表示法\n+ 遍历接口\n+ 模板字符串\n+ 新增方法（10种）\n<!-- more -->\n\n## Unicode表示法\n+ 引入： \n```javascript\n{\n  console.log('a', '\\u0061'); // a a\n  console.log('s', '\\u20BB7'); // s ₻7\n                    //这个超过了0xffff，也就是超过了2字节，他会把20BB和7分别拿出来解析，20BB不是unicode的编码，所以不能识别 \n} \n```\n+ 在ES6中处理超过2字节的unicode编码，使用{}包起来，比如：\n```javascript\n{\n  console.log('s', '\\u{20BB7}'); // s 𠮷\n} \n```\n+ ES5和ES6处理码值： \n```javascript\n{\n  let a = 'a'; \n  let s = '𠮷';\n  console.log(a.length) // 1\n  console.log(s.length) // 2\n  console.log('0', s.charAt(0)) // 0 � 取s的Unicode编码第1个位置的字符\n  console.log('1', s.charAt(1)) // 1 � 取s的Unicode编码第2个位置的字符\n  console.log('at0', s.charCodeAt(0).toString(16)) // at0 d842 \n  console.log('at1', s.charCodeAt(1).toString(16)) // at1 dfb7\n  console.log('a', a.charCodeAt(0).toString(16)) // a 61\n\n//ES6中的codePointeAt()\nlet s1 = '𠮷a'\nconsole.log(s1.length)\nconsole.log(s1.codePointAt(0).toString(16)) // 20bb7 取了4字节的码值，codePointAt()方法会先去判断指定字符是2字节的还是4字节的，然后再去获得Unicode编码\nconsole.log(s1.codePointAt(1).toString(16)) // dfb7\nconsole.log(s1.codePointAt(2).toString(16)) // 61\n}\n{\n  // ES5中方法\n  console.log(String.fromCharCode(\"0x20bb7\")); // ஷ\n  // ES6中方法\n  console.log(String.fromCodePoint(\"0x20bb7\")) // 𠮷\n\n  // 两者区别就是能否处理超过2字节的Unicode字符\n}\n```\n## ES5和ES6的字符串遍历\n```javascript\n{\n  // 常用的字符遍历器接口\n  let str = '\\u{20bb7}abc';\n  // ES6处理\n  for (let code of str) { \n    console.log('ES6', code) // ES6 𠮷\n                              // ES6 a\n                              // ES6 b  \n                              // ES6 c\n  }\n\n  // ES5不能处理\n  for (let i = 0; i < str.length; i++) {\n    console.log('es5', str[i]) // es5 �\n                                // es5 �\n                                // es5 a\n                                // es5 b\n                                // es5 c\n  }\n  let arr = str.split(\"\") // split(\"\")也是按照2个字节为一个字符来处理的，所以把1个4字节的字符识别成了2个2字节的字符\n  console.log(arr) // [\"�\", \"�\", \"a\", \"b\", \"c\"] \n  {\n    let str2 = \"你好\";\n    console.log(str2[1]) // \"好\"\n  }\n}\n```\n## ES6新增的经常使用的字符串处理API\n```javascript\n{\n  let str = \"string\";\n\n  // ES6对字符串进行简单查询\n  {\n    console.log(\"includes\", str.includes(\"r\")); // includes true\n    console.log(\"start\", str.startsWith('str')) // start true\n    console.log(\"end\", str.endsWith('ng')) // end true\n  }\n  \n  // ES6重复字符串\n  {\n    // ES6重复字符串\n    console.log(str.repeat(2)); // stringstring\n    // ES5重复字符串\n    let str2 = str\n    str2 += str;\n    console.log(str2) // stringstring\n    \n    // 为String添加一个mRepeat原型方法\n    String.prototype.mRepeat = function (n) {\n    let str = this.valueOf();\n    let str2 = \"\";\n    for (let i = 0; i < n; i ++) {\n      str2 += str\n    }\n    return str2;\n    }\n    console.log(str.mRepeat(2));\n  }\n\n  //模板字符串\n  {\n    let name = \"list\";\n    let info = \"hello world\";\n    let s = `I am ${name},${info}`;\n    console.log(s); // I am list,hello world\n  }\n\n  // String.raw()\n  {\n    console.log(String.raw`Hi\\n${1+2}`); // Hi\\n3 换行符并没有生效，也就是在\"\\\"前面又隐式的加了一个\"\\\", \\n  => \\\\n\n    // 等价于\n    console.log(`Hi\\\\n${1+2}`) // Hi\\n3\n\n    console.log(`Hi\\n${1+2}`); // Hi\n                                // 3 \n    console.log('ma\\\\n') // ma\\n \n  }\n\n  // ES7草案\n  {\n    // padStart和endStart方法非常实用，比如日期补白: 2019-6-2 => 2019-06-02\n    console.log('1', padStart(2, '0')); // 01\n    // padStart()谷歌识别不了，第一个参数指定字符串长度，如果不够用第二个字符参数往前补白\n    console.log('1', padEnd(2, '0')); // 10\n    // padEnd()向后补白\n  }\n}\n```\n## 标签模板\n作用：\n1. 防止xss攻击\n2. 多语言支持\n```javascript\n{\n  let user = {\n    name: 'list',\n    info: 'hello world'\n  };\n  let str = abc`I am ${user.name},${user.info}`;\n  console.log(str); // I am ,,,listhello world\n  function abc (s, v1, v2) {\n    console.log(s, v1, v2); // (3) [\"I am \", \",\", \"\", raw: Array(3)] \"list\" \"hello world\"\n    return s + v1 + v2;\n  }\n}\n```","slug":"ES6梳理-字符串扩展","published":1,"updated":"2020-01-20T07:45:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghn000jlktvfk5v421x"},{"title":"ES6梳理-对象扩展","date":"2019-07-08T06:15:45.000Z","_content":"# 对象扩展\n+ 简洁表示法\n+ 属性表达式\n+ 扩展运算符\n+ Object新增方法\n<!-- more -->\n### 简洁表达\n```javascript\n{\n  let name = 'masia';\n  let age = 14;\n  // ES5中创建对象\n  const es5 = {\n    name: name,\n    age: age,\n    level: 6,\n    getName: function () {\n      console.log(this.name)\n    }\n  }\n  console.log(es5) // {name: \"masia\", age: 14, level: 6, getName: ƒ}\n  // ES6创建对象\n  const es6 = {\n    name,\n    age,\n    level: 6,\n    getName () {\n      console.log(this.name)\n    }\n  }\n  console.log(es6) // {name: \"masia\", age: 14, level: 6, getName: ƒ}\n}\n```\n### 属性表达式\n```javascript\n{\n  // 在ES5中对象的key值必须是一个字符串，固定的\n  let a = 'aa';\n  let fnName = 'fn';\n  const es5 = {\n    aa: 'value',\n    fn: function () {}\n  }\n  // 但在ES6中对象的key值可以是一个表达式，用[]包起来\n  const es6 = {\n    [a]: 'value',\n    [fnName]: function () {}\n  }\n  console.log(es5); // {aa: \"value\", fn: ƒ}\n  console.log(es6); // {aa: \"value\", fn: ƒ}\n}\n```\n### 扩展运算符\n```javascript\n{\n  const obj = {\n    a: 1, \n    b: 2,\n    c: 3,\n    d: 4,\n  };\n  let {a, b, ...c} = obj;\n  console.log(a); // 1\n  console.log(b); // 2\n  console.log(c); // {c: 3, d: 4}\n}\n```\n### 新增的常用Api\n+ Object.is()，判断两个值是否完全相等，在功能上与\"===\"完全相同\n```javascript\n{\n  let str1 = 'abc';\n  let str2 = 'abc';\n  console.log('字符串', Object.is(str1, str2), str1 === str2); // 字符串 true true\n  console.log('数组', Object.is([], []), [] === []); // 数组 false false\n}\n```\n+ Object.assign()浅复制\n对象拷贝，使用第二个参数对象覆盖第一个参数对象，并且改变两个参数对象的内容，返回值为第一个参数对象的引用\n```javascript\n {\n  let obj1 = {\n    a: 1,\n  }\n  let obj2 = {\n    a: 11,\n    b:2\n  }\n  let obj3 = Object.assign(obj1, obj2);\n  console.log(obj1) // {a: 11, b: 2}\n  console.log(obj2) // {a: 11, b: 2}\n  console.log(obj3) // {a: 11, b: 2}\n  console.log(obj1 == obj2) // false\n  console.log(obj1 == obj3) // true\n}\n```\n+ Object.entries()\n方法的返回值是一个可迭代对象\n需要注意的是调用方式，这个方法用作数组是ArrayObj.entries(),而一般对象则为Object.entries(obj)\n```javascript\n{\n  let obj = {\n    a: 111,\n    b: '222',\n    c: function () {},\n    d: {}\n  }\n  for (let [key, value] of Object.entries(obj)) {\n    console.log(key, value);\n    /*\n      a 111\n      b 222\n      c ƒ () {}\n      d {}\n    */\n    console.log(Object.entries(obj));\n  }\n}\n```\n{% asset_img Object.entries().png ES5构造函数继承和原型链继承组合继承 %}\n","source":"_posts/ES6梳理-对象扩展.md","raw":"---\ntitle: ES6梳理-对象扩展\ndate: 2019-07-08 14:15:45\ntags: \n - ES6\n - 对象扩展\ncategories: \n - ES6\n - 对象扩展\n---\n# 对象扩展\n+ 简洁表示法\n+ 属性表达式\n+ 扩展运算符\n+ Object新增方法\n<!-- more -->\n### 简洁表达\n```javascript\n{\n  let name = 'masia';\n  let age = 14;\n  // ES5中创建对象\n  const es5 = {\n    name: name,\n    age: age,\n    level: 6,\n    getName: function () {\n      console.log(this.name)\n    }\n  }\n  console.log(es5) // {name: \"masia\", age: 14, level: 6, getName: ƒ}\n  // ES6创建对象\n  const es6 = {\n    name,\n    age,\n    level: 6,\n    getName () {\n      console.log(this.name)\n    }\n  }\n  console.log(es6) // {name: \"masia\", age: 14, level: 6, getName: ƒ}\n}\n```\n### 属性表达式\n```javascript\n{\n  // 在ES5中对象的key值必须是一个字符串，固定的\n  let a = 'aa';\n  let fnName = 'fn';\n  const es5 = {\n    aa: 'value',\n    fn: function () {}\n  }\n  // 但在ES6中对象的key值可以是一个表达式，用[]包起来\n  const es6 = {\n    [a]: 'value',\n    [fnName]: function () {}\n  }\n  console.log(es5); // {aa: \"value\", fn: ƒ}\n  console.log(es6); // {aa: \"value\", fn: ƒ}\n}\n```\n### 扩展运算符\n```javascript\n{\n  const obj = {\n    a: 1, \n    b: 2,\n    c: 3,\n    d: 4,\n  };\n  let {a, b, ...c} = obj;\n  console.log(a); // 1\n  console.log(b); // 2\n  console.log(c); // {c: 3, d: 4}\n}\n```\n### 新增的常用Api\n+ Object.is()，判断两个值是否完全相等，在功能上与\"===\"完全相同\n```javascript\n{\n  let str1 = 'abc';\n  let str2 = 'abc';\n  console.log('字符串', Object.is(str1, str2), str1 === str2); // 字符串 true true\n  console.log('数组', Object.is([], []), [] === []); // 数组 false false\n}\n```\n+ Object.assign()浅复制\n对象拷贝，使用第二个参数对象覆盖第一个参数对象，并且改变两个参数对象的内容，返回值为第一个参数对象的引用\n```javascript\n {\n  let obj1 = {\n    a: 1,\n  }\n  let obj2 = {\n    a: 11,\n    b:2\n  }\n  let obj3 = Object.assign(obj1, obj2);\n  console.log(obj1) // {a: 11, b: 2}\n  console.log(obj2) // {a: 11, b: 2}\n  console.log(obj3) // {a: 11, b: 2}\n  console.log(obj1 == obj2) // false\n  console.log(obj1 == obj3) // true\n}\n```\n+ Object.entries()\n方法的返回值是一个可迭代对象\n需要注意的是调用方式，这个方法用作数组是ArrayObj.entries(),而一般对象则为Object.entries(obj)\n```javascript\n{\n  let obj = {\n    a: 111,\n    b: '222',\n    c: function () {},\n    d: {}\n  }\n  for (let [key, value] of Object.entries(obj)) {\n    console.log(key, value);\n    /*\n      a 111\n      b 222\n      c ƒ () {}\n      d {}\n    */\n    console.log(Object.entries(obj));\n  }\n}\n```\n{% asset_img Object.entries().png ES5构造函数继承和原型链继承组合继承 %}\n","slug":"ES6梳理-对象扩展","published":1,"updated":"2020-01-20T07:45:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghp000nlktv4nfgv663"},{"title":"ES6梳理-数值扩展","date":"2019-05-01T02:00:00.000Z","_content":"\n## ES6把一些全局的属性移植到内置的类上，比如把全局的parseInt()方法移到了Number的原型对象上\n```javascript\n{\n  let num = 66.3;\n  console.log(parseInt(num))\n  console.log(Number.hasOwnProperty('parseInt'))\n} \n```\n<!-- more -->\n### ES6新增的数值操作：\n```javascript\n// js二进制八进制的表示方法\n{\n  console.log('二进制', 0B111111); // 二进制 63\n  console.log('八进制', 0o17); // 十六进制 15\n  console.log('十六进制', 0xff); // 十六进制 255\n} \n// 判断一个数是否是有限的\n{\n  console.log('15', Number.isFinite(15)); // 15 true\n  console.log('NaN', Number.isFinite(NaN)); // NaN false\n  console.log('1/0', Number.isFinite(1/0)); // 1/0 false\n\n  console.log('NaN', Number.isNaN(NaN)); // true\n  console.log('0', Number.isNaN(0)); // false\n} \n// 判断是不是整数\n{\n  console.log('25', Number.isInteger(25)); // 25 true\n  console.log('25.0', Number.isInteger(25.0)); // 25.0 true\n  console.log('25.1', Number.isInteger(25.1)); // 25.1 false\n  console.log('25.1字符串', Number.isInteger('25.1')); // 25.1字符串 false\n}\n// 数值范围是-2的53次幂（不包含）到2的53次幂（包含）\n{\n  console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991 表示数的最大的上限\n  console.log(Number.MIN_SAFE_INTEGER) // -9007199254740991 表示数的最小的下限\n  console.log(Number.NaN) // NaN\n}\n// 判断一个数是否在安全范围之内\n{\n  console.log('10', Number.isSafeInteger(10)); // 10 true\n  console.log('10字符串', Number.isSafeInteger('10')); // 10字符串 false\n  console.log('NaN', Number.isSafeInteger(NaN)); // NaN false\n}\n// 返回小数的整数部分\n{\n  console.log('4.1', Math.trunc(4.1)); // 4.1 4\n  console.log('4.5', Math.trunc(4.5)); // 4.5 4\n}\n// 判断一个是正数、负数还是0， \n{\n  // Math.sign()的返回值是四种情况，分别为： 0 1 -1 NaN\n  console.log('-5', Math.sign(-5)); // -5 -1\n  console.log('-5', Math.sign(0)); // -5 0\n  console.log('5', Math.sign(5)); // 5 1\n  console.log('5字符串', Math.sign('5')); // 5字符串 1\n  console.log('NaN', Math.sign(NaN)); // NaN NaN\n}\n// 求一个数的立方根\n{\n  console.log('8的立方根', Math.cbrt(8)); // 8的立方根 2\n  console.log('2的立方根', Math.cbrt(2)); // 2的立方根 1.2599210498948732\n  console.log('-1的立方根', Math.cbrt(-1)); // -1的立方根 -1\n}\n// 还新增了三角函数和对数API等\n```\n\n","source":"_posts/ES6梳理-数值扩展.md","raw":"---\ntitle: ES6梳理-数值扩展\ncategories:\n  - ES6\n  - 数值扩展\ntags:\n  - ES6\n  - 数值扩展\ndate: 2019-05-01 10:00:00\n---\n\n## ES6把一些全局的属性移植到内置的类上，比如把全局的parseInt()方法移到了Number的原型对象上\n```javascript\n{\n  let num = 66.3;\n  console.log(parseInt(num))\n  console.log(Number.hasOwnProperty('parseInt'))\n} \n```\n<!-- more -->\n### ES6新增的数值操作：\n```javascript\n// js二进制八进制的表示方法\n{\n  console.log('二进制', 0B111111); // 二进制 63\n  console.log('八进制', 0o17); // 十六进制 15\n  console.log('十六进制', 0xff); // 十六进制 255\n} \n// 判断一个数是否是有限的\n{\n  console.log('15', Number.isFinite(15)); // 15 true\n  console.log('NaN', Number.isFinite(NaN)); // NaN false\n  console.log('1/0', Number.isFinite(1/0)); // 1/0 false\n\n  console.log('NaN', Number.isNaN(NaN)); // true\n  console.log('0', Number.isNaN(0)); // false\n} \n// 判断是不是整数\n{\n  console.log('25', Number.isInteger(25)); // 25 true\n  console.log('25.0', Number.isInteger(25.0)); // 25.0 true\n  console.log('25.1', Number.isInteger(25.1)); // 25.1 false\n  console.log('25.1字符串', Number.isInteger('25.1')); // 25.1字符串 false\n}\n// 数值范围是-2的53次幂（不包含）到2的53次幂（包含）\n{\n  console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991 表示数的最大的上限\n  console.log(Number.MIN_SAFE_INTEGER) // -9007199254740991 表示数的最小的下限\n  console.log(Number.NaN) // NaN\n}\n// 判断一个数是否在安全范围之内\n{\n  console.log('10', Number.isSafeInteger(10)); // 10 true\n  console.log('10字符串', Number.isSafeInteger('10')); // 10字符串 false\n  console.log('NaN', Number.isSafeInteger(NaN)); // NaN false\n}\n// 返回小数的整数部分\n{\n  console.log('4.1', Math.trunc(4.1)); // 4.1 4\n  console.log('4.5', Math.trunc(4.5)); // 4.5 4\n}\n// 判断一个是正数、负数还是0， \n{\n  // Math.sign()的返回值是四种情况，分别为： 0 1 -1 NaN\n  console.log('-5', Math.sign(-5)); // -5 -1\n  console.log('-5', Math.sign(0)); // -5 0\n  console.log('5', Math.sign(5)); // 5 1\n  console.log('5字符串', Math.sign('5')); // 5字符串 1\n  console.log('NaN', Math.sign(NaN)); // NaN NaN\n}\n// 求一个数的立方根\n{\n  console.log('8的立方根', Math.cbrt(8)); // 8的立方根 2\n  console.log('2的立方根', Math.cbrt(2)); // 2的立方根 1.2599210498948732\n  console.log('-1的立方根', Math.cbrt(-1)); // -1的立方根 -1\n}\n// 还新增了三角函数和对数API等\n```\n\n","slug":"ES6梳理-数值扩展","published":1,"updated":"2020-01-20T07:45:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghq000olktv4vhpipq7"},{"title":"ES6梳理-数据结构","date":"2019-07-08T08:57:54.000Z","_content":"# 数据结构\n+ set用法\n+ Map用法\n+ WeakSet用法\n+ WeakMap用法\n<!-- more -->\n\nset可以理解为数组，但是该集合中的元素不能重复\nmap可以理解成为对象，但是普通对象中的key一定是一个字符串，map中的key可以是其他数据类型，比如一个数组、一个对象都可以做他的key\n\n### set用法\n+ 基本用法\n```javascript\n{\n  // Set的普通定义方法\n  let list = new Set();\n  list.add(5); // 向set中增加值，要使用add()方法\n  list.add(7);\n  console.log(list);\n  console.log('size', list.size); // size 2\n} \n```\n{% asset_img set.png Set()的基本用法 %}\n+ Set(arr)将传入数组转化为一个集合\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  let list = new Set(arr); // 将arr数组转化为数组集合\n  console.log(list);\n  console.log(list.size); // 4\n}\n```\n{% asset_img Set(arr).png console.log(list); %}\n+ Set类型的元素必须是唯一的，不能重复\n```javascript\n{\n  let list = new Set();\n  list.add(5); \n  list.add(7);\n  list.add(5); // 没有添加进去，并不会报错\n  console.log(list); // Set(2) {5, 7}\n  console.log('size', list.size); // size 2\n}\n// 利用这个特性，我们可以做数组去重\n{\n  arr = [1, 1, 2, 2, 3, 3, 4, '4'];\n  let list = new Set(arr);\n  console.log('unique', list) // unique Set(5) {1, 2, 3, 4, \"4\"} 字符串4和数字4不算重复\n  let newArr = Array.from(list);\n  console.log(newArr); // [1, 2, 3, 4, '4']\n}\n```\n+ Set实例对象的常用方法：\n```javascript\n{\n  let arr = ['add', 'delete', 'clear', 'has']\n  let list = new Set(arr);\n  console.log(list.add('masia')); // 返回值为添加之后的集合：{\"add\", \"delete\", \"clear\", \"has\", \"masia\"}\n  console.log(list.has('add')); // true\n  console.log(list.delete('add')); // true\n  console.log(list); // Set(3) {\"delete\", \"clear\", \"has\"}\n  console.log(list.clear('clear')); // undefined\n  console.log(list); // Set(0) {}\n}\n```\n+ Set实例对象的遍历\n```javascript\n{\n  let arr = ['add', 'delete', 'clear', 'has']\n  let list = new Set(arr);\n  for (let key of list.keys()) {\n    console.log('keys', key); // 但好像打印的是value值\n    /*\n      keys add\n      keys delete\n      keys clear\n      keys has\n    */\n  }\n  for (let value of list.values()) {\n    console.log('keys', value); // 结果仍然是value值\n    /*\n      keys add\n      keys delete\n      keys clear\n      keys has\n    */\n  }\n  for (let value of list) {\n    console.log('keys', value); // 直接遍历list，结果也是value值\n    /*\n      keys add\n      keys delete\n      keys clear\n      keys has\n    */\n  }\n  for (let [key, value] of list.entries()) {\n    console.log('keys', key, 'value', value); // 当然也可以调用entries()方法，结果也是value值\n    /*\n      keys add value add\n      keys delete value delete\n      keys clear value clear\n      keys has value has\n    */\n  }\n  list.forEach(function (value, key) {\n    console.log('key', key, 'value', value) // 当然也可以使用forEach()方法\n    /*\n      key add value add\n      key delete value delete\n      key clear value clear\n      key has value has\n    */\n  });\n}\n```\n### WeakSet用法\n+ WeakSet基本用法：\n与Set的区别：\n1. WeakSet的元素的key值必须是对象，而Set的元素可以是任意类型\n2. WeakSet的元素的key值是一个弱引用(元素值都是地址的引用，而且并不会检测地址所对应的对象是否被垃圾回收了)\n3. WeakSet没有size属性\n4. WeakSet没有clear()方法\n5. WeakSet不能遍历\n与Set的相同点: has(), delete(), add()方法使用相同\n```javascript\n{\n  let obj = { a: 1 };\n  let obj2 = { b: 2 };\n  let weakList = new WeakSet();\n  weakList.add(obj);\n  weakList.add(obj2);\n  console.log(weakList);\n}\n```\n{% asset_img WeakSet().png console.log(weakList); %}\n### Map的用法\nMap的特性：key可以是任何数据类型\n+ Map的基本用法\n```javascript\n{\n  let map = new Map();\n  let arr = ['123'];\n  map.set(arr, 456) // Map的实例对象添加元素使用set()\n  // 使用数组arr做key， value为456\n  console.log(map); // Map(1) {Array(1) => 456}\n  console.log(map.get(arr)); // 456  使用get()获取属性值\n}\n```\n+ Map的第二种定义方式\nMap()，参数是数组，数组中又有两个数组\n```javascript\n{\n  let arr = ['a', 123]; // 第一个数组必须包含两项值\n  let arr2 = ['b', 456];\n  let map = new Map([arr, arr2]);\n  console.log(map) // Map(2) {\"a\" => 123, \"b\" => 456}\n  console.log(map.set(arr, 999)); // Map(3) {\"a\" => 123, \"b\" => 456, Array(2) => 999}\n  console.log(map.size); // 2\n  console.log(map.get('a')  ); // 123\n  console.log(map.delete('a'), map); // true Map(2) {\"b\" => 456, Array(2) => 999}\n  console.log(map.clear(), map); // undefined Map(0) {}\n}\n```\n{% asset_img Map([]).png console.log(map) %}\n+ Map实例对象的遍历和Set一模一样\n### WeakMap\n与Map的区别：（即Set和WeakSet的区别）\n1. WeakMap的元素的key值必须是对象，而Set的元素可以是任意类型\n2. WeakMap的元素的key值是一个弱引用(元素值都是地址的引用，而且并不会检测地址所对应的对象是否被垃圾回收了)\n3. WeakMap没有size属性\n4. WeakMap没有clear()方法\n5. WeakMap不能遍历\n```javascript\n{\n  let obj1 = { a: 1 }\n  let obj2 = { b: 1 }\n  let weakMap = new WeakMap();\n  weakMap.set(obj1, 'aa');\n  weakMap.set(obj2, 'bb');\n  console.log(weakMap); // WeakMap {{…} => \"aa\", {…} => \"bb\"}\n  console.log(weakMap.get(obj1)); // aa\n}\n```","source":"_posts/ES6梳理-数据结构.md","raw":"---\ntitle: ES6梳理-数据结构\ndate: 2019-07-08 16:57:54\ntags:\n - ES6\n - 数据结构\ncategories: \n - ES6\n - 数据结构\n---\n# 数据结构\n+ set用法\n+ Map用法\n+ WeakSet用法\n+ WeakMap用法\n<!-- more -->\n\nset可以理解为数组，但是该集合中的元素不能重复\nmap可以理解成为对象，但是普通对象中的key一定是一个字符串，map中的key可以是其他数据类型，比如一个数组、一个对象都可以做他的key\n\n### set用法\n+ 基本用法\n```javascript\n{\n  // Set的普通定义方法\n  let list = new Set();\n  list.add(5); // 向set中增加值，要使用add()方法\n  list.add(7);\n  console.log(list);\n  console.log('size', list.size); // size 2\n} \n```\n{% asset_img set.png Set()的基本用法 %}\n+ Set(arr)将传入数组转化为一个集合\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  let list = new Set(arr); // 将arr数组转化为数组集合\n  console.log(list);\n  console.log(list.size); // 4\n}\n```\n{% asset_img Set(arr).png console.log(list); %}\n+ Set类型的元素必须是唯一的，不能重复\n```javascript\n{\n  let list = new Set();\n  list.add(5); \n  list.add(7);\n  list.add(5); // 没有添加进去，并不会报错\n  console.log(list); // Set(2) {5, 7}\n  console.log('size', list.size); // size 2\n}\n// 利用这个特性，我们可以做数组去重\n{\n  arr = [1, 1, 2, 2, 3, 3, 4, '4'];\n  let list = new Set(arr);\n  console.log('unique', list) // unique Set(5) {1, 2, 3, 4, \"4\"} 字符串4和数字4不算重复\n  let newArr = Array.from(list);\n  console.log(newArr); // [1, 2, 3, 4, '4']\n}\n```\n+ Set实例对象的常用方法：\n```javascript\n{\n  let arr = ['add', 'delete', 'clear', 'has']\n  let list = new Set(arr);\n  console.log(list.add('masia')); // 返回值为添加之后的集合：{\"add\", \"delete\", \"clear\", \"has\", \"masia\"}\n  console.log(list.has('add')); // true\n  console.log(list.delete('add')); // true\n  console.log(list); // Set(3) {\"delete\", \"clear\", \"has\"}\n  console.log(list.clear('clear')); // undefined\n  console.log(list); // Set(0) {}\n}\n```\n+ Set实例对象的遍历\n```javascript\n{\n  let arr = ['add', 'delete', 'clear', 'has']\n  let list = new Set(arr);\n  for (let key of list.keys()) {\n    console.log('keys', key); // 但好像打印的是value值\n    /*\n      keys add\n      keys delete\n      keys clear\n      keys has\n    */\n  }\n  for (let value of list.values()) {\n    console.log('keys', value); // 结果仍然是value值\n    /*\n      keys add\n      keys delete\n      keys clear\n      keys has\n    */\n  }\n  for (let value of list) {\n    console.log('keys', value); // 直接遍历list，结果也是value值\n    /*\n      keys add\n      keys delete\n      keys clear\n      keys has\n    */\n  }\n  for (let [key, value] of list.entries()) {\n    console.log('keys', key, 'value', value); // 当然也可以调用entries()方法，结果也是value值\n    /*\n      keys add value add\n      keys delete value delete\n      keys clear value clear\n      keys has value has\n    */\n  }\n  list.forEach(function (value, key) {\n    console.log('key', key, 'value', value) // 当然也可以使用forEach()方法\n    /*\n      key add value add\n      key delete value delete\n      key clear value clear\n      key has value has\n    */\n  });\n}\n```\n### WeakSet用法\n+ WeakSet基本用法：\n与Set的区别：\n1. WeakSet的元素的key值必须是对象，而Set的元素可以是任意类型\n2. WeakSet的元素的key值是一个弱引用(元素值都是地址的引用，而且并不会检测地址所对应的对象是否被垃圾回收了)\n3. WeakSet没有size属性\n4. WeakSet没有clear()方法\n5. WeakSet不能遍历\n与Set的相同点: has(), delete(), add()方法使用相同\n```javascript\n{\n  let obj = { a: 1 };\n  let obj2 = { b: 2 };\n  let weakList = new WeakSet();\n  weakList.add(obj);\n  weakList.add(obj2);\n  console.log(weakList);\n}\n```\n{% asset_img WeakSet().png console.log(weakList); %}\n### Map的用法\nMap的特性：key可以是任何数据类型\n+ Map的基本用法\n```javascript\n{\n  let map = new Map();\n  let arr = ['123'];\n  map.set(arr, 456) // Map的实例对象添加元素使用set()\n  // 使用数组arr做key， value为456\n  console.log(map); // Map(1) {Array(1) => 456}\n  console.log(map.get(arr)); // 456  使用get()获取属性值\n}\n```\n+ Map的第二种定义方式\nMap()，参数是数组，数组中又有两个数组\n```javascript\n{\n  let arr = ['a', 123]; // 第一个数组必须包含两项值\n  let arr2 = ['b', 456];\n  let map = new Map([arr, arr2]);\n  console.log(map) // Map(2) {\"a\" => 123, \"b\" => 456}\n  console.log(map.set(arr, 999)); // Map(3) {\"a\" => 123, \"b\" => 456, Array(2) => 999}\n  console.log(map.size); // 2\n  console.log(map.get('a')  ); // 123\n  console.log(map.delete('a'), map); // true Map(2) {\"b\" => 456, Array(2) => 999}\n  console.log(map.clear(), map); // undefined Map(0) {}\n}\n```\n{% asset_img Map([]).png console.log(map) %}\n+ Map实例对象的遍历和Set一模一样\n### WeakMap\n与Map的区别：（即Set和WeakSet的区别）\n1. WeakMap的元素的key值必须是对象，而Set的元素可以是任意类型\n2. WeakMap的元素的key值是一个弱引用(元素值都是地址的引用，而且并不会检测地址所对应的对象是否被垃圾回收了)\n3. WeakMap没有size属性\n4. WeakMap没有clear()方法\n5. WeakMap不能遍历\n```javascript\n{\n  let obj1 = { a: 1 }\n  let obj2 = { b: 1 }\n  let weakMap = new WeakMap();\n  weakMap.set(obj1, 'aa');\n  weakMap.set(obj2, 'bb');\n  console.log(weakMap); // WeakMap {{…} => \"aa\", {…} => \"bb\"}\n  console.log(weakMap.get(obj1)); // aa\n}\n```","slug":"ES6梳理-数据结构","published":1,"updated":"2020-01-20T07:45:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghr000rlktvptxih8y4"},{"title":"ES6梳理-数据结构对比","date":"2019-07-08T08:58:54.000Z","_content":"# 数据结构对比\n理解什么情况下用Map，什么情况下用Set\n+ Map与Array对比\n+ Set与Array对比 \n+ Map与object对比\n+ Set与object对比\n<!-- more -->\n\n### Map与Array对比\n```javascript\n// Map与Array对比，增删改查\n{\n  let map = new Map(); // \n  let array = [];\n  // 增\n  map.set('t', 1);\n  array.push({t: 1});\n  console.log('map', map); // map Map(1) {\"t\" => 1}\n  console.log('array', array); // array [{ t: 1 }]\n\n  // 查\n  let map_exist = map.has('t');\n  let array_exist = array.find(i => i.t);\n  console.log('map_exist', map_exist); // map_exist true\n  console.log('array_exist', array_exist); // array_exist {t: 1}\n\n  // 改\n  map.set('t', 2);\n  array.forEach(i => {\n    i.t && (i.t = 2);\n  })\n  console.log('修改后的map', map); // 修改后的map Map(1) {\"t\" => 2}\n  console.log('修改后的Array', array) // 修改后的Array [{ t: 2 }]\n\n  // 删\n  map.delete('t'); \n  let index = array.findIndex(item => item.t);\n  array.splice(index, 1);\n  console.log('删除后的map', map); // 删除后的map Map(0) {}\n  console.log('删除后的array', array); // 删除后的array []\n}\n```\n\n### Set与Array对比\n```javascript\n// Set与Array对比，增删改查\n{\n  let set = new Set(); \n  let array = [];\n  // 增\n  let obj = {t: 1};\n  console.log(set.add(obj)); // Set(1) {{…}} set.add()返回的是操作之后的Set对象\n  console.log(array.push({t: 1})); // 1  array.push()返回的是操作之后的数组长度\n  console.log(set); // Set(1) {Object {t: 1}}\n  console.log(array); // [{t: 1}]\n  // 查\n  let set_exist = set.has(obj) // 返回值是true\n  let array_exist = array.find(item => item.t);\n  console.log(set_exist); // true\n  console.log(array_exist); // {t: 1}\n  // 改（这里的改对于数组，不是按照数组下标获取数组元素的值，而是获取数组元素对象中t的值，所以要先forEach查询）\n  console.log(set.forEach(item => item.t ? item.t = 2 : '')); // undefined 方法forEach()的返回值是undefined\n  console.log(array.forEach(item => item.t ? item.t = 2 : '')); // undefined undefined\n  console.log(set); // Set(1) {Object {t: 2}} ，其中 {t: 2} ，则证明被修改了\n  console.log(array); // [{t: 2}]\n  // 删 （两者也同样通过forEach先找到，再删除）\n  set.forEach(item => item.t ? set.delete(item) : '');\n  let index = array.findIndex(item => item.t);\n\n  array.splice(index, 1);\n  console.log(set); // Set(0) {}\n  console.log(array); // []\n}  \n```\n\n### Map与object对比\n```javascript\n// Map、Set与object对比，增删改查\n{\n  let item = {t: 1};\n  let map = new Map();\n  let set = new Set();\n  let obj = {};\n\n  // 增\n  map.set('t', 1);\n  set.add(item);\n  obj['t'] = 1;\n  console.info({\n    map, // map: Map(1) {\"t\" => 1}\n    set, // set: Set(1) {Object {t: 1}}\n    obj // obj: {t: 1}\n  })\n  // 查\n  console.info({\n    map_exist: map.has('t'), // map_exist: true\n    set_exist: set.has(item), // obj_exist: true\n    obj_exist: 't' in obj // set_exist: true\n  })\n\n  set.forEach(item => {\n    item.t && console.log(item);\n  })\n  // 改\n  map.set('t', 2); // 覆盖了原来的值\n  set.forEach(item => item.t && (item.t = 2));\n  obj['t'] = 2;\n  console.info({\n    map, // map: Map(1) {\"t\" => 2}\n    set, // set: Set(1) {Object {t: 2}}\n    obj // obj: {t: 2}\n  })\n  // 删\n  map.delete('t');\n  set.delete(item); \n  // 或 set.forEach(item => item.t && (set.delete(item)));\n  delete obj['t'];\n  console.info({\n    map, // map: Map(0) {}\n    set, // set: Set(0) {}\n    obj // obj: {} \n  })\n}\n```\n总结：\n1. 能使用Map，不使用数组，里面越复杂，越适合使用Map\n2. 要求数据存储的唯一性，则使用Set\n3. 优先使用Map，放弃使用Array和Object","source":"_posts/ES6梳理-数据结构对比.md","raw":"---\ntitle: ES6梳理-数据结构对比\ndate: 2019-07-08 16:58:54\ntags:\n---\n# 数据结构对比\n理解什么情况下用Map，什么情况下用Set\n+ Map与Array对比\n+ Set与Array对比 \n+ Map与object对比\n+ Set与object对比\n<!-- more -->\n\n### Map与Array对比\n```javascript\n// Map与Array对比，增删改查\n{\n  let map = new Map(); // \n  let array = [];\n  // 增\n  map.set('t', 1);\n  array.push({t: 1});\n  console.log('map', map); // map Map(1) {\"t\" => 1}\n  console.log('array', array); // array [{ t: 1 }]\n\n  // 查\n  let map_exist = map.has('t');\n  let array_exist = array.find(i => i.t);\n  console.log('map_exist', map_exist); // map_exist true\n  console.log('array_exist', array_exist); // array_exist {t: 1}\n\n  // 改\n  map.set('t', 2);\n  array.forEach(i => {\n    i.t && (i.t = 2);\n  })\n  console.log('修改后的map', map); // 修改后的map Map(1) {\"t\" => 2}\n  console.log('修改后的Array', array) // 修改后的Array [{ t: 2 }]\n\n  // 删\n  map.delete('t'); \n  let index = array.findIndex(item => item.t);\n  array.splice(index, 1);\n  console.log('删除后的map', map); // 删除后的map Map(0) {}\n  console.log('删除后的array', array); // 删除后的array []\n}\n```\n\n### Set与Array对比\n```javascript\n// Set与Array对比，增删改查\n{\n  let set = new Set(); \n  let array = [];\n  // 增\n  let obj = {t: 1};\n  console.log(set.add(obj)); // Set(1) {{…}} set.add()返回的是操作之后的Set对象\n  console.log(array.push({t: 1})); // 1  array.push()返回的是操作之后的数组长度\n  console.log(set); // Set(1) {Object {t: 1}}\n  console.log(array); // [{t: 1}]\n  // 查\n  let set_exist = set.has(obj) // 返回值是true\n  let array_exist = array.find(item => item.t);\n  console.log(set_exist); // true\n  console.log(array_exist); // {t: 1}\n  // 改（这里的改对于数组，不是按照数组下标获取数组元素的值，而是获取数组元素对象中t的值，所以要先forEach查询）\n  console.log(set.forEach(item => item.t ? item.t = 2 : '')); // undefined 方法forEach()的返回值是undefined\n  console.log(array.forEach(item => item.t ? item.t = 2 : '')); // undefined undefined\n  console.log(set); // Set(1) {Object {t: 2}} ，其中 {t: 2} ，则证明被修改了\n  console.log(array); // [{t: 2}]\n  // 删 （两者也同样通过forEach先找到，再删除）\n  set.forEach(item => item.t ? set.delete(item) : '');\n  let index = array.findIndex(item => item.t);\n\n  array.splice(index, 1);\n  console.log(set); // Set(0) {}\n  console.log(array); // []\n}  \n```\n\n### Map与object对比\n```javascript\n// Map、Set与object对比，增删改查\n{\n  let item = {t: 1};\n  let map = new Map();\n  let set = new Set();\n  let obj = {};\n\n  // 增\n  map.set('t', 1);\n  set.add(item);\n  obj['t'] = 1;\n  console.info({\n    map, // map: Map(1) {\"t\" => 1}\n    set, // set: Set(1) {Object {t: 1}}\n    obj // obj: {t: 1}\n  })\n  // 查\n  console.info({\n    map_exist: map.has('t'), // map_exist: true\n    set_exist: set.has(item), // obj_exist: true\n    obj_exist: 't' in obj // set_exist: true\n  })\n\n  set.forEach(item => {\n    item.t && console.log(item);\n  })\n  // 改\n  map.set('t', 2); // 覆盖了原来的值\n  set.forEach(item => item.t && (item.t = 2));\n  obj['t'] = 2;\n  console.info({\n    map, // map: Map(1) {\"t\" => 2}\n    set, // set: Set(1) {Object {t: 2}}\n    obj // obj: {t: 2}\n  })\n  // 删\n  map.delete('t');\n  set.delete(item); \n  // 或 set.forEach(item => item.t && (set.delete(item)));\n  delete obj['t'];\n  console.info({\n    map, // map: Map(0) {}\n    set, // set: Set(0) {}\n    obj // obj: {} \n  })\n}\n```\n总结：\n1. 能使用Map，不使用数组，里面越复杂，越适合使用Map\n2. 要求数据存储的唯一性，则使用Set\n3. 优先使用Map，放弃使用Array和Object","slug":"ES6梳理-数据结构对比","published":1,"updated":"2020-01-20T07:45:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghs000tlktvip6vixz1"},{"title":"ES6梳理-数组扩展","date":"2019-07-08T02:48:33.000Z","_content":"\n## 数组扩展\n<!-- more -->\n### 常用方法\n+ Array.of()把一组数据组合成一个数组\n```javascript\n{\n  let arr = Array.of(3, 4, 7, 9, 11);\n  console.log(arr) // 数组扩展\n\n  // 如哦Array.of()中不传任何参数,那么返回一个空数组\n  let arr2 = Array.of();\n  console.log(arr2)  // []\n} \n```\n+ Array.from(),此方法不会改变原来的数组\n  - 只写一个参数（对象），把一个伪数组转化成一个真正的数组\n```javascript\n{ \n  let p = document.getElementsByTagName('p');\n  \n  let pArr = Array.from(p)\n  console.log(p);\n  console.log(pArr);\n}\n```\n{% asset_img Array.from().png Array.from()把一个伪数组转化成一个真正的数组 %}\n - 第一个参数是数组，第二个参数是函数(这个函数起了一个map的作用，对前面的数组的每一个数组项都做了处理)\n```javascript\n// 只对数组项为数字活数字字符串生效，不然就处理为NaN\n{\n  console.log(Array.from([1, 3, 5], function (item) { return item*2 }));\n  // (3) [2, 6, 10]\n  console.log(Array.from([1, 3, '5'], function (item) { return item*2 }));\n  // (3) [2, 6, 10]\n  console.log(Array.from([1, { a: 2 }, 'fasf'], function (item) { return item*2 }));\n  // (3) [2, NaN, NaN]\n}\n```\n+ 数组对象.fill()\n - 只有第一个参数，把数组中的每一个值都替换为目标值，此方法会改变原来的数组\n```javascript\n{\n  let arr = [1, 'masia0', { a: 0 }];\n  let newArr = arr.fill(7);\n  console.log(arr); // (3) [7, 7, 7]\n  console.log(newArr); // (3) [7, 7, 7]\n}\n```\n - 有三个参数， 第一个参数为目标值，第二个参数是其实位置下标，第三个位置是结束位置下标，\n```javascript\n{\n  let arr = [1, 'masia0', { a: 0 }, 33, 55];\n  let newArr = arr.fill(7, 1, 3); // 替换index为0（包含0）到index为2（包含2）位置上的值\n  console.log(arr); // [1, 7, 7, 33, 55]\n  console.log(newArr); // [1, 7, 7, 33, 55]\n}\n```\n+ 数组的keys(), values(), entyies()\n```javascript\n{\n  let arr = [1, 'masia0', { a: 0 }, 33, 55];\n  console.log(arr.keys()); // Array Iterator {} 返回了一个数组迭代对象\n  console.log(arr.values()); // Array Iterator {}\n  // 这两个迭代对象可以使用for in取出来\n  for (let index of arr.keys()) {\n    console.log('key', index);\n    /*\n      key 0\n      key 1\n      key 2\n      key 3\n      key 4\n    */\n  }\n  for (let value of arr.values()) {\n    console.log('value', value);\n    /*\n      value 1\n      value masia0\n      value {a: 0}\n      value 33\n      value 55\n    */\n  }\n  for (let [index, value] of arr.entries()) {\n    console.log(index, value);\n    /*\n      0 1\n      1 \"masia0\"\n      2 Object\n      3 33\n      4 55\n    */\n  }\n}\n```\n+ copyWithin()在当前数组内部，把指定位置上的成员复制到其他位置上(会改变原来的数组)\n```javascript\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let newArr = arr.copyWithin(0, 2, 5)\n  // 从0位置开始替换，读取的数据从位置2开始（包含2位置）到4位置（包含4位置）\n  console.log(arr); // [3, 4, 5, 4, 5, 6]\n  console.log(newArr); // [3, 4, 5, 4, 5, 6]\n}\n```\n+ find()和findIndex()，检查数组中是否包含满足某个条件的值，find()返回该值，findIndex()返回该值的数组下标\n```javascript\n{\n  let arr =  [1, 2, 3, 4, 5, 6];\n  console.log(arr.find(function (item) { return item > 3 })); \n  // 返回数组中第一个满足条件的值 4\n  console.log(arr.findIndex(function (item) { return item > 3 })); \n  // 返回数组中第一个满足条件的值的下标 3\n  console.log(arr); // [1, 2, 3, 4, 5, 6] 不会改变原数组的值\n}\n```\n+ includes(),检查数组中是否包含具体的某个值\n比find和findIndex更省事，而且还解决了NaN的问题\n```javascript\n{\n  const obj = { a: 1 };\n  let arr =  [1, 2, 3, 4, 5, 6, NaN, 'masia', obj];\n  console.log(arr.includes(1)); // true\n  console.log(arr.includes('masia')); // true\n  console.log(arr.includes(NaN)); // true\n  console.log(arr.includes(obj)); // true\n  console.log(arr.includes(15)); // false\n}\n```\n### 复习常用的数组方法\n1. ArrayObj.forEach(),第一个参数是数组项本身，第二个参数为数组项下标\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  arr.forEach(function (item, index) {\n    console.log(index, item);\n    /*\n      0 1\n      1 2\n      2 3\n      3 4\n    */\n  })\n}\n```\n2. ArrayObj.map()对每一项值位数字的数组项做一个遍历操作，并不会改变原数组  \n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let newArr = arr.map(function (item) {\n    return item*2;\n  })\n  console.log(arr); //  [1, 2, 3, 4, \"5\", \"masia\", {…}]\n  console.log(newArr); // [2, 4, 6, 8, 10, NaN, NaN]  可以看出对值为数字的字符串仍然适用\n}\n```\n3. ArrayObj.filter()\n此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let newArr = arr.filter(function (item) {\n    return item > 2;\n  })\n  console.log(arr); //  [1, 2, 3, 4, \"5\", \"masia\", {…}]\n  console.log(newArr); // [3, 4, \"5\"] 可以看出对值为数字的字符串仍然适用\n  let newArr2 = arr.filter(function (item) {\n    return item == 2;\n  })\n  console.log(newArr2);  // [2] 不管有多少个满足条件的数组项，返回的值一定是一个数组\n  let newArr3 = arr.filter(function (item) {\n    return item == 0;\n  })\n  console.log(newArr3);  // [] 不管有多少个满足条件的数组项，返回的值一定是一个数组\n}\n```\n4. ArrayObj.every()\n此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回true，否则为false。\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let flag = arr.every(function (item) {\n    return item > 0;\n  })\n  console.log(flag); // false\n  console.log(arr); // [1, 2, 3, 4, \"5\", \"masia\", {…}] 不会改变原数组\n  let arr2 = [1, 2, 3, 4];\n  let flag2 = arr2.every(function (item) {\n    return item > 0;\n  })\n  console.log(flag2); // true\n}\n```\n5. ArrayObj.some()\n此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false。\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let flag = arr.some(function (item) {\n    return item > 0;\n  })\n  console.log(flag); // true\n  console.log(arr); // [1, 2, 3, 4, \"5\", \"masia\", {…}] 不会改变原数组\n  let arr2 = [1, 2, 3, 4];\n  let flag2 = arr2.some(function (item) {\n    return item < 0;\n  })\n  console.log(flag2); // false\n}\n```\n6. ArrayObj.reduce()\n此方法是所有元素调用传入的回调函数，返回值为最后结果\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let res = arr.reduce(function (a, b) {\n    console.log(a, b)\n    return a + b;\n  })\n  console.log(res); \n  console.log(arr); \n  let arr2 = [1, 2, 3, 4];\n  let res2 = arr2.reduce(function (a, b) {\n    console.log(a, b)\n    return a + b;\n  })\n  console.log(res2); \n}\n```\n{% asset_img ArrayObj.reduce().png ArrayObj.reduce() %}\n\n7. ArrayObj.push()\n此方法是在数组的后面添加新加元素，此方法改变了原数组，返回值为修改过后的数组的长度\n```javascript\n{\n  let arr = [1, 2, 3];\n  let res = arr.push(4);\n  console.log(arr); // [1, 2, 3, 4]\n  console.log(res); // 4 返回值为修改过后的数组的长度\n  let res2 = arr.push(5, 6);\n  console.log(arr); // [1, 2, 3, 4, 5, 6]\n  console.log(res2); // 6 返回值为修改过后的数组的长度\n}\n```\n8. ArrayObj.pop()\n此方法删除了数组的最后一个元素，改变了原数组，返回值为删除的数组项的值\n```javascript\n{\n  let arr = [1, 2, 6];\n  let res = arr.pop(); // pop()没有参数，传参数没用\n  console.log(arr); // [1, 2]\n  console.log(res); // 6 返回值为删除的数组项的值\n}\n```\n9. ArrayObj.shift()\n此方法删除了数组的第一个元素，改变了原数组，返回值为删除的数组项的值\n```javascript\n{\n  let arr = [99, 2, 6];\n  let res = arr.shift(); // shift()没有参数，传参数没用\n  console.log(arr); // [2, 6]\n  console.log(res); // 99 返回值为删除的数组项的值\n}\n```\n10. ArrayObj.unshift()\n此方法是将一个或多个元素插入到数组的开头，改变了原数组，返回值为修改后的数组长度\n```javascript\n{\n  let arr = [99, 2, 6];\n  let res = arr.unshift(1, 2); \n  console.log(arr); // [1, 2, 99, 2, 6]\n  console.log(res); // 5 返回值为修改后的数组长度\n}\n```\n11. ArrayObj.concat()\n此方法是一个可以将多个数组拼接成一个数组，返回值为合并后的新数组，此方法不会改变原来的数组\n```javascript\n{\n  let arr = [1, 1, 1];\n  let arr2 = [2, 2, 2];\n  let arr3 = [3, 3, 3];\n  let newArr = arr.concat(arr2, arr3).concat(arr3);\n  // 或者 let newArr = arr.concat(arr2).concat(arr3);\n  console.log(newArr); // [1, 1, 1, 2, 2, 2, 3, 3, 3]\n  console.log(arr); // [1, 1, 1] 此方法不会改变原来的数组\n  console.log(arr2); // [2, 2, 2] 此方法不会改变原来的数组\n  console.log(arr3); // [3, 3, 3] 此方法不会改变原来的数组\n}\n```\n12. ArrayObj.toString()\n此方法将数组转化为字符串，不会改变原数组\n```javascript\n{\n  let arr = [1, 1, 1];\n  let str = arr.toString();\n  console.log(str); // 1,1,1\n  console.log(arr); // [1, 1, 1]\n}\n```\n13. ArrayObj.join()\n此方法将数组转化为字符串，与toString()的区别是，join('#')可以设置元素之间的间隔\n此方法与StringObj.split()方法正好相反\n```javascript\n{\n  let arr = [1, 1, 1];\n  let str = arr.join(); // 不加参数，返回的结果个toString()一样\n  let str2 = arr.join(''); // 加参数空\n  let str3 = arr.join('##'); // 加参数##\n  console.log(str); // 1,1,1\n  console.log(str2); // 111\n  console.log(str3); // 1##1##1\n  console.log(arr); // [1, 1, 1] 不改变原数组\n}\n```\n14. ArrayObj.splice(开始位置， 删除的个数，元素)\n万能方法，可以实现增删改，会改变原数组，返回删除元素组成的数组\n```javascript\n// 删除一组数组项\n{\n  let arr = [1, 2, 3, 4, 5];\n  let arr1 = arr.splice(2, 3)\n  console.log('arr', arr) // [1, 2]\n  console.log('arr1', arr1) // [3, 4, 5]\n}\n// 删除一组数组项，并且在原数组删除的位置开始添加一组元素\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let arr1 = arr.splice(2, 3, 'haha', 'lala')\n  console.log('arr', arr) // [1, 2, \"haha\", \"lala\", 6]\n  console.log('arr1', arr1) // [3, 4, 5]\n}\n// 实现指定位置数组元素替换\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let arr1 = arr.splice(2, 1, 'haha')\n  console.log('arr', arr) // 1, 2, \"haha\", 4, 5, 6]\n  console.log('arr1', arr1) // [3]\n}\n// 实现指定位置插入一个元素\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let arr1 = arr.splice(2, 0, 'haha')\n  console.log('arr', arr) // [1, 2, \"haha\", 3, 4, 5, 6]\n  console.log('arr1', arr1) // []\n}\n```\n15. Array.isArray()\n判断一个对象是不是数组，返回的是布尔值\n```javascript\n{\n  let arr = [99, 2, 6];\n  let res = Array.isArray(arr);\n  console.log(res); // true\n}\n```\n### 附加\n+ 把一个一维数组转为二维数组\n```javascript\n{\n  arr = [1, 1, 1, 2, 2, 2, 3, 3];\n  function twoDimensionalArray (n) {\n    let newArr = [];\n    let sArr = [];\n    arr.forEach(function (item) {\n      if (sArr.length == n) { // 如果小数组满了，就让他指向一片新的空间\n        sArr = [];\n      }\n      if (sArr.length == 0) { // 如果小数组为空，就把他添加到大数组中\n        newArr.push(sArr);\n      }\n      sArr.push(item);\n    })\n    return newArr;\n  }\n  console.log(twoDimensionalArray(3)); // (3) [Array(3), Array(3), Array(2)]\n}\n```","source":"_posts/ES6梳理-数组扩展.md","raw":"---\ntitle: ES6梳理-数组扩展\ndate: 2019-07-08 10:48:33\ncategories:\n  - ES6\n  - 数组扩展\ntags:\n  - ES6\n  - 数组扩展\n---\n\n## 数组扩展\n<!-- more -->\n### 常用方法\n+ Array.of()把一组数据组合成一个数组\n```javascript\n{\n  let arr = Array.of(3, 4, 7, 9, 11);\n  console.log(arr) // 数组扩展\n\n  // 如哦Array.of()中不传任何参数,那么返回一个空数组\n  let arr2 = Array.of();\n  console.log(arr2)  // []\n} \n```\n+ Array.from(),此方法不会改变原来的数组\n  - 只写一个参数（对象），把一个伪数组转化成一个真正的数组\n```javascript\n{ \n  let p = document.getElementsByTagName('p');\n  \n  let pArr = Array.from(p)\n  console.log(p);\n  console.log(pArr);\n}\n```\n{% asset_img Array.from().png Array.from()把一个伪数组转化成一个真正的数组 %}\n - 第一个参数是数组，第二个参数是函数(这个函数起了一个map的作用，对前面的数组的每一个数组项都做了处理)\n```javascript\n// 只对数组项为数字活数字字符串生效，不然就处理为NaN\n{\n  console.log(Array.from([1, 3, 5], function (item) { return item*2 }));\n  // (3) [2, 6, 10]\n  console.log(Array.from([1, 3, '5'], function (item) { return item*2 }));\n  // (3) [2, 6, 10]\n  console.log(Array.from([1, { a: 2 }, 'fasf'], function (item) { return item*2 }));\n  // (3) [2, NaN, NaN]\n}\n```\n+ 数组对象.fill()\n - 只有第一个参数，把数组中的每一个值都替换为目标值，此方法会改变原来的数组\n```javascript\n{\n  let arr = [1, 'masia0', { a: 0 }];\n  let newArr = arr.fill(7);\n  console.log(arr); // (3) [7, 7, 7]\n  console.log(newArr); // (3) [7, 7, 7]\n}\n```\n - 有三个参数， 第一个参数为目标值，第二个参数是其实位置下标，第三个位置是结束位置下标，\n```javascript\n{\n  let arr = [1, 'masia0', { a: 0 }, 33, 55];\n  let newArr = arr.fill(7, 1, 3); // 替换index为0（包含0）到index为2（包含2）位置上的值\n  console.log(arr); // [1, 7, 7, 33, 55]\n  console.log(newArr); // [1, 7, 7, 33, 55]\n}\n```\n+ 数组的keys(), values(), entyies()\n```javascript\n{\n  let arr = [1, 'masia0', { a: 0 }, 33, 55];\n  console.log(arr.keys()); // Array Iterator {} 返回了一个数组迭代对象\n  console.log(arr.values()); // Array Iterator {}\n  // 这两个迭代对象可以使用for in取出来\n  for (let index of arr.keys()) {\n    console.log('key', index);\n    /*\n      key 0\n      key 1\n      key 2\n      key 3\n      key 4\n    */\n  }\n  for (let value of arr.values()) {\n    console.log('value', value);\n    /*\n      value 1\n      value masia0\n      value {a: 0}\n      value 33\n      value 55\n    */\n  }\n  for (let [index, value] of arr.entries()) {\n    console.log(index, value);\n    /*\n      0 1\n      1 \"masia0\"\n      2 Object\n      3 33\n      4 55\n    */\n  }\n}\n```\n+ copyWithin()在当前数组内部，把指定位置上的成员复制到其他位置上(会改变原来的数组)\n```javascript\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let newArr = arr.copyWithin(0, 2, 5)\n  // 从0位置开始替换，读取的数据从位置2开始（包含2位置）到4位置（包含4位置）\n  console.log(arr); // [3, 4, 5, 4, 5, 6]\n  console.log(newArr); // [3, 4, 5, 4, 5, 6]\n}\n```\n+ find()和findIndex()，检查数组中是否包含满足某个条件的值，find()返回该值，findIndex()返回该值的数组下标\n```javascript\n{\n  let arr =  [1, 2, 3, 4, 5, 6];\n  console.log(arr.find(function (item) { return item > 3 })); \n  // 返回数组中第一个满足条件的值 4\n  console.log(arr.findIndex(function (item) { return item > 3 })); \n  // 返回数组中第一个满足条件的值的下标 3\n  console.log(arr); // [1, 2, 3, 4, 5, 6] 不会改变原数组的值\n}\n```\n+ includes(),检查数组中是否包含具体的某个值\n比find和findIndex更省事，而且还解决了NaN的问题\n```javascript\n{\n  const obj = { a: 1 };\n  let arr =  [1, 2, 3, 4, 5, 6, NaN, 'masia', obj];\n  console.log(arr.includes(1)); // true\n  console.log(arr.includes('masia')); // true\n  console.log(arr.includes(NaN)); // true\n  console.log(arr.includes(obj)); // true\n  console.log(arr.includes(15)); // false\n}\n```\n### 复习常用的数组方法\n1. ArrayObj.forEach(),第一个参数是数组项本身，第二个参数为数组项下标\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  arr.forEach(function (item, index) {\n    console.log(index, item);\n    /*\n      0 1\n      1 2\n      2 3\n      3 4\n    */\n  })\n}\n```\n2. ArrayObj.map()对每一项值位数字的数组项做一个遍历操作，并不会改变原数组  \n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let newArr = arr.map(function (item) {\n    return item*2;\n  })\n  console.log(arr); //  [1, 2, 3, 4, \"5\", \"masia\", {…}]\n  console.log(newArr); // [2, 4, 6, 8, 10, NaN, NaN]  可以看出对值为数字的字符串仍然适用\n}\n```\n3. ArrayObj.filter()\n此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let newArr = arr.filter(function (item) {\n    return item > 2;\n  })\n  console.log(arr); //  [1, 2, 3, 4, \"5\", \"masia\", {…}]\n  console.log(newArr); // [3, 4, \"5\"] 可以看出对值为数字的字符串仍然适用\n  let newArr2 = arr.filter(function (item) {\n    return item == 2;\n  })\n  console.log(newArr2);  // [2] 不管有多少个满足条件的数组项，返回的值一定是一个数组\n  let newArr3 = arr.filter(function (item) {\n    return item == 0;\n  })\n  console.log(newArr3);  // [] 不管有多少个满足条件的数组项，返回的值一定是一个数组\n}\n```\n4. ArrayObj.every()\n此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回true，否则为false。\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let flag = arr.every(function (item) {\n    return item > 0;\n  })\n  console.log(flag); // false\n  console.log(arr); // [1, 2, 3, 4, \"5\", \"masia\", {…}] 不会改变原数组\n  let arr2 = [1, 2, 3, 4];\n  let flag2 = arr2.every(function (item) {\n    return item > 0;\n  })\n  console.log(flag2); // true\n}\n```\n5. ArrayObj.some()\n此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false。\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let flag = arr.some(function (item) {\n    return item > 0;\n  })\n  console.log(flag); // true\n  console.log(arr); // [1, 2, 3, 4, \"5\", \"masia\", {…}] 不会改变原数组\n  let arr2 = [1, 2, 3, 4];\n  let flag2 = arr2.some(function (item) {\n    return item < 0;\n  })\n  console.log(flag2); // false\n}\n```\n6. ArrayObj.reduce()\n此方法是所有元素调用传入的回调函数，返回值为最后结果\n```javascript\n{\n  let arr = [1, 2, 3, 4, '5', 'masia', {}];\n  let res = arr.reduce(function (a, b) {\n    console.log(a, b)\n    return a + b;\n  })\n  console.log(res); \n  console.log(arr); \n  let arr2 = [1, 2, 3, 4];\n  let res2 = arr2.reduce(function (a, b) {\n    console.log(a, b)\n    return a + b;\n  })\n  console.log(res2); \n}\n```\n{% asset_img ArrayObj.reduce().png ArrayObj.reduce() %}\n\n7. ArrayObj.push()\n此方法是在数组的后面添加新加元素，此方法改变了原数组，返回值为修改过后的数组的长度\n```javascript\n{\n  let arr = [1, 2, 3];\n  let res = arr.push(4);\n  console.log(arr); // [1, 2, 3, 4]\n  console.log(res); // 4 返回值为修改过后的数组的长度\n  let res2 = arr.push(5, 6);\n  console.log(arr); // [1, 2, 3, 4, 5, 6]\n  console.log(res2); // 6 返回值为修改过后的数组的长度\n}\n```\n8. ArrayObj.pop()\n此方法删除了数组的最后一个元素，改变了原数组，返回值为删除的数组项的值\n```javascript\n{\n  let arr = [1, 2, 6];\n  let res = arr.pop(); // pop()没有参数，传参数没用\n  console.log(arr); // [1, 2]\n  console.log(res); // 6 返回值为删除的数组项的值\n}\n```\n9. ArrayObj.shift()\n此方法删除了数组的第一个元素，改变了原数组，返回值为删除的数组项的值\n```javascript\n{\n  let arr = [99, 2, 6];\n  let res = arr.shift(); // shift()没有参数，传参数没用\n  console.log(arr); // [2, 6]\n  console.log(res); // 99 返回值为删除的数组项的值\n}\n```\n10. ArrayObj.unshift()\n此方法是将一个或多个元素插入到数组的开头，改变了原数组，返回值为修改后的数组长度\n```javascript\n{\n  let arr = [99, 2, 6];\n  let res = arr.unshift(1, 2); \n  console.log(arr); // [1, 2, 99, 2, 6]\n  console.log(res); // 5 返回值为修改后的数组长度\n}\n```\n11. ArrayObj.concat()\n此方法是一个可以将多个数组拼接成一个数组，返回值为合并后的新数组，此方法不会改变原来的数组\n```javascript\n{\n  let arr = [1, 1, 1];\n  let arr2 = [2, 2, 2];\n  let arr3 = [3, 3, 3];\n  let newArr = arr.concat(arr2, arr3).concat(arr3);\n  // 或者 let newArr = arr.concat(arr2).concat(arr3);\n  console.log(newArr); // [1, 1, 1, 2, 2, 2, 3, 3, 3]\n  console.log(arr); // [1, 1, 1] 此方法不会改变原来的数组\n  console.log(arr2); // [2, 2, 2] 此方法不会改变原来的数组\n  console.log(arr3); // [3, 3, 3] 此方法不会改变原来的数组\n}\n```\n12. ArrayObj.toString()\n此方法将数组转化为字符串，不会改变原数组\n```javascript\n{\n  let arr = [1, 1, 1];\n  let str = arr.toString();\n  console.log(str); // 1,1,1\n  console.log(arr); // [1, 1, 1]\n}\n```\n13. ArrayObj.join()\n此方法将数组转化为字符串，与toString()的区别是，join('#')可以设置元素之间的间隔\n此方法与StringObj.split()方法正好相反\n```javascript\n{\n  let arr = [1, 1, 1];\n  let str = arr.join(); // 不加参数，返回的结果个toString()一样\n  let str2 = arr.join(''); // 加参数空\n  let str3 = arr.join('##'); // 加参数##\n  console.log(str); // 1,1,1\n  console.log(str2); // 111\n  console.log(str3); // 1##1##1\n  console.log(arr); // [1, 1, 1] 不改变原数组\n}\n```\n14. ArrayObj.splice(开始位置， 删除的个数，元素)\n万能方法，可以实现增删改，会改变原数组，返回删除元素组成的数组\n```javascript\n// 删除一组数组项\n{\n  let arr = [1, 2, 3, 4, 5];\n  let arr1 = arr.splice(2, 3)\n  console.log('arr', arr) // [1, 2]\n  console.log('arr1', arr1) // [3, 4, 5]\n}\n// 删除一组数组项，并且在原数组删除的位置开始添加一组元素\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let arr1 = arr.splice(2, 3, 'haha', 'lala')\n  console.log('arr', arr) // [1, 2, \"haha\", \"lala\", 6]\n  console.log('arr1', arr1) // [3, 4, 5]\n}\n// 实现指定位置数组元素替换\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let arr1 = arr.splice(2, 1, 'haha')\n  console.log('arr', arr) // 1, 2, \"haha\", 4, 5, 6]\n  console.log('arr1', arr1) // [3]\n}\n// 实现指定位置插入一个元素\n{\n  let arr = [1, 2, 3, 4, 5, 6];\n  let arr1 = arr.splice(2, 0, 'haha')\n  console.log('arr', arr) // [1, 2, \"haha\", 3, 4, 5, 6]\n  console.log('arr1', arr1) // []\n}\n```\n15. Array.isArray()\n判断一个对象是不是数组，返回的是布尔值\n```javascript\n{\n  let arr = [99, 2, 6];\n  let res = Array.isArray(arr);\n  console.log(res); // true\n}\n```\n### 附加\n+ 把一个一维数组转为二维数组\n```javascript\n{\n  arr = [1, 1, 1, 2, 2, 2, 3, 3];\n  function twoDimensionalArray (n) {\n    let newArr = [];\n    let sArr = [];\n    arr.forEach(function (item) {\n      if (sArr.length == n) { // 如果小数组满了，就让他指向一片新的空间\n        sArr = [];\n      }\n      if (sArr.length == 0) { // 如果小数组为空，就把他添加到大数组中\n        newArr.push(sArr);\n      }\n      sArr.push(item);\n    })\n    return newArr;\n  }\n  console.log(twoDimensionalArray(3)); // (3) [Array(3), Array(3), Array(2)]\n}\n```","slug":"ES6梳理-数组扩展","published":1,"updated":"2020-01-20T07:45:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ght000xlktv2zcbbedp"},{"title":"ES6梳理-模块化","date":"2019-07-11T02:48:33.000Z","_content":"\n# 模块化\n<!-- more -->\n+ 批量导出\n文件A.js中\n```javascript\nexport let A = 123;\nexport function test () {\n  console.log('test');\n}\nexport class Hello {\n  test () {\n    console.log('test');\n  }\n}\n```\n按需导入：文件A中的变量导入文件B.js中\n```javascript\nimport {A, test, Hello} from './A.js'\nconsole.log(A);\ntest();\n```\n全部导入：文件A中的变量导入文件c.js中\n```javascript\nimport * as A form './A.js'\nconsole.log(A.A);\nA.test();\n```\n","source":"_posts/ES6梳理-模块化.md","raw":"---\ntitle: ES6梳理-模块化\ndate: 2019-07-11 10:48:33\ncategories:\n  - ES6\n  - 模块化\ntags:\n  - ES6\n  - 模块化\n---\n\n# 模块化\n<!-- more -->\n+ 批量导出\n文件A.js中\n```javascript\nexport let A = 123;\nexport function test () {\n  console.log('test');\n}\nexport class Hello {\n  test () {\n    console.log('test');\n  }\n}\n```\n按需导入：文件A中的变量导入文件B.js中\n```javascript\nimport {A, test, Hello} from './A.js'\nconsole.log(A);\ntest();\n```\n全部导入：文件A中的变量导入文件c.js中\n```javascript\nimport * as A form './A.js'\nconsole.log(A.A);\nA.test();\n```\n","slug":"ES6梳理-模块化","published":1,"updated":"2020-01-20T07:45:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghu000ylktvd82jtisy"},{"title":"ES6梳理-正则扩展","abbrlink":"13f9823b","date":"2019-04-29T06:00:00.000Z","_content":"\n# 正则扩展\n1. 正则对象\nES5中的正则对象\n<!-- more -->\n```javascript\n{\n  // 第一种写法： 第一个参数是字符串，第二个参数是修饰符\n  let regex = new RegExp('xyz', 'i'); // 第二个参数i是忽略大小写的意思\n  // 第二种写法：只有一个参数：正则表达式\n  let regex2 = new RegExp(/xyz/i);\n  // 当然还可以使用字面量的方式去定义一个正则对象 let regex2 = /xyz/i;\n  console.log(regex.flags) // flags是ES6新增加的一个获取正则对象修饰符的属性，输出正则对象的修饰符\n  console.log(regex2.flags) // 输出正则表达式的修饰符\n  console.log(regex.test('xyz123'), regex2.test('xyz123'))\n  // 输出： true true\n}\n```\nES6中增加了一种写法：\n```javascript\n// 第一个参数是正则表达式，还能有第二个参数\n// ES6允许第一个参数是正则表达式，也允许第二个参数去覆盖正则表达式的修饰符\nlet regex3 = new RegExp(/xyz/ig, 'i');\nconsole.log(regex3.flags) // 输出 'i'\n```\n2. 修饰符\nES5中常见的修饰符是`i`和`g`,ES6增加了`y`和`u`\n+ `y`修饰符\n```javascript\n{\n  let s = 'bbb_bb_b';\n  let a1 = /b+/g;\n  let a2 = /b+/y;\n  console.log('one', a1.exec(s), a2.exec(s)); // 第一次执行\n  // 输出：都匹配到了第一个字符'bbb'\n  // [\"bbb\", index: 0, input: \"bbb_bb_b\", groups: undefined] \n  // [\"bbb\", index: 0, input: \"bbb_bb_b\", groups: undefined]\n  console.log('two', a1.exec(s), a2.exec(s)); // 第二次执行\n  // 输出：使用g修饰符的匹配到了 'bb', 使用y修饰符的没有匹配到，并且返回了null，即没有匹配成功\n  // [\"bb\", index: 4, input: \"bbb_bb_b\", groups: undefined]\n  // null\n  console.log('three', a1.exec(s), a2.exec(s)); // 第三次执行\n  // 输出：使用g修饰符的匹配到了 'b', 使用y修饰符的输出结果和第一次相同\n  //[\"b\", index: 7, input: \"bbb_bb_b\", groups: undefined]\n  //[\"bbb\", index: 0, input: \"bbb_bb_b\", groups: undefined]\n\n\n  // ES6中的sticky属性, sticky 黏(性)的;一面带黏胶的;闷热的\n  console.log(a1.sticky, a2.sticky) // 来判断正则对象是否开启了带y的修饰符的作用\n  //          false      true\n}\n```\n+ `u`修饰符\nu其实是unicode的缩写\n```javascript\n{\n  console.log('u-1', /^\\uD830/.test('\\uD830\\DC2A')); // true\n                              // 不加u会把后面的内容当两个字符去解析\n  console.log('u-2', /^\\uD830/u.test('\\uD830\\DC2A')); // false\n                            //加u会把后面test中的一连串内容当作一个字符去解析\n\n\n  console.log(/\\u{61}/.test('a'));\n  console.log(/\\u{61}/u.test('a')); // 如果{}内放的是unicode编码，且你要识别unicode编码，则一定要加u\n}\n```\n在unicode中，一个编码组合为两个字节，表示一个字符\n+ 小知识点\n在ES5中,`.`代表任意一个字符，但是其实他只能匹配两个字节的字符 \n```javascript\n{\n  console.log(`\\u{20BB7}`) // \"𠮷\"\n              // unicode的编码超过了4位，那也就意味着这个字符的大小超过了2字节\n  let s = '𠮷';\n  console.log(/^.$/.test(s)) // false, 说明\".\"并没有成功匹配到\"𠮷\"这个字符，那也就验证了\".\"只能匹配2字节的unicode字符\n  console.log(/^.$/u.test(s)) // true, 但是加上正则表达式修饰符\"u\",\".\"就可以匹配这个超过4位的unicode字符了\n}\n{\n  console.log(/𠮷{2}/.test('𠮷𠮷')) // false ,不加u修饰符，识别不了超过2字节的字符\n  console.log(/𠮷{2}/u.test('𠮷𠮷')) // true ,加了u修饰符，能够识别超过2字节的字符\n}\n\n// 总结：\".\"只能匹配2字节的unicode字符，如果我们要匹配的字符串中有超过2字节的unicode字符，请加u\n```\n","source":"_posts/ES6梳理-正则扩展.md","raw":"---\ntitle: ES6梳理-正则扩展\ncategories:\n  - ES6\n  - 正则扩展\ntags:\n  - ES6\n  - 正则扩展\nabbrlink: 13f9823b\ndate: 2019-04-29 14:00:00\n---\n\n# 正则扩展\n1. 正则对象\nES5中的正则对象\n<!-- more -->\n```javascript\n{\n  // 第一种写法： 第一个参数是字符串，第二个参数是修饰符\n  let regex = new RegExp('xyz', 'i'); // 第二个参数i是忽略大小写的意思\n  // 第二种写法：只有一个参数：正则表达式\n  let regex2 = new RegExp(/xyz/i);\n  // 当然还可以使用字面量的方式去定义一个正则对象 let regex2 = /xyz/i;\n  console.log(regex.flags) // flags是ES6新增加的一个获取正则对象修饰符的属性，输出正则对象的修饰符\n  console.log(regex2.flags) // 输出正则表达式的修饰符\n  console.log(regex.test('xyz123'), regex2.test('xyz123'))\n  // 输出： true true\n}\n```\nES6中增加了一种写法：\n```javascript\n// 第一个参数是正则表达式，还能有第二个参数\n// ES6允许第一个参数是正则表达式，也允许第二个参数去覆盖正则表达式的修饰符\nlet regex3 = new RegExp(/xyz/ig, 'i');\nconsole.log(regex3.flags) // 输出 'i'\n```\n2. 修饰符\nES5中常见的修饰符是`i`和`g`,ES6增加了`y`和`u`\n+ `y`修饰符\n```javascript\n{\n  let s = 'bbb_bb_b';\n  let a1 = /b+/g;\n  let a2 = /b+/y;\n  console.log('one', a1.exec(s), a2.exec(s)); // 第一次执行\n  // 输出：都匹配到了第一个字符'bbb'\n  // [\"bbb\", index: 0, input: \"bbb_bb_b\", groups: undefined] \n  // [\"bbb\", index: 0, input: \"bbb_bb_b\", groups: undefined]\n  console.log('two', a1.exec(s), a2.exec(s)); // 第二次执行\n  // 输出：使用g修饰符的匹配到了 'bb', 使用y修饰符的没有匹配到，并且返回了null，即没有匹配成功\n  // [\"bb\", index: 4, input: \"bbb_bb_b\", groups: undefined]\n  // null\n  console.log('three', a1.exec(s), a2.exec(s)); // 第三次执行\n  // 输出：使用g修饰符的匹配到了 'b', 使用y修饰符的输出结果和第一次相同\n  //[\"b\", index: 7, input: \"bbb_bb_b\", groups: undefined]\n  //[\"bbb\", index: 0, input: \"bbb_bb_b\", groups: undefined]\n\n\n  // ES6中的sticky属性, sticky 黏(性)的;一面带黏胶的;闷热的\n  console.log(a1.sticky, a2.sticky) // 来判断正则对象是否开启了带y的修饰符的作用\n  //          false      true\n}\n```\n+ `u`修饰符\nu其实是unicode的缩写\n```javascript\n{\n  console.log('u-1', /^\\uD830/.test('\\uD830\\DC2A')); // true\n                              // 不加u会把后面的内容当两个字符去解析\n  console.log('u-2', /^\\uD830/u.test('\\uD830\\DC2A')); // false\n                            //加u会把后面test中的一连串内容当作一个字符去解析\n\n\n  console.log(/\\u{61}/.test('a'));\n  console.log(/\\u{61}/u.test('a')); // 如果{}内放的是unicode编码，且你要识别unicode编码，则一定要加u\n}\n```\n在unicode中，一个编码组合为两个字节，表示一个字符\n+ 小知识点\n在ES5中,`.`代表任意一个字符，但是其实他只能匹配两个字节的字符 \n```javascript\n{\n  console.log(`\\u{20BB7}`) // \"𠮷\"\n              // unicode的编码超过了4位，那也就意味着这个字符的大小超过了2字节\n  let s = '𠮷';\n  console.log(/^.$/.test(s)) // false, 说明\".\"并没有成功匹配到\"𠮷\"这个字符，那也就验证了\".\"只能匹配2字节的unicode字符\n  console.log(/^.$/u.test(s)) // true, 但是加上正则表达式修饰符\"u\",\".\"就可以匹配这个超过4位的unicode字符了\n}\n{\n  console.log(/𠮷{2}/.test('𠮷𠮷')) // false ,不加u修饰符，识别不了超过2字节的字符\n  console.log(/𠮷{2}/u.test('𠮷𠮷')) // true ,加了u修饰符，能够识别超过2字节的字符\n}\n\n// 总结：\".\"只能匹配2字节的unicode字符，如果我们要匹配的字符串中有超过2字节的unicode字符，请加u\n```\n","slug":"ES6梳理-正则扩展","published":1,"updated":"2020-01-20T07:45:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghv0011lktvv8cj14jq"},{"title":"ES6梳理-类","date":"2019-07-08T11:57:54.000Z","_content":"# 类\n+ 基本概念\n+ 基本语法\n+ 类的继承\n+ 静态方法\n+ 静态属性\n+ getter\n+ setter\n<!-- more -->\n### 基本使用\n```javascript\n// ES6继承\n{\n  class Animal {\n    constructor (name, age = 0) {\n                // 当然这里也可以使用形参赋值的方式\n      this.name = name;\n      this.age = age;\n    }\n    getName () {\n      console.log('Animal getName ' + this.name);\n    }\n  }\n  class Cat extends Animal {\n    constructor (name, age, voice) { \n      /* \n        在子类中要么不写构造方法，则使用子类创建对象时，会自动调用父类的构造方法 ，\n        如果在子类中写了构造方法，则在创建子类实例的时候执行该方法，（实质就是原型\n        链就近原则，js使用方法名来规定方法的唯一性，这点和java是不同的，java使用\n        方法签名，也就是方法名和参数列表来规定方法的唯一性）\n      */\n      super(name, age);\n      this.voice = voice;\n    }\n    getName () {\n      super.getName();\n      console.log('Cat getName ' + this.name));\n    }\n  }\n  const cat = new Cat('mimi', 12, 'miao');\n  console.log(cat); // Cat {name: \"mimi\", age: 12, voice: \"miao\"}\n  cat.getName(); // Animal getName\n                  // Cat getName\n} \n// ES5继承\n{\n  function Animal (name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  Object.assign(Animal.prototype, {\n    getName () {\n      console.log('Animal getName ' + this.name);\n    }\n  });\n  function Cat (name, age, voice) {\n    Animal.apply(this, [name, age]);\n    this.voice = voice;\n  }\n  Object.assign(Cat.prototype, {\n    getName () {\n      // 子类public方法调用父类方法\n      Cat.prototype.__proto__.getName.call(this); // 同样可以使用call()来改变方法内的this\n      console.log('Cat getName ' + this.name)\n    }\n  })\n  Cat.prototype.__proto__ = Animal.prototype;\n  const cat = new Cat('lili', 2, 'miao'); \n  console.log(cat); // Cat {name: \"lili\", age: 2, voice: \"miao\"}\n  cat.getName(); // Animal getName lili\n                  // Cat getName lili\n}\n```\n{% asset_img class_compare1.png 类的简单使用 %}\n{% asset_img class_compare2.png ES6类的继承 %}\n{% asset_img class_compare3.png ES5类的继承 %}\n\n### getter和setter\n```javascript\n{\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n\n    // 这里你不要理解为方法，这里是非方法属性，相当于vue中的计算属性\n    get longName () {\n      return 'mk' + this.name;\n    }\n\n    set longName (value) {\n      // 意为你给longName赋值，最终会给name属性赋值\n      this.name =  value\n    }\n  }\n  const ani = new Animal();\n  console.log(ani.name); // animal\n  console.log(ani.longName); // mkanimal\n  ani.longName = 'cat';\n  console.log(ani.name); // cat\n  console.log(ani.longName); // mkcat\n}\n```\n### 静态方法\n+ 使用关键字static，这点和java相同\n```javascript\n{\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n    static tell () {\n      console.log('this is a static method');\n    }\n    test () {\n      tell();\n    }\n  }\n  const ani = new Animal();\n  console.log(ani);\n  console.log(ani.name); // animal\n  Animal.tell(); // this is a static method\n\n  // js中的静态方法不能通过实例去调用，这主要与静态方法存放的位置有关，这点与java不同\n  ani.tell(); // Uncaught TypeError: ani.tell is not a function \n\n  // 当然也不能通过原型链上的其他方法去调用(这实质上也是通过实例在调用)\n  ani.test(); // Uncaught TypeError: ani.tell is not a function \n}\n```\n{% asset_img static1.png 静态方法%}\n+ 当然，也可以使用一些骚操作来实现实例对静态方法的调用，只要搞清楚静态方法存放的位置，就可以为所欲为\n```javascript\n{\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n    static tell () {\n      console.log('this is a static method');\n    }\n    static getThis () {\n      console.log(this)\n    }\n\n    test () {\n      tell();\n    }\n    test2 () {\n      Animal.tell();\n    }\n    test3 () {\n      Animal.getThis.call(this);\n    }\n  }\n  const ani = new Animal();\n  console.log(ani);\n  console.log(ani.name); // animal\n  Animal.tell(); // this is a static method\n  Animal.getThis();\n  /* 输出：\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n    static tell () {\n      console.log('this is a static method');\n    }\n    static getThis () {\n      console.log(this)\n   …\n  */\n\n  // js中的静态方法不能通过实例去调用，这主要与静态方法存放的位置有关，这点与java不同\n  ani.tell(); // Uncaught TypeError: ani.tell is not a function \n\n  // 当然也不能通过原型链上的其他方法去调用，因为在对象的原型链上找不到这个方法。\n  ani.test(); // Uncaught TypeError: ani.tell is not a function \n\n  // 但其实你非要通过实例中的方法间接使用，也可以\n  ani.test2(); // this is a static method\n\n  // 甚至通过call来改变this的指向（call太强大了）\n  ani.test3(); // Animal {name: \"animal\"}\n}\n```\n+ 如果要用ES5实现，就直接给类加属性就可以了，如：Animal.getThis = function () {}，甚至可以使用这种方法定义静态属性，但static只能用来定义静态方法","source":"_posts/ES6梳理-类.md","raw":"---\ntitle: ES6梳理-类\ndate: 2019-07-08 19:57:54\ntags:\n - ES6\n - 类\ncategories: \n - ES6\n - 类\n---\n# 类\n+ 基本概念\n+ 基本语法\n+ 类的继承\n+ 静态方法\n+ 静态属性\n+ getter\n+ setter\n<!-- more -->\n### 基本使用\n```javascript\n// ES6继承\n{\n  class Animal {\n    constructor (name, age = 0) {\n                // 当然这里也可以使用形参赋值的方式\n      this.name = name;\n      this.age = age;\n    }\n    getName () {\n      console.log('Animal getName ' + this.name);\n    }\n  }\n  class Cat extends Animal {\n    constructor (name, age, voice) { \n      /* \n        在子类中要么不写构造方法，则使用子类创建对象时，会自动调用父类的构造方法 ，\n        如果在子类中写了构造方法，则在创建子类实例的时候执行该方法，（实质就是原型\n        链就近原则，js使用方法名来规定方法的唯一性，这点和java是不同的，java使用\n        方法签名，也就是方法名和参数列表来规定方法的唯一性）\n      */\n      super(name, age);\n      this.voice = voice;\n    }\n    getName () {\n      super.getName();\n      console.log('Cat getName ' + this.name));\n    }\n  }\n  const cat = new Cat('mimi', 12, 'miao');\n  console.log(cat); // Cat {name: \"mimi\", age: 12, voice: \"miao\"}\n  cat.getName(); // Animal getName\n                  // Cat getName\n} \n// ES5继承\n{\n  function Animal (name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  Object.assign(Animal.prototype, {\n    getName () {\n      console.log('Animal getName ' + this.name);\n    }\n  });\n  function Cat (name, age, voice) {\n    Animal.apply(this, [name, age]);\n    this.voice = voice;\n  }\n  Object.assign(Cat.prototype, {\n    getName () {\n      // 子类public方法调用父类方法\n      Cat.prototype.__proto__.getName.call(this); // 同样可以使用call()来改变方法内的this\n      console.log('Cat getName ' + this.name)\n    }\n  })\n  Cat.prototype.__proto__ = Animal.prototype;\n  const cat = new Cat('lili', 2, 'miao'); \n  console.log(cat); // Cat {name: \"lili\", age: 2, voice: \"miao\"}\n  cat.getName(); // Animal getName lili\n                  // Cat getName lili\n}\n```\n{% asset_img class_compare1.png 类的简单使用 %}\n{% asset_img class_compare2.png ES6类的继承 %}\n{% asset_img class_compare3.png ES5类的继承 %}\n\n### getter和setter\n```javascript\n{\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n\n    // 这里你不要理解为方法，这里是非方法属性，相当于vue中的计算属性\n    get longName () {\n      return 'mk' + this.name;\n    }\n\n    set longName (value) {\n      // 意为你给longName赋值，最终会给name属性赋值\n      this.name =  value\n    }\n  }\n  const ani = new Animal();\n  console.log(ani.name); // animal\n  console.log(ani.longName); // mkanimal\n  ani.longName = 'cat';\n  console.log(ani.name); // cat\n  console.log(ani.longName); // mkcat\n}\n```\n### 静态方法\n+ 使用关键字static，这点和java相同\n```javascript\n{\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n    static tell () {\n      console.log('this is a static method');\n    }\n    test () {\n      tell();\n    }\n  }\n  const ani = new Animal();\n  console.log(ani);\n  console.log(ani.name); // animal\n  Animal.tell(); // this is a static method\n\n  // js中的静态方法不能通过实例去调用，这主要与静态方法存放的位置有关，这点与java不同\n  ani.tell(); // Uncaught TypeError: ani.tell is not a function \n\n  // 当然也不能通过原型链上的其他方法去调用(这实质上也是通过实例在调用)\n  ani.test(); // Uncaught TypeError: ani.tell is not a function \n}\n```\n{% asset_img static1.png 静态方法%}\n+ 当然，也可以使用一些骚操作来实现实例对静态方法的调用，只要搞清楚静态方法存放的位置，就可以为所欲为\n```javascript\n{\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n    static tell () {\n      console.log('this is a static method');\n    }\n    static getThis () {\n      console.log(this)\n    }\n\n    test () {\n      tell();\n    }\n    test2 () {\n      Animal.tell();\n    }\n    test3 () {\n      Animal.getThis.call(this);\n    }\n  }\n  const ani = new Animal();\n  console.log(ani);\n  console.log(ani.name); // animal\n  Animal.tell(); // this is a static method\n  Animal.getThis();\n  /* 输出：\n  class Animal {\n    constructor (name = 'animal') {\n      this.name = name;\n    }\n    static tell () {\n      console.log('this is a static method');\n    }\n    static getThis () {\n      console.log(this)\n   …\n  */\n\n  // js中的静态方法不能通过实例去调用，这主要与静态方法存放的位置有关，这点与java不同\n  ani.tell(); // Uncaught TypeError: ani.tell is not a function \n\n  // 当然也不能通过原型链上的其他方法去调用，因为在对象的原型链上找不到这个方法。\n  ani.test(); // Uncaught TypeError: ani.tell is not a function \n\n  // 但其实你非要通过实例中的方法间接使用，也可以\n  ani.test2(); // this is a static method\n\n  // 甚至通过call来改变this的指向（call太强大了）\n  ani.test3(); // Animal {name: \"animal\"}\n}\n```\n+ 如果要用ES5实现，就直接给类加属性就可以了，如：Animal.getThis = function () {}，甚至可以使用这种方法定义静态属性，但static只能用来定义静态方法","slug":"ES6梳理-类","published":1,"updated":"2020-01-20T07:45:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghx0015lktv8b5c5arg"},{"title":"ES6梳理-解构赋值","abbrlink":"13f9823b","date":"2019-04-29T02:00:00.000Z","_content":"\n# 解构赋值\n对象的结构赋值按照key去匹配，数组的解构赋值按照位置去匹配 \n<!-- more -->\n\n## 对象的解构赋值\n\n写法一：\n```javascript\n// 解构对象\nconst obj = {\n\ta: 1, \n  \tb: 2\n}\n// 赋值变量\nlet {a, b} = obj;\nconsole.log(a, b);\n```\n\n写法二:\n```javascript\n {\n   let a, b;\n   ({a, b} = {a: 1, b: 2});\n   console.log(a, b);\n }\n// 输出: 1 2 \n```\n覆盖变量的默认值：\n```javascript\n{\n  let {a=10, b=5} = {a:5}\n  console.log(a, b)\n}\n```\n起别名：\n```javascript\n{\n  let metaData = {\n    title: 'abc',\n    num: 2222\n  }\n  let {title: t, num: n} = metaData;\n  console.log(t, n)\n  // 输出 'abc' 222 \n  // 如果你要访问title，就会报错，title is not defined\n}\n```\n使用场景一：服务端和前端通行使用的格式是json，metaData是从后端接收到的json对象，我们需要取出第一层的title和第二层的title \n\n```javascript\n{\n  let metaData = {\n    title: 'abc',\n    test: [{\n      title: 'test1', // 只能取出第一个数组项的title\n      desc: 'description'\n    }, {\n      title: 'test2',\n      desc: 'description'\n    }]\n  }\n\n  //  取出来的是冒号右边的值，在后续访问的也是冒号后面的值，如果你访问左边的值，则会报 xxx is not defined\n  let {title: esTitle, test: [{title: cnTitle}]} = metaData;\n            // 取出了第一层的title属性并且别名\n  console.log(esTitle, cnTitle)\n}\n``\n\nps:对象简单赋值法：\n```javascript\nlet c, d;\nc = 3;\nd = 4;\nconst obj2 = {c, d};\n```\n\n## 数组的解构赋值\n\n0. 一般写法\n```javascript\n{\n  let a = 1, b = 2;\n  const arr = [a, b];\n  console.log(a, b, arr);\n}\n```\n1. 解构赋值写法\n```javascript\n{\n  let a, b;\n  const arr = [a, b] = [1, 2]\n              // 对应写法\n  console.log(a, b, arr);\n}\n```\n2. 数组解构赋值+ \"...\"操作符\n```javascript\n{\n  let a, b, rest;\n  [a, b,...rest] = [1, 2, 3, 4, 5, 6]\n  console.log(a, b, rest)\n}\n// 输出: 1 2 [3, 4, 5, 6]\n```\n\n3. 如果右边缺少与左边的配对值，则右边的值默认为undefined。反则，右边值覆盖左边值\n```javascript\n{\n  let a, b=111, c, rest;\n  \t\t// 给b设置初值\n  const arr = [a, b=222, c] = [1, 2]\t\t\t// 修改b的值      //再次修改b的值\n  console.log(a, b, c, arr)\n}\n//输出：1 2 undefined [1, 2]\n```\n\n4. 数组解构赋值默认值使用场景，以前es5不好实现的，现在非常容易\n\n场景一：实现变量交换\n```javascript\n{\n  let a = 1, b = 2;\n  [a, b] = [b, a];\n  console.log(a, b);\n}\n//输出： 2 1\n```\n\n场景二：某个产品订单函数，输出三个值，第一个是名称，第二个是数量，第三个值是单价。\n```javascript \n{\n  function fn () {\n \treturn ['手机', 2, 2000];\n  }\n  let [name, num, price] = fn();\n  // 直接使用变量来接受值本身，不需要再通过数组的索引去取值。\n  console.log(name, num, price);\n  // 输出： \"手机\" 2 2000\n}\n```\n场景三：函数执行返回一个数组，我只取出来我想要的\n```javascript\n{\n  function fn () {\n    return [1, 2, 3, 4, 5];\n  }\n  let a, b, c;\n  [a, b, , ,c] = fn(); // 根据位置来去除自己想要的值\n  console.log(a, b, c);\n  // 输出： 1 2 5\n}\n```\n场景四（特别有用）：函数执行返回一个数组，但是长度未知，我想要第一个元素，但是其余的元素我需要保存在一个数组中在未来使用\n```javascript\n{\n  function fn () {\n    return [1, 2, 3, 4, 5];\n  }\n  let a, b;\n  [a, ...b] = fn(); // 根据位置来去除自己想要的值\n  console.log(a, b);\n  // 输出： 1 [2, 3, 4, 5]\n}\n```","source":"_posts/ES6梳理-解构赋值.md","raw":"---\ntitle: ES6梳理-解构赋值\ncategories:\n  - ES6\n  - 解构赋值\ntags:\n  - ES6\n  - 解构赋值\nabbrlink: 13f9823b\ndate: 2019-04-29 10:00:00\n---\n\n# 解构赋值\n对象的结构赋值按照key去匹配，数组的解构赋值按照位置去匹配 \n<!-- more -->\n\n## 对象的解构赋值\n\n写法一：\n```javascript\n// 解构对象\nconst obj = {\n\ta: 1, \n  \tb: 2\n}\n// 赋值变量\nlet {a, b} = obj;\nconsole.log(a, b);\n```\n\n写法二:\n```javascript\n {\n   let a, b;\n   ({a, b} = {a: 1, b: 2});\n   console.log(a, b);\n }\n// 输出: 1 2 \n```\n覆盖变量的默认值：\n```javascript\n{\n  let {a=10, b=5} = {a:5}\n  console.log(a, b)\n}\n```\n起别名：\n```javascript\n{\n  let metaData = {\n    title: 'abc',\n    num: 2222\n  }\n  let {title: t, num: n} = metaData;\n  console.log(t, n)\n  // 输出 'abc' 222 \n  // 如果你要访问title，就会报错，title is not defined\n}\n```\n使用场景一：服务端和前端通行使用的格式是json，metaData是从后端接收到的json对象，我们需要取出第一层的title和第二层的title \n\n```javascript\n{\n  let metaData = {\n    title: 'abc',\n    test: [{\n      title: 'test1', // 只能取出第一个数组项的title\n      desc: 'description'\n    }, {\n      title: 'test2',\n      desc: 'description'\n    }]\n  }\n\n  //  取出来的是冒号右边的值，在后续访问的也是冒号后面的值，如果你访问左边的值，则会报 xxx is not defined\n  let {title: esTitle, test: [{title: cnTitle}]} = metaData;\n            // 取出了第一层的title属性并且别名\n  console.log(esTitle, cnTitle)\n}\n``\n\nps:对象简单赋值法：\n```javascript\nlet c, d;\nc = 3;\nd = 4;\nconst obj2 = {c, d};\n```\n\n## 数组的解构赋值\n\n0. 一般写法\n```javascript\n{\n  let a = 1, b = 2;\n  const arr = [a, b];\n  console.log(a, b, arr);\n}\n```\n1. 解构赋值写法\n```javascript\n{\n  let a, b;\n  const arr = [a, b] = [1, 2]\n              // 对应写法\n  console.log(a, b, arr);\n}\n```\n2. 数组解构赋值+ \"...\"操作符\n```javascript\n{\n  let a, b, rest;\n  [a, b,...rest] = [1, 2, 3, 4, 5, 6]\n  console.log(a, b, rest)\n}\n// 输出: 1 2 [3, 4, 5, 6]\n```\n\n3. 如果右边缺少与左边的配对值，则右边的值默认为undefined。反则，右边值覆盖左边值\n```javascript\n{\n  let a, b=111, c, rest;\n  \t\t// 给b设置初值\n  const arr = [a, b=222, c] = [1, 2]\t\t\t// 修改b的值      //再次修改b的值\n  console.log(a, b, c, arr)\n}\n//输出：1 2 undefined [1, 2]\n```\n\n4. 数组解构赋值默认值使用场景，以前es5不好实现的，现在非常容易\n\n场景一：实现变量交换\n```javascript\n{\n  let a = 1, b = 2;\n  [a, b] = [b, a];\n  console.log(a, b);\n}\n//输出： 2 1\n```\n\n场景二：某个产品订单函数，输出三个值，第一个是名称，第二个是数量，第三个值是单价。\n```javascript \n{\n  function fn () {\n \treturn ['手机', 2, 2000];\n  }\n  let [name, num, price] = fn();\n  // 直接使用变量来接受值本身，不需要再通过数组的索引去取值。\n  console.log(name, num, price);\n  // 输出： \"手机\" 2 2000\n}\n```\n场景三：函数执行返回一个数组，我只取出来我想要的\n```javascript\n{\n  function fn () {\n    return [1, 2, 3, 4, 5];\n  }\n  let a, b, c;\n  [a, b, , ,c] = fn(); // 根据位置来去除自己想要的值\n  console.log(a, b, c);\n  // 输出： 1 2 5\n}\n```\n场景四（特别有用）：函数执行返回一个数组，但是长度未知，我想要第一个元素，但是其余的元素我需要保存在一个数组中在未来使用\n```javascript\n{\n  function fn () {\n    return [1, 2, 3, 4, 5];\n  }\n  let a, b;\n  [a, ...b] = fn(); // 根据位置来去除自己想要的值\n  console.log(a, b);\n  // 输出： 1 [2, 3, 4, 5]\n}\n```","slug":"ES6梳理-解构赋值","published":1,"updated":"2020-01-20T07:45:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghy0018lktvmipseua6"},{"title":"Function原型对象中的call、apply、bind","date":"2019-04-29T04:00:00.000Z","_content":"# Function.prototype\n+ call、apply、bind都是Function.prototype的属性\n<!-- more -->\n```javascript\n{\n  console.log(Function.prototype.hasOwnProperty('apply')); // true\n  console.log(Function.prototype.hasOwnProperty('call')); // true\n  console.log(Function.prototype.hasOwnProperty('bind')); // true\n}\n```\n### call、apply方法\n```javascript\n{\n  function fn (a, b) {\n    console.log(this.name, a, b)\n  }\n  var obj = {\n    name: 'masia'\n  }\n  fn.call(obj, 1, 2); // masia 1 2  fn函数体中this是obj\n  fn.apply(obj, [11, 22]); // masia 11 22  fn函数体中的this是obj\n  var getFun = fn.bind(obj); // masia 111 222  fn函数体中的this是obj\n  getFun(111, 222);\n}\n```\n### bind方法用来重新定义方法中的this\n与call、apply不同的是，使用fn.bind(self)并不是在调用的时候重新定义this的指向，而是在调用之前重新定义了方法中this的指向，fn.bind(self)这个表达式的值是一个方法体，所以需要一个变量去接收修改this后的fn方法体。fn.call(self)或者fn.apply(self)的值是fn执行的返回值。\n```javascript\n{\n  function fn (arg) {\n    console.log('arg',arg); // arg this is arg\n    console.log(this.name); // obj1\n  }\n  let obj1 = {\n    name: 'obj1'\n  }\n  let obj2 = {\n    name: 'obj2',\n    fn: fn.bind(obj1)\n  }\n  obj2.fn('this is arg');\n}\n```\n```javascript\n// 使用新的变量去接收改变this指向后的fn函数\n{\n  function fn () {\n    console.log(this);\n  }\n  let obj = {\n    name: 'obj'\n  }\n  let newFn = fn.bind(obj);\n  fn(); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n  newFn(); // {name: \"obj\"}\n}\n```\n","source":"_posts/Function原型对象中的call、apply、bind.md","raw":"---\ntitle: Function原型对象中的call、apply、bind\ncategories:\n  - javascript\n  - Function\ntags:\n  - javascript\n  - Function\ndate: 2019-04-29 12:00:00\n---\n# Function.prototype\n+ call、apply、bind都是Function.prototype的属性\n<!-- more -->\n```javascript\n{\n  console.log(Function.prototype.hasOwnProperty('apply')); // true\n  console.log(Function.prototype.hasOwnProperty('call')); // true\n  console.log(Function.prototype.hasOwnProperty('bind')); // true\n}\n```\n### call、apply方法\n```javascript\n{\n  function fn (a, b) {\n    console.log(this.name, a, b)\n  }\n  var obj = {\n    name: 'masia'\n  }\n  fn.call(obj, 1, 2); // masia 1 2  fn函数体中this是obj\n  fn.apply(obj, [11, 22]); // masia 11 22  fn函数体中的this是obj\n  var getFun = fn.bind(obj); // masia 111 222  fn函数体中的this是obj\n  getFun(111, 222);\n}\n```\n### bind方法用来重新定义方法中的this\n与call、apply不同的是，使用fn.bind(self)并不是在调用的时候重新定义this的指向，而是在调用之前重新定义了方法中this的指向，fn.bind(self)这个表达式的值是一个方法体，所以需要一个变量去接收修改this后的fn方法体。fn.call(self)或者fn.apply(self)的值是fn执行的返回值。\n```javascript\n{\n  function fn (arg) {\n    console.log('arg',arg); // arg this is arg\n    console.log(this.name); // obj1\n  }\n  let obj1 = {\n    name: 'obj1'\n  }\n  let obj2 = {\n    name: 'obj2',\n    fn: fn.bind(obj1)\n  }\n  obj2.fn('this is arg');\n}\n```\n```javascript\n// 使用新的变量去接收改变this指向后的fn函数\n{\n  function fn () {\n    console.log(this);\n  }\n  let obj = {\n    name: 'obj'\n  }\n  let newFn = fn.bind(obj);\n  fn(); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n  newFn(); // {name: \"obj\"}\n}\n```\n","slug":"Function原型对象中的call、apply、bind","published":1,"updated":"2020-01-20T07:45:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75ghz001alktvjrbdm9jd"},{"title":"MVVM双向数据绑定原理","date":"2019-07-13T01:00:00.000Z","_content":"# MVVM双向数据绑定原理\n+ angular\n  脏值检测\n+ vue\n  数据劫持\n<!-- more -->\n### Object.defineProperty（ES5）\n+ 定义方式作比较\n```javascript\n// 以往方式定义对象\nvar obj = {}\nobj.school = 'lala'\n// 使用Object.defineProperty定义对象\nvar obj2 = {}\nObject.defineProperty(obj2, 'school', {\n  value: 'lala'\n})\n```\n1. 使用Object.defineProperty()定义的属性不能被删掉，当然也不允许使用“对象.属性=新值”的方式重新赋值\n```javascript\n{\n  let obj = {\n    school: 'lala'\n  }\n  let obj2 = {}\n  let a = 'masia'\n  Object.defineProperty(obj2, 'school', {\n    value: a\n  })\n  delete obj.school\n  delete obj2.school // 使用Object.defineProperty()定义的属性不能被删掉\n  console.log(obj); // {}\n  console.log(obj2); // {school: \"masia\"}\n}\n```\n2. Object.defineProperty()中的configurable、writable、ennumberable属性\n```javascript\n{\n  let a = {\n    name: 'masia'\n  }\n  let obj2 = {}\n  Object.defineProperty(obj2, 'school', {\n    configurable: true, // 允许使用delete 对象.属性的方式去删除，默认为false\n    writable: true, // 允许去写，默认为false\n    enumerable: true, // 是否可枚举（使用for in遍历），默认为false\n    value: a,\n  })\n  delete obj2.school;\n  console.log(obj2); // {}\n}\n```\n3. get和set不能与value、writable共存\n如果你写了get和set，那就不要value writable属性了，不然会报错。当然，此时你写不写enumerable: true,当前属性都是可枚举的。\n\n### 数据劫持\n```javascript\nclass Vue {\n  constructor (options = {}) {\n    this.$options = options;\n    this.$data = options.data;\n    this.defineProperty(this.$data);\n    for (let key in this.$data) {\n      this[key] = this.$data[key];\n    }\n  }\n  defineProperty (obj) {\n    let seft = this;\n    for (let property in obj) {\n      let val = obj[property];\n      Object.defineProperty(obj, property, {\n        enumerable: true,\n        get () { // 每次通过vue.$data.属性 获取值的时候，都会走这个方法\n          return val; // 把val的值返回\n        }, \n        set (newVal) { // 每次通过vue.$data.属性 = 'xxx'赋值的时候，都会走这个方法\n          if (newVal !== val) {\n            val = newVal; // 把新值保存在val中\n          }\n          \n        }\n      })\n      if (typeof val == 'object') {\n        this.defineProperty.call(seft, val);\n      }\n    }\n  }\n}\nlet vue = new Vue({\n  el: '#app',\n  data: {\n    a: 'aaa',\n    b: {\n      bb: 'bb'\n    },\n    c: 'ccc'\n  }\n})\n```\n输出：\n{% asset_img 数据劫持.png 数据劫持 %}\n\n### 数据代理\n+ 错误方式：浅复制方法\n如果使用常规浅复制方式，发现并不适用this.$data中基本类型的属性。因为通过this.a='xx'的方式尝试去改变this.$data.a的值，发现并没有生效，因为this.a是string类型的，this.a = this.$data.a 也只是把后者的值赋给前者，所以并没有改变this.$data.a的值。而通过this.b.bb = 'xx'的方式去改变this.$data.b.bb的值，则生效了。因为this.b是引用类型啊。\n```javascript\nclass Vue {\n  constructor (options = {}) {\n    this.$options = options;\n    this.$data = options.data;\n    this.defineProperty(this.$data);\n    for (let key in this.$data) {\n      this[key] = this.$data[key];\n    }\n  }\n  defineProperty (obj) {\n    let seft = this;\n    for (let property in obj) {\n      let val = obj[property];\n      Object.defineProperty(obj, property, {\n        enumerable: true, // 这里加不加可枚举属性,vue.$data的属性都是可枚举的\n        get () {\n          document.getElementById('div').innerHTML = val;\n          return val;\n        }, \n        set (newVal) {\n          if (newVal !== val) {\n            val = newVal;\n          }\n          \n        }\n      })\n      if (typeof val == 'object') {\n        this.defineProperty.call(seft, val);\n      }\n    }\n  }\n}\nlet vue = new Vue({\n  el: '#app',\n  data: {\n    a: 'aaa',\n    b: {\n      bb: 'bb'\n    },\n    c: 'ccc'\n  }\n})\nconsole.log(vue.$data.a); // aaa\nconsole.log(vue.$data.b.bb); // bb\nvue.a = '修改后的a'\nvue.b.bb = '修改后的bb';\nconsole.log(vue.$data.a); // aaa 发现没有修改this.$data.a的值\nconsole.log(vue.$data.b.bb); // 修改后的bb\n```\n+ 正确方式：再来一次数据劫持\n管你赋值的是什么类型，如果你对this.a赋值，我就先劫持掉，把你赋的值转赋给this.$data.a。如果你要获取this.a的值，那我就把this.$data.a的值拿来给你。\n要注意的是：给this.$data.b.bb赋值也就是给this.$data.b赋值，通过\".\"方式操作对象的的过程其实也是一层一层寻找的过程。\n```javascript\nclass Vue {\n  constructor (options = {}) {\n    this.$options = options;\n    this.$data = options.data;\n    this.defineProperty(this.$data);\n    for (let key in this.$data) {\n      Object.defineProperty(this, key, {\n        enumerable: true, // 这里加不加可枚举属性,vue.$data的属性都是可枚举的\n        get () {\n          return this.$data[key];\n        },\n        set (newVal) {\n          this.$data[key] = newVal;\n        }\n      })\n    }\n  }\n  defineProperty (obj) {\n    let seft = this;\n    for (let property in obj) {\n      let val = obj[property];\n      Object.defineProperty(obj, property, {\n        get () {\n          document.getElementById('div').innerHTML = val;\n          return val;\n        }, \n        set (newVal) {\n          if (newVal !== val) {\n            val = newVal;\n          }\n          \n        }\n      })\n      if (typeof val == 'object') {\n        this.defineProperty.call(seft, val);\n      }\n    }\n  }\n}\nlet vue = new Vue({\n  el: '#app',\n  data: {\n    a: 'aaa',\n    b: {\n      bb: 'bb'\n    },\n    c: 'ccc'\n  }\n})\nconsole.log(vue.$data.a); // aaa\nconsole.log(vue.$data.b.bb); // bb\nvue.a = '修改后的a'\nvue.b.bb = '修改后的bb';\nconsole.log(vue.$data.a); // 修改后的a 发现可以修改基本类型的this.$data.a了\nconsole.log(vue.$data.b.bb); // 修改后的bb\nconsole.log(vue.a) // 修改后的a\nconsole.log(vue.b.bb) // 修改后的bb\n```\n### 编译模板\nVue中的v-model、{{}}是如何编译的？\n1. 通过el拿到里面的所有dom元素，遍历每个dom元素的节点（文本节点、属性节点、以及元素节点），并且把这些dom对象移入内存\n  1. 文本节点\n    1. 判断存在{{}}，并且解析\n  2. 属性节点\n    2. 判断存在\"v-\"，并且获得包含\"v-\"的指令列表，并且解析\n  3. 元素节点\n    1. 递归遍历子元素\n2. 通过正则表达式解析“v-model、{{}}”这样的指令或者插值表达式模板\\\n  1. dom元素中属性中的指令\n    1. 指令本身\n      1. show\n      2. model\n      3. text\n      4. html\n      5. ...\n    2. 指令的value\n      1. 一般变量\n      2. 表达式\n  2. dom元素文本节点中的{{}}\n   1. 一般变量\n   2. 表达式\n      1. {{flag? '真': '假'}}\n3. 分离出模板中的js表达式，并且得到执行结果，比如取当前实例的属性值\"shool.name\"等\n  1. 一般变量\n  2. 表达式\n4. 在内存中，使用拿到的属性值重新填充模板\n5. 把填充好的模板再写入dom\n总结： 当前实例vm，和需要操作的节点贯穿整个函数执行栈，因为要做的事情只有一件，就是找到节点对应的内存空间，并把this.$data中的相对应的值放进去。","source":"_posts/MVVM双向数据绑定原理.md","raw":"---\ntitle: MVVM双向数据绑定原理\ncategories:\n  - js\n  - MVVM\ntags:\n  - js\n  - MVVM\ndate: 2019-07-13 09:00:00\n---\n# MVVM双向数据绑定原理\n+ angular\n  脏值检测\n+ vue\n  数据劫持\n<!-- more -->\n### Object.defineProperty（ES5）\n+ 定义方式作比较\n```javascript\n// 以往方式定义对象\nvar obj = {}\nobj.school = 'lala'\n// 使用Object.defineProperty定义对象\nvar obj2 = {}\nObject.defineProperty(obj2, 'school', {\n  value: 'lala'\n})\n```\n1. 使用Object.defineProperty()定义的属性不能被删掉，当然也不允许使用“对象.属性=新值”的方式重新赋值\n```javascript\n{\n  let obj = {\n    school: 'lala'\n  }\n  let obj2 = {}\n  let a = 'masia'\n  Object.defineProperty(obj2, 'school', {\n    value: a\n  })\n  delete obj.school\n  delete obj2.school // 使用Object.defineProperty()定义的属性不能被删掉\n  console.log(obj); // {}\n  console.log(obj2); // {school: \"masia\"}\n}\n```\n2. Object.defineProperty()中的configurable、writable、ennumberable属性\n```javascript\n{\n  let a = {\n    name: 'masia'\n  }\n  let obj2 = {}\n  Object.defineProperty(obj2, 'school', {\n    configurable: true, // 允许使用delete 对象.属性的方式去删除，默认为false\n    writable: true, // 允许去写，默认为false\n    enumerable: true, // 是否可枚举（使用for in遍历），默认为false\n    value: a,\n  })\n  delete obj2.school;\n  console.log(obj2); // {}\n}\n```\n3. get和set不能与value、writable共存\n如果你写了get和set，那就不要value writable属性了，不然会报错。当然，此时你写不写enumerable: true,当前属性都是可枚举的。\n\n### 数据劫持\n```javascript\nclass Vue {\n  constructor (options = {}) {\n    this.$options = options;\n    this.$data = options.data;\n    this.defineProperty(this.$data);\n    for (let key in this.$data) {\n      this[key] = this.$data[key];\n    }\n  }\n  defineProperty (obj) {\n    let seft = this;\n    for (let property in obj) {\n      let val = obj[property];\n      Object.defineProperty(obj, property, {\n        enumerable: true,\n        get () { // 每次通过vue.$data.属性 获取值的时候，都会走这个方法\n          return val; // 把val的值返回\n        }, \n        set (newVal) { // 每次通过vue.$data.属性 = 'xxx'赋值的时候，都会走这个方法\n          if (newVal !== val) {\n            val = newVal; // 把新值保存在val中\n          }\n          \n        }\n      })\n      if (typeof val == 'object') {\n        this.defineProperty.call(seft, val);\n      }\n    }\n  }\n}\nlet vue = new Vue({\n  el: '#app',\n  data: {\n    a: 'aaa',\n    b: {\n      bb: 'bb'\n    },\n    c: 'ccc'\n  }\n})\n```\n输出：\n{% asset_img 数据劫持.png 数据劫持 %}\n\n### 数据代理\n+ 错误方式：浅复制方法\n如果使用常规浅复制方式，发现并不适用this.$data中基本类型的属性。因为通过this.a='xx'的方式尝试去改变this.$data.a的值，发现并没有生效，因为this.a是string类型的，this.a = this.$data.a 也只是把后者的值赋给前者，所以并没有改变this.$data.a的值。而通过this.b.bb = 'xx'的方式去改变this.$data.b.bb的值，则生效了。因为this.b是引用类型啊。\n```javascript\nclass Vue {\n  constructor (options = {}) {\n    this.$options = options;\n    this.$data = options.data;\n    this.defineProperty(this.$data);\n    for (let key in this.$data) {\n      this[key] = this.$data[key];\n    }\n  }\n  defineProperty (obj) {\n    let seft = this;\n    for (let property in obj) {\n      let val = obj[property];\n      Object.defineProperty(obj, property, {\n        enumerable: true, // 这里加不加可枚举属性,vue.$data的属性都是可枚举的\n        get () {\n          document.getElementById('div').innerHTML = val;\n          return val;\n        }, \n        set (newVal) {\n          if (newVal !== val) {\n            val = newVal;\n          }\n          \n        }\n      })\n      if (typeof val == 'object') {\n        this.defineProperty.call(seft, val);\n      }\n    }\n  }\n}\nlet vue = new Vue({\n  el: '#app',\n  data: {\n    a: 'aaa',\n    b: {\n      bb: 'bb'\n    },\n    c: 'ccc'\n  }\n})\nconsole.log(vue.$data.a); // aaa\nconsole.log(vue.$data.b.bb); // bb\nvue.a = '修改后的a'\nvue.b.bb = '修改后的bb';\nconsole.log(vue.$data.a); // aaa 发现没有修改this.$data.a的值\nconsole.log(vue.$data.b.bb); // 修改后的bb\n```\n+ 正确方式：再来一次数据劫持\n管你赋值的是什么类型，如果你对this.a赋值，我就先劫持掉，把你赋的值转赋给this.$data.a。如果你要获取this.a的值，那我就把this.$data.a的值拿来给你。\n要注意的是：给this.$data.b.bb赋值也就是给this.$data.b赋值，通过\".\"方式操作对象的的过程其实也是一层一层寻找的过程。\n```javascript\nclass Vue {\n  constructor (options = {}) {\n    this.$options = options;\n    this.$data = options.data;\n    this.defineProperty(this.$data);\n    for (let key in this.$data) {\n      Object.defineProperty(this, key, {\n        enumerable: true, // 这里加不加可枚举属性,vue.$data的属性都是可枚举的\n        get () {\n          return this.$data[key];\n        },\n        set (newVal) {\n          this.$data[key] = newVal;\n        }\n      })\n    }\n  }\n  defineProperty (obj) {\n    let seft = this;\n    for (let property in obj) {\n      let val = obj[property];\n      Object.defineProperty(obj, property, {\n        get () {\n          document.getElementById('div').innerHTML = val;\n          return val;\n        }, \n        set (newVal) {\n          if (newVal !== val) {\n            val = newVal;\n          }\n          \n        }\n      })\n      if (typeof val == 'object') {\n        this.defineProperty.call(seft, val);\n      }\n    }\n  }\n}\nlet vue = new Vue({\n  el: '#app',\n  data: {\n    a: 'aaa',\n    b: {\n      bb: 'bb'\n    },\n    c: 'ccc'\n  }\n})\nconsole.log(vue.$data.a); // aaa\nconsole.log(vue.$data.b.bb); // bb\nvue.a = '修改后的a'\nvue.b.bb = '修改后的bb';\nconsole.log(vue.$data.a); // 修改后的a 发现可以修改基本类型的this.$data.a了\nconsole.log(vue.$data.b.bb); // 修改后的bb\nconsole.log(vue.a) // 修改后的a\nconsole.log(vue.b.bb) // 修改后的bb\n```\n### 编译模板\nVue中的v-model、{{}}是如何编译的？\n1. 通过el拿到里面的所有dom元素，遍历每个dom元素的节点（文本节点、属性节点、以及元素节点），并且把这些dom对象移入内存\n  1. 文本节点\n    1. 判断存在{{}}，并且解析\n  2. 属性节点\n    2. 判断存在\"v-\"，并且获得包含\"v-\"的指令列表，并且解析\n  3. 元素节点\n    1. 递归遍历子元素\n2. 通过正则表达式解析“v-model、{{}}”这样的指令或者插值表达式模板\\\n  1. dom元素中属性中的指令\n    1. 指令本身\n      1. show\n      2. model\n      3. text\n      4. html\n      5. ...\n    2. 指令的value\n      1. 一般变量\n      2. 表达式\n  2. dom元素文本节点中的{{}}\n   1. 一般变量\n   2. 表达式\n      1. {{flag? '真': '假'}}\n3. 分离出模板中的js表达式，并且得到执行结果，比如取当前实例的属性值\"shool.name\"等\n  1. 一般变量\n  2. 表达式\n4. 在内存中，使用拿到的属性值重新填充模板\n5. 把填充好的模板再写入dom\n总结： 当前实例vm，和需要操作的节点贯穿整个函数执行栈，因为要做的事情只有一件，就是找到节点对应的内存空间，并把this.$data中的相对应的值放进去。","slug":"MVVM双向数据绑定原理","published":1,"updated":"2020-01-20T08:28:38.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi0001clktvqdkacv57"},{"title":"Object原型对象","date":"2019-04-29T03:00:00.000Z","_content":"\n# javascript Object\n+ 方法Object.assign()，用类给一个构造函数或者说类的原型对象添加属性\n<!-- more -->\n```javascript\n{\n  function Person (name) {\n    this.name = name\n  }\n  const obj = new Person();\n  console.log(Person.prototype.constructor) // ƒ Person (name) {..}\n  // 如果我们直接覆盖Person.prototype，那样prototype原来有constructor属性将会丢失。\n  Person.prototype = {\n    getName: function () {\n      return this.name;\n    }\n  }\n  console.log(Person.prototype.constructor) // 再次打印，只能查找到了Object的中constructor, ƒ Object() { [native code] }\n\n  // 当然我们也不需要通过Person.prototype.getName = .. 的方式一个个去添加属性，直接使用Object.assign(),这样只是添加了属性，并没有改变构造函数原型对象的指向\n\n  function Animal (name) {\n    this.name = name\n  }\n  Object.assgin({\n    getName: function () {\n      return this.name;\n    },\n    setName (name) {\n      this.name = name;\n    }\n  })\n}\n```\n+ 方法Object.create()\n```javascript\n{\n  const obj = {} // 由Object创建的对象，他的 __proto__ 指向Object.prototype\n  function Person () {}\n  const person = new Person() // \n  console.log(person) // 由Person创建，他的 __proto__ 指向Person.prototype\n\n  const obj2 = Object.create(null); // 创建了一个没有 __proto__ 属性的空对象，那么自然这个对象不能使用Object原型对象上面的属性\n  obj2.a = 'masia' // 单可以为他添加属性\n  console.log(obj2.a) // 而且可以访问\n\n  const methods = {\n    getName: function () {\n      return this.name\n    }\n  }\n  const obj3 = Object.create(methods) // 把obj3的__proto__属性指向methods对象\n  obj3.name = 'masia'; // 可以添加属性\n  console.log(obj3.getName()); // masia \n\n  // 请不会给Object.create()的参数传了一个函数\n}\n\n// 使用工厂模式手写一个Object.create() 方法\n{\n  function ObCreate (proto) {\n    const a = {}\n    a.__proto__ = proto;\n    return a;\n  }\n  const proto = {\n    getName: function () {\n      return this.name;\n    }\n  }\n  const obj = ObCreate(proto);\n  obj.name = 'masia';\n  console.log(obj.getName()); // masia\n}\n</script>\n```","source":"_posts/Object.md","raw":"---\ntitle: Object原型对象\ncategories:\n  - javascript\n  - Object\ntags:\n  - javascript\n  - Object\ndate: 2019-04-29 11:00:00\n---\n\n# javascript Object\n+ 方法Object.assign()，用类给一个构造函数或者说类的原型对象添加属性\n<!-- more -->\n```javascript\n{\n  function Person (name) {\n    this.name = name\n  }\n  const obj = new Person();\n  console.log(Person.prototype.constructor) // ƒ Person (name) {..}\n  // 如果我们直接覆盖Person.prototype，那样prototype原来有constructor属性将会丢失。\n  Person.prototype = {\n    getName: function () {\n      return this.name;\n    }\n  }\n  console.log(Person.prototype.constructor) // 再次打印，只能查找到了Object的中constructor, ƒ Object() { [native code] }\n\n  // 当然我们也不需要通过Person.prototype.getName = .. 的方式一个个去添加属性，直接使用Object.assign(),这样只是添加了属性，并没有改变构造函数原型对象的指向\n\n  function Animal (name) {\n    this.name = name\n  }\n  Object.assgin({\n    getName: function () {\n      return this.name;\n    },\n    setName (name) {\n      this.name = name;\n    }\n  })\n}\n```\n+ 方法Object.create()\n```javascript\n{\n  const obj = {} // 由Object创建的对象，他的 __proto__ 指向Object.prototype\n  function Person () {}\n  const person = new Person() // \n  console.log(person) // 由Person创建，他的 __proto__ 指向Person.prototype\n\n  const obj2 = Object.create(null); // 创建了一个没有 __proto__ 属性的空对象，那么自然这个对象不能使用Object原型对象上面的属性\n  obj2.a = 'masia' // 单可以为他添加属性\n  console.log(obj2.a) // 而且可以访问\n\n  const methods = {\n    getName: function () {\n      return this.name\n    }\n  }\n  const obj3 = Object.create(methods) // 把obj3的__proto__属性指向methods对象\n  obj3.name = 'masia'; // 可以添加属性\n  console.log(obj3.getName()); // masia \n\n  // 请不会给Object.create()的参数传了一个函数\n}\n\n// 使用工厂模式手写一个Object.create() 方法\n{\n  function ObCreate (proto) {\n    const a = {}\n    a.__proto__ = proto;\n    return a;\n  }\n  const proto = {\n    getName: function () {\n      return this.name;\n    }\n  }\n  const obj = ObCreate(proto);\n  obj.name = 'masia';\n  console.log(obj.getName()); // masia\n}\n</script>\n```","slug":"Object","published":1,"updated":"2020-01-20T07:45:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi1001glktvwiya2ahq"},{"title":"React在事件绑定中bind的使用","_content":"\n# 首先要知道的是bind的一些基本用法（骚操作 /滑稽）\n\n+ 1. bind 在使用的时候，第一个参数 是 this\n```javascript\n function demo (...arg) {\n  arg.forEach(item => {\n    console.log(item)\n  })\n}\n\nlet bindDemo = demo.bind(this, 1, 2, 3)\n\nbindDemo()\n\n// 输出了 1 2 3 ，却没有输出this ,那就证明 this 不是当作载荷传进去的\n```\n+ 2. 在被绑定的函数中主动打出 this\n```javascript\nfunction demo2 (...arg) {\n  console.log(this)\n  arg.forEach(item => {\n    console.log(item)\n  })\n}\n\nlet bindDemo2 = demo2.bind(this, 1, 2, 3)\n\nlet obj = { a: 1 }\n\nbindDemo2.call(obj)\n\n// 再使用.call调用，设法改变bindDemo2中的this，但是\n// 输出了 Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n//       1\n//       2\n//       3\n// 那就证明，在.call调用bindDemo2之前，bindDemo2中的this早就被规定好了。\n```\n+ 3. 那给bind 的第一个参数随便传一个呢，事实上你给bind的第一个参数传什么this就是什么，不管是什么类型( 例如传个 数字 11 )\n\n```javascript\nfunction demo3 () {\n  console.log(this) // 输出了了一个 Number 对象\n  // 当然你可以使用 valueOf() \n  console.log(this.valueOf()) // 输出了一个数字 11\n  // 你还可以使用 toString()\n  console.log(this.toString()) // 输出了一个字符串 '11'\n}\n\nlet bindDemo3 = demo3.bind(11)\n\nbindDemo3()\n```\n+ 4. 如果在jsx中使用bind给onClick绑定事件回调函数，那么第二个参数默认是event\n```javascript\nfunction Button () {\n  return (\n    <div onClick={clickDemo.bind(this, event, ...args)}></div>\n                              // 这里如果要传入this，和事件源对象，必须写this 和 event，2019年10月10日证明这种写法的错误的，因为event找不到\n    // 应该改为如下，先找个闭包把事件源对象保存一下\n    <div onClick={(e) => clickDemo.call(this, e, ...args)}></div>\n  )\n}\n\nfunction clickDemo (this, event, ...args) {\n  console.log(this)\n  console.log(event)\n  args.forEach(item => {\n    console.log(item)\n  })\n}\n```\n# 在 React中绑定事件回调函数的方法一般有三种（目前我知道的3种）\n\n第一种：在constructor去为事件回调函数绑定this，且将绑定好this的函数赋值给该函数本身(比较土，比较low)\n第二种：在真正的事件回调函数外面再包一层箭头函数 onClick={() => this.testClick()}，使用箭头函数中this去定义testClick中的this\n第三种：使用bind在定义事件回调函数的this（比较麻烦）\n\n+ 第一种：在constructor去为事件回调函数绑定this，且将绑定好this的函数赋值给该函数本身(比较土，比较low)\n```javascript\nclass Button extends React.Component {\n  constructor () {\n    super()\n    this.clickButton = this.clickButton.bind(this)\n  }\n  clickButton (...args) {\n    console.log(this)\n    args.forEach(item => {\n      console.log(item)\n    })\n  }\n\n  render () {\n    return (\n      <button onClick={this.clickButton}>点击按钮</button>\n    )\n  }\n}\n\nReactDOM.render(<Button />, document.getElementById('app'))\n\n// 输出:\n// Button {props: {…}, context: {…}, refs: {…}, updater: {…}, clickButton: ƒ, …}\n// Class {dispatchConfig: {…}, _targetInst: FiberNode, _dispatchListeners: ƒ, _dispatchInstances: FiberNode, nativeEvent: MouseEvent, …}\n```\n如果你想要传入event，那么还是得在事件绑定函数的时候用到\n`this.clickButton.bind(this, event)`\n输出：\n```javascript\n// Button {props: {…}, context: {…}, refs: {…}, updater: {…}, clickButton: ƒ, …}\n// Event {isTrusted: true, type: \"DOMContentLoaded\", target: document, currentTarget: null, eventPhase: 0, …}\n// Class {dispatchConfig: {…}, _targetInst: FiberNode, _dispatchListeners: ƒ, _dispatchInstances: FiberNode, nativeEvent: MouseEvent, …}\n```\n\n+ 第二种：在真正的事件回调函数外面再包一层箭头函数 onClick={() => this.testClick()}，使用箭头函数中this去定义testClick中的this\n\n```javascript\nclass Button extends React.Component {\n  constructor () {\n    super()\n  }\n\n  clickButton (...args) {\n    console.log(this)\n    args.forEach(item => {\n      console.log(item)\n    })\n  }\n\n  render () {\n    return (\n      <button onClick={() => this.clickButton()}>点击按钮</button>\n    )\n  }\n}\n\nReactDOM.render(<Button />, document.getElementById('app'))\n```\n\n+ 第三种：使用bind在定义事件回调函数的this（比较麻烦）\n```javascript\nlet args = [222, 333, 444]\nclass Button extends React.Component {\n  clickButton (...args) {\n    console.log(this) \n    args.forEach(item => {\n      console.log(item)\n    })\n  }\n\n  render () {\n    return (\n      <button onClick={this.clickButton.bind(this, event, ...args)}>点击按钮</button>\n    ) \n  }\n}\n\nReactDOM.render(<Button />, document.getElementById('app'))\n\n\n// 点击按钮输出：\n/*\n  Button {props: {…}, context: {…}, refs: {…}, updater: {…}, _reactInternalFiber: FiberNode, …}\n  Event {isTrusted: true, type: \"DOMContentLoaded\", target: document, currentTarget: null, eventPhase: 0, …}\n  222\n  333\n  444\n  Class {dispatchConfig: {…}, _targetInst: FiberNode, _dispatchListeners: ƒ, _dispatchInstances: FiberNode, nativeEvent: MouseEvent, …}\n*/\n```","source":"_posts/React在事件绑定中bind的使用.md","raw":"---\ntitle: React在事件绑定中bind的使用\ncategories:\n  - js\n  - react\ntags:\n  - js\n  - react\n---\n\n# 首先要知道的是bind的一些基本用法（骚操作 /滑稽）\n\n+ 1. bind 在使用的时候，第一个参数 是 this\n```javascript\n function demo (...arg) {\n  arg.forEach(item => {\n    console.log(item)\n  })\n}\n\nlet bindDemo = demo.bind(this, 1, 2, 3)\n\nbindDemo()\n\n// 输出了 1 2 3 ，却没有输出this ,那就证明 this 不是当作载荷传进去的\n```\n+ 2. 在被绑定的函数中主动打出 this\n```javascript\nfunction demo2 (...arg) {\n  console.log(this)\n  arg.forEach(item => {\n    console.log(item)\n  })\n}\n\nlet bindDemo2 = demo2.bind(this, 1, 2, 3)\n\nlet obj = { a: 1 }\n\nbindDemo2.call(obj)\n\n// 再使用.call调用，设法改变bindDemo2中的this，但是\n// 输出了 Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n//       1\n//       2\n//       3\n// 那就证明，在.call调用bindDemo2之前，bindDemo2中的this早就被规定好了。\n```\n+ 3. 那给bind 的第一个参数随便传一个呢，事实上你给bind的第一个参数传什么this就是什么，不管是什么类型( 例如传个 数字 11 )\n\n```javascript\nfunction demo3 () {\n  console.log(this) // 输出了了一个 Number 对象\n  // 当然你可以使用 valueOf() \n  console.log(this.valueOf()) // 输出了一个数字 11\n  // 你还可以使用 toString()\n  console.log(this.toString()) // 输出了一个字符串 '11'\n}\n\nlet bindDemo3 = demo3.bind(11)\n\nbindDemo3()\n```\n+ 4. 如果在jsx中使用bind给onClick绑定事件回调函数，那么第二个参数默认是event\n```javascript\nfunction Button () {\n  return (\n    <div onClick={clickDemo.bind(this, event, ...args)}></div>\n                              // 这里如果要传入this，和事件源对象，必须写this 和 event，2019年10月10日证明这种写法的错误的，因为event找不到\n    // 应该改为如下，先找个闭包把事件源对象保存一下\n    <div onClick={(e) => clickDemo.call(this, e, ...args)}></div>\n  )\n}\n\nfunction clickDemo (this, event, ...args) {\n  console.log(this)\n  console.log(event)\n  args.forEach(item => {\n    console.log(item)\n  })\n}\n```\n# 在 React中绑定事件回调函数的方法一般有三种（目前我知道的3种）\n\n第一种：在constructor去为事件回调函数绑定this，且将绑定好this的函数赋值给该函数本身(比较土，比较low)\n第二种：在真正的事件回调函数外面再包一层箭头函数 onClick={() => this.testClick()}，使用箭头函数中this去定义testClick中的this\n第三种：使用bind在定义事件回调函数的this（比较麻烦）\n\n+ 第一种：在constructor去为事件回调函数绑定this，且将绑定好this的函数赋值给该函数本身(比较土，比较low)\n```javascript\nclass Button extends React.Component {\n  constructor () {\n    super()\n    this.clickButton = this.clickButton.bind(this)\n  }\n  clickButton (...args) {\n    console.log(this)\n    args.forEach(item => {\n      console.log(item)\n    })\n  }\n\n  render () {\n    return (\n      <button onClick={this.clickButton}>点击按钮</button>\n    )\n  }\n}\n\nReactDOM.render(<Button />, document.getElementById('app'))\n\n// 输出:\n// Button {props: {…}, context: {…}, refs: {…}, updater: {…}, clickButton: ƒ, …}\n// Class {dispatchConfig: {…}, _targetInst: FiberNode, _dispatchListeners: ƒ, _dispatchInstances: FiberNode, nativeEvent: MouseEvent, …}\n```\n如果你想要传入event，那么还是得在事件绑定函数的时候用到\n`this.clickButton.bind(this, event)`\n输出：\n```javascript\n// Button {props: {…}, context: {…}, refs: {…}, updater: {…}, clickButton: ƒ, …}\n// Event {isTrusted: true, type: \"DOMContentLoaded\", target: document, currentTarget: null, eventPhase: 0, …}\n// Class {dispatchConfig: {…}, _targetInst: FiberNode, _dispatchListeners: ƒ, _dispatchInstances: FiberNode, nativeEvent: MouseEvent, …}\n```\n\n+ 第二种：在真正的事件回调函数外面再包一层箭头函数 onClick={() => this.testClick()}，使用箭头函数中this去定义testClick中的this\n\n```javascript\nclass Button extends React.Component {\n  constructor () {\n    super()\n  }\n\n  clickButton (...args) {\n    console.log(this)\n    args.forEach(item => {\n      console.log(item)\n    })\n  }\n\n  render () {\n    return (\n      <button onClick={() => this.clickButton()}>点击按钮</button>\n    )\n  }\n}\n\nReactDOM.render(<Button />, document.getElementById('app'))\n```\n\n+ 第三种：使用bind在定义事件回调函数的this（比较麻烦）\n```javascript\nlet args = [222, 333, 444]\nclass Button extends React.Component {\n  clickButton (...args) {\n    console.log(this) \n    args.forEach(item => {\n      console.log(item)\n    })\n  }\n\n  render () {\n    return (\n      <button onClick={this.clickButton.bind(this, event, ...args)}>点击按钮</button>\n    ) \n  }\n}\n\nReactDOM.render(<Button />, document.getElementById('app'))\n\n\n// 点击按钮输出：\n/*\n  Button {props: {…}, context: {…}, refs: {…}, updater: {…}, _reactInternalFiber: FiberNode, …}\n  Event {isTrusted: true, type: \"DOMContentLoaded\", target: document, currentTarget: null, eventPhase: 0, …}\n  222\n  333\n  444\n  Class {dispatchConfig: {…}, _targetInst: FiberNode, _dispatchListeners: ƒ, _dispatchInstances: FiberNode, nativeEvent: MouseEvent, …}\n*/\n```","slug":"React在事件绑定中bind的使用","published":1,"date":"2020-01-20T07:45:12.000Z","updated":"2020-01-20T07:45:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi2001ilktv4zy0jhe4"},{"title":"React学习-组件生命周期","date":"2019-09-02T14:00:00.000Z","_content":"\n# React的组件生命周期\n+ 从下面的图可以看出，这里嵌套组件渲染是递归实现的。父组件不管是在初次挂载还是更新，都需要把内部的孩子组件全部挂载或者更新完成之后，自己才完成挂载和更新\n<!-- more -->\n+ 特别要注意的是\n  componentWillReceiveProps\n  shouldComponentWillUpdate\n  componentWillUpdate\n  componentDidUpdate\n  这四者的执行顺序\n\n# 图解\n{% asset_img component_life.png React组件的生命周期 %}\n\n# 代码\n```javascript\nclass Child extends React.Component {\n  constructor (props) {\n    super(props);\n    console.log('Child constructor')\n  }\n\n  componentWillMount () { \n    console.log('Child componentWillMount')\n  }\n\n  componentDidMount (prevProps, prevState) {\n    console.log('Child componentDidMount')\n  }\n\n  componentWillReceiveProps (nextProp) {\n    console.log('Child componentWillReceiveProps')\n  }\n\n  shouldComponentUpdate (nextProps, nextState) {\n    console.log('Child shouldComponentUpdate')\n    return true\n  }\n\n  componentWillUpdate (nextProps, nextState) {\n    console.log('Child componentWillUpdate')\n  }\n\n  componentDidUpdate (prevProps, prevState) {\n    console.log('Child componentDidUpdate')\n  }\n\n  componentWillUnmount () {\n    console.log('Child componentWillUnmount')\n  }\n\n  render () {\n    console.log('Child render')\n\n    return <div>{this.props.test}</div>\n  }\n}\n\nclass App extends React.Component {\n  constructor () {\n    super()\n    this.state = {\n      test: new Date().toLocaleTimeString(),\n      count: 0,\n      clockTimer: null\n    }\n    console.log('App constructor')\n  }\n  \n  componentWillMount () {\n    console.log('App componentWillMount')\n  }\n\n  componentDidMount () {\n    console.log('App componentDidMount')\n\n    let {clockTimer, count} = this.state\n    clockTimer = setInterval(function () {\n      console.log(this.state.test)\n      if (count > 0) clearInterval(clockTimer)\n      this.setState({\n        test: new Date().toLocaleTimeString()\n          })\n          count++\n        }.bind(this), 1000)\n      }\n\n      shouldComponentUpdate (nextProps, nextState) {\n        console.log('App shouldComponentUpdate')\n        return true\n      }\n\n      componentWillUpdate (nextProps, nextState) {\n        console.log('App componentWillUpdate')\n      }\n\n      componentDidUpdate (prevProps, prevState) {\n        console.log('App componentDidUpdate')\n      }\n\n      render () {\n        console.log('App render')\n        let {test} = this.state\n\n        return (\n          <Child test={test}/>\n        )\n      }\n    }\n\n    ReactDOM.render(\n      <App />,\n      document.getElementById('app')\n    )\n```","source":"_posts/React学习-组件生命周期.md","raw":"---\ntitle: React学习-组件生命周期\ncategories:\n  - js\n  - React\n  - component\ntags:\n  - js\n  - React\n  - component\ndate: 2019-09-02 22:00:00\n---\n\n# React的组件生命周期\n+ 从下面的图可以看出，这里嵌套组件渲染是递归实现的。父组件不管是在初次挂载还是更新，都需要把内部的孩子组件全部挂载或者更新完成之后，自己才完成挂载和更新\n<!-- more -->\n+ 特别要注意的是\n  componentWillReceiveProps\n  shouldComponentWillUpdate\n  componentWillUpdate\n  componentDidUpdate\n  这四者的执行顺序\n\n# 图解\n{% asset_img component_life.png React组件的生命周期 %}\n\n# 代码\n```javascript\nclass Child extends React.Component {\n  constructor (props) {\n    super(props);\n    console.log('Child constructor')\n  }\n\n  componentWillMount () { \n    console.log('Child componentWillMount')\n  }\n\n  componentDidMount (prevProps, prevState) {\n    console.log('Child componentDidMount')\n  }\n\n  componentWillReceiveProps (nextProp) {\n    console.log('Child componentWillReceiveProps')\n  }\n\n  shouldComponentUpdate (nextProps, nextState) {\n    console.log('Child shouldComponentUpdate')\n    return true\n  }\n\n  componentWillUpdate (nextProps, nextState) {\n    console.log('Child componentWillUpdate')\n  }\n\n  componentDidUpdate (prevProps, prevState) {\n    console.log('Child componentDidUpdate')\n  }\n\n  componentWillUnmount () {\n    console.log('Child componentWillUnmount')\n  }\n\n  render () {\n    console.log('Child render')\n\n    return <div>{this.props.test}</div>\n  }\n}\n\nclass App extends React.Component {\n  constructor () {\n    super()\n    this.state = {\n      test: new Date().toLocaleTimeString(),\n      count: 0,\n      clockTimer: null\n    }\n    console.log('App constructor')\n  }\n  \n  componentWillMount () {\n    console.log('App componentWillMount')\n  }\n\n  componentDidMount () {\n    console.log('App componentDidMount')\n\n    let {clockTimer, count} = this.state\n    clockTimer = setInterval(function () {\n      console.log(this.state.test)\n      if (count > 0) clearInterval(clockTimer)\n      this.setState({\n        test: new Date().toLocaleTimeString()\n          })\n          count++\n        }.bind(this), 1000)\n      }\n\n      shouldComponentUpdate (nextProps, nextState) {\n        console.log('App shouldComponentUpdate')\n        return true\n      }\n\n      componentWillUpdate (nextProps, nextState) {\n        console.log('App componentWillUpdate')\n      }\n\n      componentDidUpdate (prevProps, prevState) {\n        console.log('App componentDidUpdate')\n      }\n\n      render () {\n        console.log('App render')\n        let {test} = this.state\n\n        return (\n          <Child test={test}/>\n        )\n      }\n    }\n\n    ReactDOM.render(\n      <App />,\n      document.getElementById('app')\n    )\n```","slug":"React学习-组件生命周期","published":1,"updated":"2020-01-20T07:45:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi3001nlktva2kj9x4n"},{"title":"React学习-高阶组件","_content":"\n### 高阶组件和套子组件的区别是：\n<!-- more -->\n1. 套子组件是把写在其内部标签结构内的jsx元素通过this.children的方式拿到，并且解析\n2. 高阶组件是函数执行后，返回一个组件类，函数的参数为你要渲染的组件类，这个函数会给你传递的组件类外面在加一层父组件我们用的时候实际上在用这个父组件，而且这个父组件以后会代理外部所要传给内部组件的props\n\n### 代码\n+ 给实际的ui组件类外加一层代理组件\nconnect.jsx\n```javascript\nimport React from 'react'\n\nexport default function connect(mapStateToProps, mapActionsToProps) {\n  return function connectHot(Component) {\n    return class Proxy extends React.Component {\n\n      state = {\n        n: 'nnnn',\n        m: 'mmmm'\n      }\n\n      componentDidMount() {\n        \n      }\n      \n      render() {\n        return <Component {...this.state} {...this.props}></Component>\n      }\n    }\n  }\n}\n```\n+ 实际的ui组件\n```javascript\nimport React, { Component } from 'react'\nimport connect from './connect'  // 导入connect 函数\n\nclass Vote extends Component {\n  render() {\n    console.log('vote-component', this)\n    return (\n      <div>\n        <div>vote 组件</div>\n        { this.props.children }\n      </div>\n    )\n  }\n}\n\nexport default connect()(Vote) \n// 返回的是一个Proxy组件，里面包裹了Vote组件\n```\n+ index.js\n```javascript\nimport React from 'react'\nimport { render } from 'react-dom'\nimport Vote from './components/higher-comp/vote' // 这里引入的其实是一个Proxy组件，里面包裹了 Vote 组件\n\nrender(\n  <Vote c={'ccc'}>\n    <Vote c={'ccc'}>\n\n    </Vote>\n  </Vote>,\n  document.getElementById('root')\n)\n```\n\n# 图解\n{% asset_img react_higher_component1.png 高阶组件 %}\n{% asset_img react_higher_component2.png 高阶组件 %}","source":"_posts/React学习-高阶组件.md","raw":"---\ntitle: React学习-高阶组件\ncategories:\n  - js\n  - React\n  - component\ntags:\n  - js\n  - React\n  - component\n---\n\n### 高阶组件和套子组件的区别是：\n<!-- more -->\n1. 套子组件是把写在其内部标签结构内的jsx元素通过this.children的方式拿到，并且解析\n2. 高阶组件是函数执行后，返回一个组件类，函数的参数为你要渲染的组件类，这个函数会给你传递的组件类外面在加一层父组件我们用的时候实际上在用这个父组件，而且这个父组件以后会代理外部所要传给内部组件的props\n\n### 代码\n+ 给实际的ui组件类外加一层代理组件\nconnect.jsx\n```javascript\nimport React from 'react'\n\nexport default function connect(mapStateToProps, mapActionsToProps) {\n  return function connectHot(Component) {\n    return class Proxy extends React.Component {\n\n      state = {\n        n: 'nnnn',\n        m: 'mmmm'\n      }\n\n      componentDidMount() {\n        \n      }\n      \n      render() {\n        return <Component {...this.state} {...this.props}></Component>\n      }\n    }\n  }\n}\n```\n+ 实际的ui组件\n```javascript\nimport React, { Component } from 'react'\nimport connect from './connect'  // 导入connect 函数\n\nclass Vote extends Component {\n  render() {\n    console.log('vote-component', this)\n    return (\n      <div>\n        <div>vote 组件</div>\n        { this.props.children }\n      </div>\n    )\n  }\n}\n\nexport default connect()(Vote) \n// 返回的是一个Proxy组件，里面包裹了Vote组件\n```\n+ index.js\n```javascript\nimport React from 'react'\nimport { render } from 'react-dom'\nimport Vote from './components/higher-comp/vote' // 这里引入的其实是一个Proxy组件，里面包裹了 Vote 组件\n\nrender(\n  <Vote c={'ccc'}>\n    <Vote c={'ccc'}>\n\n    </Vote>\n  </Vote>,\n  document.getElementById('root')\n)\n```\n\n# 图解\n{% asset_img react_higher_component1.png 高阶组件 %}\n{% asset_img react_higher_component2.png 高阶组件 %}","slug":"React学习-高阶组件","published":1,"date":"2020-01-20T07:45:12.000Z","updated":"2020-01-20T07:45:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi4001plktvgvg3gg82"},{"title":"谷歌浏览器访问助手安装","abbrlink":"6b5a8be2","date":"2019-04-25T02:43:00.000Z","_content":"# 在给同事安装谷歌浏览器插件的时候遇到的问题\n<!-- more -->\n<font color=\"#cccccc\">本来想装一个vue-devtools,但是我们知道这个插件虽然在谷歌自带的商店里面有，但是没有谷歌访问助手，这个商店是访问不到的，所有先要安装谷歌访问助手。</font>\n+ 1、下载[谷歌访问助手](https://dlc2.pconline.com.cn/filedown_519594_12218443/PRxl0hdm/chrome.zip)\n  将下载的文件解压得到一个扩展名为`.crx`的文件，先将这个文件直接拖到谷歌扩展程序窗口中，看看能不能安装成功，如果能，直接跳到第3步。如果不能，将这个文件的扩展名改为`.zip`，再进行解压，得到一个文件夹，里面包含了好多文件夹和文件。\n+ 2、安装\n  打开谷歌浏览器的更多工具 > 扩展程序，并且打开开发者模式按钮，点击左侧的加载已解压的扩展程序，找到刚刚解压完成的文件夹，成功！\n+ 3、访问谷歌网上应用商店\n  找到谷歌商店，点击，发现可以打开了，在搜索框输入vue，就会在右侧找到Vue.js devtools，点击添加至Chrome即可。\n","source":"_posts/chrome-plugins.md","raw":"---\ntitle: 谷歌浏览器访问助手安装\ncategories:\n  - 安装\ntags:\n  - 闲杂\n  - Install\nabbrlink: 6b5a8be2\ndate: 2019-04-25 10:43:00\n---\n# 在给同事安装谷歌浏览器插件的时候遇到的问题\n<!-- more -->\n<font color=\"#cccccc\">本来想装一个vue-devtools,但是我们知道这个插件虽然在谷歌自带的商店里面有，但是没有谷歌访问助手，这个商店是访问不到的，所有先要安装谷歌访问助手。</font>\n+ 1、下载[谷歌访问助手](https://dlc2.pconline.com.cn/filedown_519594_12218443/PRxl0hdm/chrome.zip)\n  将下载的文件解压得到一个扩展名为`.crx`的文件，先将这个文件直接拖到谷歌扩展程序窗口中，看看能不能安装成功，如果能，直接跳到第3步。如果不能，将这个文件的扩展名改为`.zip`，再进行解压，得到一个文件夹，里面包含了好多文件夹和文件。\n+ 2、安装\n  打开谷歌浏览器的更多工具 > 扩展程序，并且打开开发者模式按钮，点击左侧的加载已解压的扩展程序，找到刚刚解压完成的文件夹，成功！\n+ 3、访问谷歌网上应用商店\n  找到谷歌商店，点击，发现可以打开了，在搜索框输入vue，就会在右侧找到Vue.js devtools，点击添加至Chrome即可。\n","slug":"chrome-plugins","published":1,"updated":"2020-01-20T07:45:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi6001tlktvwgpqjbp7"},{"title":"async和await的妙用-异步方法同步执行","date":"2019-07-08T02:49:30.000Z","_content":"\n# 在项目中常常需要在调用接口前后执行一些操作，来对一系列的异步方法执行顺序进行控制\n<!-- more -->\n我们一般的方法是通过回调函数，在调用接口成功的回调函数中执行一些我们之后的操作\n1. 如果不使用promise，那就比较恐怖了，常见的就是普通回调的地狱\n2. 如果使用了promise对象的`.then()`方法控制异步执行，虽然可以控制异步方法的执行顺序，但是会将整个业务流程打散，我们要想理清整个业务流程就得从一个.then()中去找下一个业务流程节点\n3. 利用async-await保证方法执行流程的完整性，这样在一个async方法中就可以清晰的看见整个业务流程的执行顺序\n\n# 代码对比\n业务流程：我们在点击提交之后：\n(1) 先去判断用户有没有输入评价（评价可选字段，但是我们希望让用户输入），如果没有，那么弹出确定框提示用户还没有输入评价内容，是否确定提交，\n(2.1) 如果用户点确定，调用save接口且确认框消失\n(2.2) 如果用户点取消，不调用save且确认框消失\n(3) save调用成功，通知工单列表组件，再次获取新的工单列表\n(4) 详情框消失\n\n2. promise对象的.then()方法实现方式\n```javascript \n// 评价弹框组件\nmethods: {\n  submitComment () {\n    if (this.comment == '') {\n      // (1)\n      this.$confirm('您还没有输入评价内容，确认提交吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消'\n      }).then(() => {\n        // (2.1)\n        this.dealMark()\n      }).catch(() => { // (2.2) 点击了确认框的取消，确认框会单纯的消失 })\n    }\n  },\n  dealMark () {\n    saveComment().then(res = > {\n      if (res.retCode == 200) {\n        this.$message({\n          type: 'success',\n          message: '评价成功！'\n        })\n        // (3)\n        this.$emit('commentCompleted') \n      } else {\n        this.$message({\n          type: 'warning',\n          message: '评价失败，请稍后重试'\n        })\n      }\n      // (4)\n      this.dialogFormVisible = false\n    }).catch(err => {\n      this.$message({\n        type: 'error',\n        message: '系统异常'\n      })\n      this.dialogFormVisible = false\n    })\n    // this.dialogFormVisible = false // 弹框会在saveComment.thne()方法执行之前就关闭\n  }\n}\n```\n可以看出(3)和(4)步骤等于放在了(2.1)步骤里面执行的，缺点：如果整个业务流程非常长且复杂，那么就势必会有很多的步骤需要嵌套在前一个步骤中，虽然整个流程是整个一颗树型结构，单这颗树却是打散的，你很难在一个完整的代码块中看清整个流程。\n\n3. async和await的实现方式\n+ 带try catch 写法\n```javascript\n// 评价弹框组件\nmethods: {\n  async submitComment () { // 这里的async 是针对里里面的await而言的，里面要使用await去执行await目标promise对象.then()的回调函数，外部必须在函数名前面加async，别人调它还是this.submitComment()\n    if (this.comment == '') {\n      try {\n        // 这个代码块中相当于.then(res => {})回调函数的函数体\n         // (1)\n        await this.$confirm('您还没有输入评价内容，确认提交吗？', '提示', {\n          confirmButtonText: '确定',\n          cancelButtonText: '取消'\n        }) // 这里的await是正对this.$confirm()返回的promise对象的.then()方法而言的\n        try {\n          // (2.1)\n          let { commentSuccess } = await this.dealMark()\n          if (commentSuccess) {\n            // (3)\n            this.$emit('commentCompleted')\n          } \n        } \n      } \n    }\n    // (2.2) (4)\n    this.dialogFormVisible = false \n  },\n  dealMark () {\n    return new Promise((resolve, reject) => {\n      saveComment().then(res => {\n        if (res.retCode == 200) {\n          this.$message({\n            type: 'success',\n            message: '评价成功！'\n          })\n          resolve({\n            commentSuccess: true\n          })\n        } else {\n          this.$message({\n            type: 'warning',\n            message: '评价失败，请稍后重试'\n          })\n          resolve({\n            commentSuccess: false\n          })\n        }\n      }).catch(err => {\n        this.$message({\n          type: 'error',\n          message: '系统异常'\n        })\n        reject()\n      })\n    })\n  }\n}\n```","source":"_posts/async和await的妙用-异步方法同步执行.md","raw":"---\ntitle: async和await的妙用-异步方法同步执行\ndate: 2019-07-08 10:49:30\ncategories:\n  - js\n  - async-await\ntags:\n  - js\n  - async-await\n---\n\n# 在项目中常常需要在调用接口前后执行一些操作，来对一系列的异步方法执行顺序进行控制\n<!-- more -->\n我们一般的方法是通过回调函数，在调用接口成功的回调函数中执行一些我们之后的操作\n1. 如果不使用promise，那就比较恐怖了，常见的就是普通回调的地狱\n2. 如果使用了promise对象的`.then()`方法控制异步执行，虽然可以控制异步方法的执行顺序，但是会将整个业务流程打散，我们要想理清整个业务流程就得从一个.then()中去找下一个业务流程节点\n3. 利用async-await保证方法执行流程的完整性，这样在一个async方法中就可以清晰的看见整个业务流程的执行顺序\n\n# 代码对比\n业务流程：我们在点击提交之后：\n(1) 先去判断用户有没有输入评价（评价可选字段，但是我们希望让用户输入），如果没有，那么弹出确定框提示用户还没有输入评价内容，是否确定提交，\n(2.1) 如果用户点确定，调用save接口且确认框消失\n(2.2) 如果用户点取消，不调用save且确认框消失\n(3) save调用成功，通知工单列表组件，再次获取新的工单列表\n(4) 详情框消失\n\n2. promise对象的.then()方法实现方式\n```javascript \n// 评价弹框组件\nmethods: {\n  submitComment () {\n    if (this.comment == '') {\n      // (1)\n      this.$confirm('您还没有输入评价内容，确认提交吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消'\n      }).then(() => {\n        // (2.1)\n        this.dealMark()\n      }).catch(() => { // (2.2) 点击了确认框的取消，确认框会单纯的消失 })\n    }\n  },\n  dealMark () {\n    saveComment().then(res = > {\n      if (res.retCode == 200) {\n        this.$message({\n          type: 'success',\n          message: '评价成功！'\n        })\n        // (3)\n        this.$emit('commentCompleted') \n      } else {\n        this.$message({\n          type: 'warning',\n          message: '评价失败，请稍后重试'\n        })\n      }\n      // (4)\n      this.dialogFormVisible = false\n    }).catch(err => {\n      this.$message({\n        type: 'error',\n        message: '系统异常'\n      })\n      this.dialogFormVisible = false\n    })\n    // this.dialogFormVisible = false // 弹框会在saveComment.thne()方法执行之前就关闭\n  }\n}\n```\n可以看出(3)和(4)步骤等于放在了(2.1)步骤里面执行的，缺点：如果整个业务流程非常长且复杂，那么就势必会有很多的步骤需要嵌套在前一个步骤中，虽然整个流程是整个一颗树型结构，单这颗树却是打散的，你很难在一个完整的代码块中看清整个流程。\n\n3. async和await的实现方式\n+ 带try catch 写法\n```javascript\n// 评价弹框组件\nmethods: {\n  async submitComment () { // 这里的async 是针对里里面的await而言的，里面要使用await去执行await目标promise对象.then()的回调函数，外部必须在函数名前面加async，别人调它还是this.submitComment()\n    if (this.comment == '') {\n      try {\n        // 这个代码块中相当于.then(res => {})回调函数的函数体\n         // (1)\n        await this.$confirm('您还没有输入评价内容，确认提交吗？', '提示', {\n          confirmButtonText: '确定',\n          cancelButtonText: '取消'\n        }) // 这里的await是正对this.$confirm()返回的promise对象的.then()方法而言的\n        try {\n          // (2.1)\n          let { commentSuccess } = await this.dealMark()\n          if (commentSuccess) {\n            // (3)\n            this.$emit('commentCompleted')\n          } \n        } \n      } \n    }\n    // (2.2) (4)\n    this.dialogFormVisible = false \n  },\n  dealMark () {\n    return new Promise((resolve, reject) => {\n      saveComment().then(res => {\n        if (res.retCode == 200) {\n          this.$message({\n            type: 'success',\n            message: '评价成功！'\n          })\n          resolve({\n            commentSuccess: true\n          })\n        } else {\n          this.$message({\n            type: 'warning',\n            message: '评价失败，请稍后重试'\n          })\n          resolve({\n            commentSuccess: false\n          })\n        }\n      }).catch(err => {\n        this.$message({\n          type: 'error',\n          message: '系统异常'\n        })\n        reject()\n      })\n    })\n  }\n}\n```","slug":"async和await的妙用-异步方法同步执行","published":1,"updated":"2020-01-20T07:45:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi7001wlktv89xzkwu0"},{"title":"http/tcp","date":"2019-07-08T00:55:39.000Z","_content":"\n# TCP三次握手\n首先要知道这几个名词的含义：\n\nSYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。\nACK (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方\n<!-- more -->\n### method字段不同值：\n+ GET - 访问服务器资源\n+ POST - 向服务器发送要修改的数据\n+ HEAD - 获取服务器文档的首部\n+ PUT - 向服务器上传资源\n+ DELETE - 删除服务器资源\n### 常见的状态码段代表的含义\n\n状态码段 | 含义 \n-|-\n1xx | 表示HTTP请求已经接受，继续处理请求\n2xx\t| 表示HTTP请求已经处理完成\n3xx\t| 表示把请求访问的URL重定向到其他目录\n4xx\t| 表示客户端出现错误\n5xx\t| 表示服务端出现错误\n\n### 常见的状态码的含义\n\n状态码 | 含义\n-|-\n200 | OK/请求已经正常处理完毕\n301 | /请求永久重定向\n302 | /请求临时重定向\n304 | /请求被重定向到客户端本地缓存\n400 | /客户端请求存在语法错误\n401 | /客户端请求没有经过授权\n403 | /客户端的请求被服务器拒绝，一般为客户端没有访问权限\n404 | /客户端请求的URL在服务端不存在","source":"_posts/http-tcp.md","raw":"---\ntitle: http/tcp\ndate: 2019-07-08 08:55:39\ntags:\n - http\ncategories: \n - http\n---\n\n# TCP三次握手\n首先要知道这几个名词的含义：\n\nSYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。\nACK (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方\n<!-- more -->\n### method字段不同值：\n+ GET - 访问服务器资源\n+ POST - 向服务器发送要修改的数据\n+ HEAD - 获取服务器文档的首部\n+ PUT - 向服务器上传资源\n+ DELETE - 删除服务器资源\n### 常见的状态码段代表的含义\n\n状态码段 | 含义 \n-|-\n1xx | 表示HTTP请求已经接受，继续处理请求\n2xx\t| 表示HTTP请求已经处理完成\n3xx\t| 表示把请求访问的URL重定向到其他目录\n4xx\t| 表示客户端出现错误\n5xx\t| 表示服务端出现错误\n\n### 常见的状态码的含义\n\n状态码 | 含义\n-|-\n200 | OK/请求已经正常处理完毕\n301 | /请求永久重定向\n302 | /请求临时重定向\n304 | /请求被重定向到客户端本地缓存\n400 | /客户端请求存在语法错误\n401 | /客户端请求没有经过授权\n403 | /客户端的请求被服务器拒绝，一般为客户端没有访问权限\n404 | /客户端请求的URL在服务端不存在","slug":"http-tcp","published":1,"updated":"2020-01-20T07:45:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi80021lktv7r5me15q"},{"title":"css技巧总结","date":"2019-05-10T10:00:00.000Z","_content":"\n## 垂直水平居中\n<!-- more -->\n  + 使用css3中的transform(内容高度和宽度都可以是自动)\n```css\n.parent\n  position relative\n  .children \n    position absolute\n    top 50%\n    left 50%\n    transform translate(-50%, -50%)\n    width 不固定\n    height 也可以不固定\n```","source":"_posts/css技巧总结.md","raw":"---\ntitle: css技巧总结\ncategories:\n - html\n - css\ntags: \n - html\n - css\ndate: 2019-05-10 18:00:00\n---\n\n## 垂直水平居中\n<!-- more -->\n  + 使用css3中的transform(内容高度和宽度都可以是自动)\n```css\n.parent\n  position relative\n  .children \n    position absolute\n    top 50%\n    left 50%\n    transform translate(-50%, -50%)\n    width 不固定\n    height 也可以不固定\n```","slug":"css技巧总结","published":1,"updated":"2020-01-20T07:45:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gi90023lktvr7jimmq9"},{"title":"ie下vue问题总结","_content":"# 经过测试最高版本的ie也难以完全兼容ie\n+ 路由规则匹配中，不能使用动态导入views组件\n+ element-ui的table在ie下不能自动沾满容器\n+ ie9不支持flex","source":"_posts/ie下vue问题总结.md","raw":"---\ntitle: ie下vue问题总结\ntags:\n  - vue\n  - ie\ncategories:\n  - vue\n  - ie\n---\n# 经过测试最高版本的ie也难以完全兼容ie\n+ 路由规则匹配中，不能使用动态导入views组件\n+ element-ui的table在ie下不能自动沾满容器\n+ ie9不支持flex","slug":"ie下vue问题总结","published":1,"date":"2020-01-20T07:45:08.000Z","updated":"2020-01-20T07:45:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gia0026lktv35ddnwzr"},{"title":"js继承2","_content":"\n# 首先写出ES6的继承\n<!-- more -->\n```javascript\nclass Animal {\n  constructor () {\n    this.z = 'zzz'\n  }\n  getAnimal () {\n    console.log(\"animal\")\n  }\n}\nclass Cat extends Animal {\n  constructor () {\n    super();\n    this.x = 'xx';\n    this.y = 'yy';\n  }\n  getCat () {\n    console.log('cat')\n  }\n}\nconsole.log(new Cat());\n```\n{% asset_img extends.png ES6的继承 %}\n# ES5实现继承\n```javascript\nfunction Animal () {\n  this.z = 'zzz'\n}\nAnimal.prototype.getAnimal = function () {\n  console.log(\"animal\")\n}\nfunction Cat () {\n  Object.assign(this, new Animal); // 要注意的是，Object.assign() 只可以浅复制可枚举对象，\n  // 所以this.__proto__是不会被改变的，但是Animal实例对象中的z会被加入这里的this中\n  // 在new实例对象的时候， this一被创建就被会被执行this.__proto__ = Cat.prototype\n  this.x = 'xxx';\n  this.y = 'yyy';\n}\nCat.prototype.getCat = function () {\n  console.log(\"cat\")\n}\nCat.prototype.__proto__ = Animal.prototype\nconsole.log(new Cat())\n```\n上述ES6创建和ES5创建对象执行的结果是一模一样","source":"_posts/js继承2.md","raw":"---\ntitle: js继承2\ncategories:\n  - js\n  - 继承\ntags:\n  - js\n  - 继承\n---\n\n# 首先写出ES6的继承\n<!-- more -->\n```javascript\nclass Animal {\n  constructor () {\n    this.z = 'zzz'\n  }\n  getAnimal () {\n    console.log(\"animal\")\n  }\n}\nclass Cat extends Animal {\n  constructor () {\n    super();\n    this.x = 'xx';\n    this.y = 'yy';\n  }\n  getCat () {\n    console.log('cat')\n  }\n}\nconsole.log(new Cat());\n```\n{% asset_img extends.png ES6的继承 %}\n# ES5实现继承\n```javascript\nfunction Animal () {\n  this.z = 'zzz'\n}\nAnimal.prototype.getAnimal = function () {\n  console.log(\"animal\")\n}\nfunction Cat () {\n  Object.assign(this, new Animal); // 要注意的是，Object.assign() 只可以浅复制可枚举对象，\n  // 所以this.__proto__是不会被改变的，但是Animal实例对象中的z会被加入这里的this中\n  // 在new实例对象的时候， this一被创建就被会被执行this.__proto__ = Cat.prototype\n  this.x = 'xxx';\n  this.y = 'yyy';\n}\nCat.prototype.getCat = function () {\n  console.log(\"cat\")\n}\nCat.prototype.__proto__ = Animal.prototype\nconsole.log(new Cat())\n```\n上述ES6创建和ES5创建对象执行的结果是一模一样","slug":"js继承2","published":1,"date":"2020-01-20T07:45:09.000Z","updated":"2020-01-20T07:45:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gic002alktvxf0z3qxy"},{"title":"js知识点集合","date":"2019-05-31T16:00:00.000Z","_content":"#### 检测数组的几种方式：\n<!-- more -->\n1. Array.isArray(); // es5\n2. toString.call([]) // [Object Array] 这只是一个字符串\n3. var arr = []\n  console.log(arr.contructor.name) // Array\n4. console.log([] instanceof Array) // 检测某个对象是不是属于某个类或者构造函数\n\n拓展：\n toString.call(/[0-9]/) // [Object RegExp] // 判断正则表达式对象\n```javascript\n// 编写一个函数来判断输入对象的类型\nfunction check (obj) {\n  return toString.call(obj).split(' ').pop().slice(0, -1)\n}\n```\n\n#### javascript 中实现继承的几种方式\n+ 原型链继承\n+ 借用构造函数继承\n```javascript\nfunction Animal () {\n  this.name = 'masia',\n  this.getName = function () {\n    console.log(this.name)\n  }\n}\nfunction Cat () {\n  Animal.call(this) \n  this.age = 18\n}\nvar cat = new Cat()\nconsole.log(cat)\nconsole.log(cat.name) // 'masia'\ncat.getName() // 'masia'\n```\n+ 原型+构造函数继承\n+ 寄生式继承(工厂模式的变种)\n```javascript\nfunction Japanese (name, language) {\n  this.name = name\n  this.language = language\n}\nfunction CreateChinese (name, language) {\n  var obj = {};\n  Japanese.call(obj, name, language)\n  return obj\n}\nconst chinese = CreateChinese('masia', 'chinese')\nconsole.log(chinese)\nconsole.log(chinese.constructor) // Object\n```\n#### 动态原型\n在构造函数中，通过传入的属性来判断，是否让他的原型拥有方法的方式\n```javascript\nfunction Person (name, work) {\n  this.name = name;\n  work && Person.prototype.woking = function () {\n    console.log(work)\n  }\n}\nvar obj = new Person('masia')\nvar obj2 = new Person('masia', 'font-engineer')\n```\n","source":"_posts/js知识点集合.md","raw":"---\ntitle: js知识点集合\ncategories: \n  - js\ntags: \n - js\ndate: 2019-06-01\n---\n#### 检测数组的几种方式：\n<!-- more -->\n1. Array.isArray(); // es5\n2. toString.call([]) // [Object Array] 这只是一个字符串\n3. var arr = []\n  console.log(arr.contructor.name) // Array\n4. console.log([] instanceof Array) // 检测某个对象是不是属于某个类或者构造函数\n\n拓展：\n toString.call(/[0-9]/) // [Object RegExp] // 判断正则表达式对象\n```javascript\n// 编写一个函数来判断输入对象的类型\nfunction check (obj) {\n  return toString.call(obj).split(' ').pop().slice(0, -1)\n}\n```\n\n#### javascript 中实现继承的几种方式\n+ 原型链继承\n+ 借用构造函数继承\n```javascript\nfunction Animal () {\n  this.name = 'masia',\n  this.getName = function () {\n    console.log(this.name)\n  }\n}\nfunction Cat () {\n  Animal.call(this) \n  this.age = 18\n}\nvar cat = new Cat()\nconsole.log(cat)\nconsole.log(cat.name) // 'masia'\ncat.getName() // 'masia'\n```\n+ 原型+构造函数继承\n+ 寄生式继承(工厂模式的变种)\n```javascript\nfunction Japanese (name, language) {\n  this.name = name\n  this.language = language\n}\nfunction CreateChinese (name, language) {\n  var obj = {};\n  Japanese.call(obj, name, language)\n  return obj\n}\nconst chinese = CreateChinese('masia', 'chinese')\nconsole.log(chinese)\nconsole.log(chinese.constructor) // Object\n```\n#### 动态原型\n在构造函数中，通过传入的属性来判断，是否让他的原型拥有方法的方式\n```javascript\nfunction Person (name, work) {\n  this.name = name;\n  work && Person.prototype.woking = function () {\n    console.log(work)\n  }\n}\nvar obj = new Person('masia')\nvar obj2 = new Person('masia', 'font-engineer')\n```\n","slug":"js知识点集合","published":1,"updated":"2020-01-20T07:45:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gid002dlktvrqfr81nt"},{"title":"js设计模式","date":"2019-05-15T02:00:00.000Z","_content":"\n## 定义类或者对象\n<!-- more -->\n1. 工厂模式\n\n  + 创建对象\n```javascript\nvar person = new Object(); // new Object() 和 new Object 是一样的效果\nperson.id = 1;\nperson.name = 'masia';\nperson.showName = function () {\n  alert(this.name);\n}\n```\n  + 创建多个对象\n```javascript\nfunction createPerson (id, name) {\n  var obj = new Object;\n  obj.id = id;\n  obj.name = name;\n  obj.showName = function () { // 每次创建一个实例，都要在实例中保存一个showName方法，在实例对象中复制了一份showName，为了解决这个重复复制函数的问题，可以使用给showName这个属性复制一个引用。\n  // obj.showName = outerShowName;\n    alert(this.name); // 这个this是obj\n  }\n  return obj;\n}\nfunction outerShowName () {\n  alert(this.name)\n}\nvar person1 = createPerson('1', 'masia');\nvar person2 = createPerson('2', 'laoliu'); \n```\n2. 构造函数方式\n```javascript\nfunction Person (id, name) {\n  this.id = id;\n  this.name = name;\n  this.showName = function () { // 这样写，在实例中也是会重复生成函数的，所以也可以使用引用赋值的方法，将一个函数的引用赋值给showName这个属性\n  // this.showName = outerShowName;\n    alert(this.name)\n  }\n}\n\nvar person1 = new Person('1', 'masia');\nvar person2 = new Person('2', 'laoliu');\n```\n3. 原型与构造函数混合方式\n```javascript\nfucntion Person (id, name) {\n  this.id = id;\n  this.name = name;\n}\nPerson.prototype.showName = function () {\n  alert(this.name);\n}\n// 这样的方式，在创建构造函数的时候，showName保存在构造函数的原型链中，没有浪费内存空间，不同的实例通过隐式原型链来调用showName方法。\n```\n+ 引入知识点：对象的方法借用\n```javascript\nvar obj = {\n  name: 'masia',\n  age: 19,\n  getName: function () {\n    console.log(this.name)\n  },\n  modifyInfo: function (newName, newAge) {\n    this.name = newName\n    this.age = newAge\n  }\n}\nvar obj2 = {\n  name: 'laoliu',\n  age: 23\n}\n// obj2借用obj1中的方法，无参数时：\nobj.getName.call(obj2)\nobj.getName.apply(obj2)\n// obj2借用obj1中的方法，有参数时：\nobj.modifyInfo.call(obj2, 'Lawrence', 25) // 使用call，依次传参\nobj.modifyInfo.apply(obj2, ['Lawrence', 25]) // 使用apply, 传入一个参数数组\n```","source":"_posts/js设计模式.md","raw":"---\ntitle: js设计模式\ncategories: \n  - js\n  - 设计模式\n  - 面向对象\ntags: \n   - js\n   - 设计模式\n   - 面向对象\ndate: 2019-05-15 10:00\n---\n\n## 定义类或者对象\n<!-- more -->\n1. 工厂模式\n\n  + 创建对象\n```javascript\nvar person = new Object(); // new Object() 和 new Object 是一样的效果\nperson.id = 1;\nperson.name = 'masia';\nperson.showName = function () {\n  alert(this.name);\n}\n```\n  + 创建多个对象\n```javascript\nfunction createPerson (id, name) {\n  var obj = new Object;\n  obj.id = id;\n  obj.name = name;\n  obj.showName = function () { // 每次创建一个实例，都要在实例中保存一个showName方法，在实例对象中复制了一份showName，为了解决这个重复复制函数的问题，可以使用给showName这个属性复制一个引用。\n  // obj.showName = outerShowName;\n    alert(this.name); // 这个this是obj\n  }\n  return obj;\n}\nfunction outerShowName () {\n  alert(this.name)\n}\nvar person1 = createPerson('1', 'masia');\nvar person2 = createPerson('2', 'laoliu'); \n```\n2. 构造函数方式\n```javascript\nfunction Person (id, name) {\n  this.id = id;\n  this.name = name;\n  this.showName = function () { // 这样写，在实例中也是会重复生成函数的，所以也可以使用引用赋值的方法，将一个函数的引用赋值给showName这个属性\n  // this.showName = outerShowName;\n    alert(this.name)\n  }\n}\n\nvar person1 = new Person('1', 'masia');\nvar person2 = new Person('2', 'laoliu');\n```\n3. 原型与构造函数混合方式\n```javascript\nfucntion Person (id, name) {\n  this.id = id;\n  this.name = name;\n}\nPerson.prototype.showName = function () {\n  alert(this.name);\n}\n// 这样的方式，在创建构造函数的时候，showName保存在构造函数的原型链中，没有浪费内存空间，不同的实例通过隐式原型链来调用showName方法。\n```\n+ 引入知识点：对象的方法借用\n```javascript\nvar obj = {\n  name: 'masia',\n  age: 19,\n  getName: function () {\n    console.log(this.name)\n  },\n  modifyInfo: function (newName, newAge) {\n    this.name = newName\n    this.age = newAge\n  }\n}\nvar obj2 = {\n  name: 'laoliu',\n  age: 23\n}\n// obj2借用obj1中的方法，无参数时：\nobj.getName.call(obj2)\nobj.getName.apply(obj2)\n// obj2借用obj1中的方法，有参数时：\nobj.modifyInfo.call(obj2, 'Lawrence', 25) // 使用call，依次传参\nobj.modifyInfo.apply(obj2, ['Lawrence', 25]) // 使用apply, 传入一个参数数组\n```","slug":"js设计模式","published":1,"updated":"2020-01-20T07:45:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gie002glktvzjy48kmq"},{"title":"数组和对象的深度复制","date":"2019-04-29T06:00:00.000Z","_content":"\n### 遍历数组的方法\n1. for循环\n2. 使用for in 或者 for of，注意二者区别\n3. 使用forEach\n4. 使用map","source":"_posts/js遍历数组的方法.md","raw":"---\ntitle: 数组和对象的深度复制\ncategories:\n  - 数组和对象的深度复制\ntags:\n  - 数组和对象的深度复制\ndate: 2019-04-29 14:00:00\n---\n\n### 遍历数组的方法\n1. for循环\n2. 使用for in 或者 for of，注意二者区别\n3. 使用forEach\n4. 使用map","slug":"js遍历数组的方法","published":1,"updated":"2020-01-20T07:45:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gie002ilktvwb60j5xt"},{"title":"let关键字使用","abbrlink":"13f9823b","date":"2019-04-28T02:00:00.000Z","_content":"\n### let关键字定义之后不能修改，let关键字有作用域限制\n<!-- more -->\n```html\n<div class=\"nav\">\n  <button>选项一</button>\n  <button>选项二</button>\n  <button>选项三</button>\n</div>\n<div class=\"con\">\n  <p>内容一</p>\n  <p>内容二</p>\n  <p>内容三</p>\n</div>\n```\n\n```javascript\n// 使用常规的方式，变量声明和定义全部使用var关键字\nvar buttons = document.querySelectorAll('button');\nvar ps = document.querySelectorAll('p');\n\nfor (var i = 0; i < buttons.length; i ++) {\n  buttons[i].index = i;\n  buttons[i].onclick = function () {\n    console.log(this.index); // 在这里只能通过自定义属性index来拿到外部循环的i\n    for (var i = 0; i < buttons.length; i ++) {\n      buttons[i].className = '';\n      ps [i].className = '';\n    }\n    this.className = 'active';\n    ps[this.index].className = 'active'\n  }\n}\n\n\n// 使用const关键限制i的作用域\nvar buttons = document.querySelectorAll('button');\nvar ps = document.querySelectorAll('p')\n\nfor (let i = 0; i < buttons.length; i ++) {\n  buttons[i].onclick = function () {\n    console.log(i) // 这里可以拿到循环中的i\n    for (let i = 0; i < buttons.length; i ++) {\n      buttons[i].className = '';\n      ps[i].className = '';\n    }\n    this.className = 'active';\n    ps[i].className = 'active';\n  }\n\n}\n```","source":"_posts/let关键字使用.md","raw":"---\ntitle: let关键字使用\ncategories:\n  - ES6\ntags:\n  - ES6\nabbrlink: 13f9823b\ndate: 2019-04-28 10:00:00\n---\n\n### let关键字定义之后不能修改，let关键字有作用域限制\n<!-- more -->\n```html\n<div class=\"nav\">\n  <button>选项一</button>\n  <button>选项二</button>\n  <button>选项三</button>\n</div>\n<div class=\"con\">\n  <p>内容一</p>\n  <p>内容二</p>\n  <p>内容三</p>\n</div>\n```\n\n```javascript\n// 使用常规的方式，变量声明和定义全部使用var关键字\nvar buttons = document.querySelectorAll('button');\nvar ps = document.querySelectorAll('p');\n\nfor (var i = 0; i < buttons.length; i ++) {\n  buttons[i].index = i;\n  buttons[i].onclick = function () {\n    console.log(this.index); // 在这里只能通过自定义属性index来拿到外部循环的i\n    for (var i = 0; i < buttons.length; i ++) {\n      buttons[i].className = '';\n      ps [i].className = '';\n    }\n    this.className = 'active';\n    ps[this.index].className = 'active'\n  }\n}\n\n\n// 使用const关键限制i的作用域\nvar buttons = document.querySelectorAll('button');\nvar ps = document.querySelectorAll('p')\n\nfor (let i = 0; i < buttons.length; i ++) {\n  buttons[i].onclick = function () {\n    console.log(i) // 这里可以拿到循环中的i\n    for (let i = 0; i < buttons.length; i ++) {\n      buttons[i].className = '';\n      ps[i].className = '';\n    }\n    this.className = 'active';\n    ps[i].className = 'active';\n  }\n\n}\n```","slug":"let关键字使用","published":1,"updated":"2020-01-20T07:45:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gig002nlktvtgk3xx0m"},{"title":"masia","abbrlink":"fc2783ae","date":"2019-04-23T15:55:44.000Z","_content":"# hello world\n","source":"_posts/masia.md","raw":"---\ntitle: masia\ncategories: 关于我\ntags:\n  - html\n  - javascript\nabbrlink: fc2783ae\ndate: 2019-04-23 23:55:44\n---\n# hello world\n","slug":"masia","published":1,"updated":"2020-01-20T07:45:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gig002qlktv2saj50q1"},{"title":"mongoose使用","abbrlink":"62ea38d6","date":"2019-04-30T08:00:00.000Z","_content":"\n## 注意:\n+ 以params方式传参的方式编写的接口，params本身也被看做是路由的一部分，所以params参数不能为空，为必传项，不然会找不到接口\n+ 以query方式传参的方式编写的接口可以不传\n<!-- more -->\n+ get方式和pos方式，都可以使用json对象格式来传入参数，都用res.body来接收，注意在使用`req.body`之前要使用`app.use(express.json())`来配置一下，但是一般使用json对象来传入数据体，使用query方式或者params方式来传入查询条件。\n+ 客户端（发送表单格式数据: `Content-Type: application/x-www-form-urlencoded`）\n  服务端（处理客服端发送的表单格式的数据`app.use(express.urlencoded({extended: false}))`或`app.use(bodyParser.urlencoded({extended: false}))`）\n+ 客户端（发送json对象格式数据: `Content-Type: application/json`）\n  服务端（处理客服端发送的json对象格式的数据`app.use(express.json())`或`app.use(bodyParser.json())`）\n\n## 准备: \n```javascript\nconst mongoose = require('mongoose') // 导包\nmongoose.connect('mongodb://localhost:27017/express-test', {useNewUrlParser: true})\n```\n## 创建Schema：\n```javascript\nconst ProductSchema = new mongoose.Schema({ // 创建模型1\n  title: {\n    type: String, // 类型\n  },\n  content: {\n    type: String\n  }\n})\nconst Product = mongoose.model('Product', ProductSchema) // 创建模型2\n\nmodule.exports = {\n  Product // 把模型导出去\n}\n```\n## 删除：\n+ 删除集合\n```javascript\nProduct.db.dropCollection('products') // 模型为Product ，但是在mongodb数据库中保存的集合是 products\n```\n## 查找：\n+  在products集合中查找所有的记录\n```javscript\nconst data = Product.find()\n```\n+  在products集合中查找所有的记录，并且只显示两条\n```javscript\nconst data = Product.find().limit(2)\n```\n+  在products集合中查找所有的记录，并且只显示两条,并且跳过最前面的1条\n```javscript\nconst data = Product.find().skip(1).limit(2) // 将skip()以及limit()结合起来，可以做分页\n```\n+ 使用where()进行条件查询(find()和findOne()后面都可以跟where()做组合查询)\n```javascript\nconst data = Product.find().where({ // where()方法的传入参数为对象格式，即使只有一个查询条件，也得写成键值对形式\n  title: '产品2'\n})\n```\n+  使用sort进行排序，可以用来做产品列表页接口\n```javascript\nconst data = Product.find().sort({\n  _id: 1 // 1 表示正序(从小到大，一般默认都是正序，最新的排在最后面)， -1 表示倒序(从大到小)\n        //这里的 _id 是一个16进制的值，也是可以比较大小的\n})\n```\n+ 根据id查找，可以用来做详情页的接口\n```javascript\napp.get('/products/:id', async (req, res) => {\n        // 这里使用params方式传参数\n  const data = await Product.findById(req.params.id)\n  res.send(data) // 在req.params中获取参数，不需要中间件再处理req\n})\n```\n+ 根据条件查询一条数据\n```javascript\napp.post('/login', async (req, res) => {\n  const user = await User.findOne().where(req.body)\n  res.send(user)\n})\n```\n+ 查询全部和条件查询通用接口\n```javascript\napp.get('products', await (req, res) => {\n  if (JSON.strify(req.query) == '{}') { // 查询条件是否为空，若为空，则查询全部\n    const products = await Product.find()\n    return res.send(products)\n  }\n  const products = await Product.find().where(req.query) // 按照req.query中的约束条件查询\n  res.send(products)\n})\n```\n## 插入：\n+ 往products集合中插入多条记录\n```javascript\nProduct.insertMany([\n  {title: '产品1', content: '这是产品1'},\n  {title: '产品2', content: '这是产品2'},\n  {title: '产品3', content: '这是产品3'}\n])\n```\n+ 使用create() 往集合中插入一条记录\n```javascript\nconst app = express()\napp.use(express.json())\n// 一般添加数据的请求都是post请求，所以要先使用app.use(express.json()) 处理传过来的json数据\napp.post('/products', async (req, res) => {\n  const data = req.body // 保存客户端传过来的json数据\n  const product = await Product.create(req.body) \n  // 这里的await一定要加上，不然会先执行下面的res.send()\n  res.send(product)\n})\n```\n## 修改：（一般会使用put或者patch两种请求方式）\n+ 先说两个请求方式，put和patch\n 1. patch表示的是部分修改\n 2. put表示的是直接覆盖\n+ 先查，后改，再存储\n```javascript\napp.put('/products/:id', async (req, res) => {\n  const product = await Product.findById(req.params.id) // 先找到指定产品\n  product.title = req.body.title // 改值，记得在发送请求的时候，要在请求头中加上 \"Content-Type\": \"application/json\"，意思是，发送的数据类型是json格式的，这样req.body中才能拿到前台传来的json数据\n  await product.save() //  保存到集合中也是异步的，所以要加await \n  res.send(product)\n})\n```\n## 删除\n+ 按照id删除\n```javascript\n<!-- 方法一 -->\napp.delete('/product/:id', async (req, res) => {\n  const product = await Product.findById(req.params.id)\n  await product.remove()\n  res.send({\n    success: true\n  })\n})\n<!-- 方法二 -->\napp.post('/deleteProductById', async (req, res) => {\n  await Product.remove({\n    _id: req.body.id\n  })\n  res.send('delete success')\n})\n```\n+ 按id批量删除\n```javascript\napp.post('/deleteByIds', async (req, res) => {\n  await Product.remove({\n    _id: {\n      $in: req.body.ids // ids 是多个id组成的数组\n    }\n  })\n})\n```\n+ 按照同一个title批量删除\n```javascript\n<!-- 方法一 -->\napp.post('/products/:title', async (req, res) => {\n  const products = await Product.find().where({\n    title: req.params.title\n  })\n  console.log(products instanceof Array) // 查询出来的products是一个数组\n  console.log(products) \n  for (var i = 0; i < products.length; i ++) {\n    await  products[i].remove() // 遍历删除\n  }\n  res.send('remove products complete') // 返回删除成功\n})\n<!-- 方法二 -->\napp.delete('productByTitle', async (req, res) => {\n  await Product.remove({\n    title: req.params.title\n  })\n  res.send(Delete by title is success.')\n})\n```\n","source":"_posts/mongoose使用.md","raw":"---\ntitle: mongoose使用\ncategories:\n  - node.js\n  - mongodb\n  - mongoose\ntags:\n  - node.js\n  - mongodb\n  - mongoose\nabbrlink: 62ea38d6\ndate: 2019-04-30 16:00:00\n---\n\n## 注意:\n+ 以params方式传参的方式编写的接口，params本身也被看做是路由的一部分，所以params参数不能为空，为必传项，不然会找不到接口\n+ 以query方式传参的方式编写的接口可以不传\n<!-- more -->\n+ get方式和pos方式，都可以使用json对象格式来传入参数，都用res.body来接收，注意在使用`req.body`之前要使用`app.use(express.json())`来配置一下，但是一般使用json对象来传入数据体，使用query方式或者params方式来传入查询条件。\n+ 客户端（发送表单格式数据: `Content-Type: application/x-www-form-urlencoded`）\n  服务端（处理客服端发送的表单格式的数据`app.use(express.urlencoded({extended: false}))`或`app.use(bodyParser.urlencoded({extended: false}))`）\n+ 客户端（发送json对象格式数据: `Content-Type: application/json`）\n  服务端（处理客服端发送的json对象格式的数据`app.use(express.json())`或`app.use(bodyParser.json())`）\n\n## 准备: \n```javascript\nconst mongoose = require('mongoose') // 导包\nmongoose.connect('mongodb://localhost:27017/express-test', {useNewUrlParser: true})\n```\n## 创建Schema：\n```javascript\nconst ProductSchema = new mongoose.Schema({ // 创建模型1\n  title: {\n    type: String, // 类型\n  },\n  content: {\n    type: String\n  }\n})\nconst Product = mongoose.model('Product', ProductSchema) // 创建模型2\n\nmodule.exports = {\n  Product // 把模型导出去\n}\n```\n## 删除：\n+ 删除集合\n```javascript\nProduct.db.dropCollection('products') // 模型为Product ，但是在mongodb数据库中保存的集合是 products\n```\n## 查找：\n+  在products集合中查找所有的记录\n```javscript\nconst data = Product.find()\n```\n+  在products集合中查找所有的记录，并且只显示两条\n```javscript\nconst data = Product.find().limit(2)\n```\n+  在products集合中查找所有的记录，并且只显示两条,并且跳过最前面的1条\n```javscript\nconst data = Product.find().skip(1).limit(2) // 将skip()以及limit()结合起来，可以做分页\n```\n+ 使用where()进行条件查询(find()和findOne()后面都可以跟where()做组合查询)\n```javascript\nconst data = Product.find().where({ // where()方法的传入参数为对象格式，即使只有一个查询条件，也得写成键值对形式\n  title: '产品2'\n})\n```\n+  使用sort进行排序，可以用来做产品列表页接口\n```javascript\nconst data = Product.find().sort({\n  _id: 1 // 1 表示正序(从小到大，一般默认都是正序，最新的排在最后面)， -1 表示倒序(从大到小)\n        //这里的 _id 是一个16进制的值，也是可以比较大小的\n})\n```\n+ 根据id查找，可以用来做详情页的接口\n```javascript\napp.get('/products/:id', async (req, res) => {\n        // 这里使用params方式传参数\n  const data = await Product.findById(req.params.id)\n  res.send(data) // 在req.params中获取参数，不需要中间件再处理req\n})\n```\n+ 根据条件查询一条数据\n```javascript\napp.post('/login', async (req, res) => {\n  const user = await User.findOne().where(req.body)\n  res.send(user)\n})\n```\n+ 查询全部和条件查询通用接口\n```javascript\napp.get('products', await (req, res) => {\n  if (JSON.strify(req.query) == '{}') { // 查询条件是否为空，若为空，则查询全部\n    const products = await Product.find()\n    return res.send(products)\n  }\n  const products = await Product.find().where(req.query) // 按照req.query中的约束条件查询\n  res.send(products)\n})\n```\n## 插入：\n+ 往products集合中插入多条记录\n```javascript\nProduct.insertMany([\n  {title: '产品1', content: '这是产品1'},\n  {title: '产品2', content: '这是产品2'},\n  {title: '产品3', content: '这是产品3'}\n])\n```\n+ 使用create() 往集合中插入一条记录\n```javascript\nconst app = express()\napp.use(express.json())\n// 一般添加数据的请求都是post请求，所以要先使用app.use(express.json()) 处理传过来的json数据\napp.post('/products', async (req, res) => {\n  const data = req.body // 保存客户端传过来的json数据\n  const product = await Product.create(req.body) \n  // 这里的await一定要加上，不然会先执行下面的res.send()\n  res.send(product)\n})\n```\n## 修改：（一般会使用put或者patch两种请求方式）\n+ 先说两个请求方式，put和patch\n 1. patch表示的是部分修改\n 2. put表示的是直接覆盖\n+ 先查，后改，再存储\n```javascript\napp.put('/products/:id', async (req, res) => {\n  const product = await Product.findById(req.params.id) // 先找到指定产品\n  product.title = req.body.title // 改值，记得在发送请求的时候，要在请求头中加上 \"Content-Type\": \"application/json\"，意思是，发送的数据类型是json格式的，这样req.body中才能拿到前台传来的json数据\n  await product.save() //  保存到集合中也是异步的，所以要加await \n  res.send(product)\n})\n```\n## 删除\n+ 按照id删除\n```javascript\n<!-- 方法一 -->\napp.delete('/product/:id', async (req, res) => {\n  const product = await Product.findById(req.params.id)\n  await product.remove()\n  res.send({\n    success: true\n  })\n})\n<!-- 方法二 -->\napp.post('/deleteProductById', async (req, res) => {\n  await Product.remove({\n    _id: req.body.id\n  })\n  res.send('delete success')\n})\n```\n+ 按id批量删除\n```javascript\napp.post('/deleteByIds', async (req, res) => {\n  await Product.remove({\n    _id: {\n      $in: req.body.ids // ids 是多个id组成的数组\n    }\n  })\n})\n```\n+ 按照同一个title批量删除\n```javascript\n<!-- 方法一 -->\napp.post('/products/:title', async (req, res) => {\n  const products = await Product.find().where({\n    title: req.params.title\n  })\n  console.log(products instanceof Array) // 查询出来的products是一个数组\n  console.log(products) \n  for (var i = 0; i < products.length; i ++) {\n    await  products[i].remove() // 遍历删除\n  }\n  res.send('remove products complete') // 返回删除成功\n})\n<!-- 方法二 -->\napp.delete('productByTitle', async (req, res) => {\n  await Product.remove({\n    title: req.params.title\n  })\n  res.send(Delete by title is success.')\n})\n```\n","slug":"mongoose使用","published":1,"updated":"2020-01-20T07:45:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gii002vlktvwxl7tk5w"},{"title":"node安装引发的惨案","abbrlink":"2a6653ec","date":"2019-04-25T08:10:10.000Z","_content":"# node安装\n本人在学习node初期，按照网上的教程傻瓜式的给win10安装了node，当时没有真正理会每一步安装的目的和意义，直接导致后期在使用npm的时候出现了各种各样的问题（尤其是在npm全局安装的时候）\n<!-- more -->\n+ ps: 如果你的机器已经安装了nodejs，而且在npm全局安装是出现了各种各样的问题（比如找不到npm指向的全局安装目录，安装权限问题），那么这篇文章可能会找到一些问题的答案，或者可以完全卸载重新安装。\n\n## 在windows中完全移除nodejs（npm包含在nodejs中）\n\n1. 在 【windows设置>应用】 中，找到nodejs，然后点击卸载\n2. 删除所有与nodejs相关的文件目录以及文件\nC:\\Program Files (x86)\\Nodejs\nC:\\Program Files\\Nodejs\nC:\\Users\\{User}\\AppData\\Roaming\\npm（或%appdata%\\npm）\nC:\\Users\\{User}\\AppData\\Roaming\\npm-cache（或%appdata%\\npm-cache） \n以及之前的nodejs的安装目录（比如我刚开始将nodejs安装在了F:\\nodejs中，那就将这个目录删除）\n3. 删除所有与node或者npm相关的环境变量\n一般包括用户环境变量中的PATH和系统变量中的NODE_PATH、Path（注意：只要看见包含npm或者node就大胆把它给删除了，不管是大写的还是小写的）\n\n## 在windows中安装nodejs\n1. 打开nodejs官网 https://nodejs.org/en/\n    选择Download for Windows (x64)，LTS版本，此版为稳定版，点击下载，得到一个msi格式的nodejs安装文件\n2. 在你经常存放软件的磁盘中先建一个nodejs文件夹，比如：F:\\nodejs\n    点击刚刚下载的nodejs安装文件，记得在选择安装目录的时候选择F:\\nodejs，一路next，直到finish\n3. 此时，你使用win+R打开命令行工具，输入指令`node -v`,已经可以看见nodejs的版本号了，输入指令`npm -v`,同样可以看见npm的版本号,证明你已经成功安装了nodejs\n4. 接下来我们需要配置一些nodejs环境变量，也就是设置一下你的npm工具在全局安装一些例如webpack工具的时候，安装在哪里。\n   + 注意：这里的配置非常重要，因为你安装完nodejs之后，默认设置以后的全局安装目录在C:\\Program Files\\Nodejs这个文件夹中，所以我们在以后全局安装的时候，就会因为权限的问题而安装失败，亲测管理员身份安装也会失败。。。（这个问题困扰了我好久）\n   1. 在F:\\nodejs\\中新建两个文件夹，一个名为node_global，另外一个名为node_cache\n      + node_global就是以后全局安装的目录，node_cache就是以后全局安装时产生日志文件目录\n   2. 设置环境变量\n      + 点击用户环境变量中的变量PATH，找到C:\\User\\你的计算机用户名\\AppData\\Roaming\\npm,点击编辑，编辑为`F:\\nodejs\\node_global `\n      + 在系统环境变量中新建一个名为NODE_PATH的变量，设置变量值为`F:\\nodejs\\node_global\\node_modules`后面这个node_modules目录会在全局安装时自动生成。\n\n   3. 打开命令行工具输入`npm config set prefix \"F:\\nodejs\\node_global\"`以及`npm config set cache \"F:\\nodejs\\node_cache\"`\n   4. 尝试全局安装nodemon，`npm i -g nodemon`，等待安装完成之后，再输入`nodemon -v`,在命令行显示版本号，证明全局安装成功\n      + ps：打开【F:\\nodejs\\node_global】目录你会看到刚刚安装的nodemon相关的文件，再点击 其中的node_modules文件夹，你会看到有一个名为nodemon的文件夹。","source":"_posts/node-install.md","raw":"---\ntitle: node安装引发的惨案\ncategories:\n  - 安装\ntags:\n  - install\nabbrlink: 2a6653ec\ndate: 2019-04-25 16:10:10\n---\n# node安装\n本人在学习node初期，按照网上的教程傻瓜式的给win10安装了node，当时没有真正理会每一步安装的目的和意义，直接导致后期在使用npm的时候出现了各种各样的问题（尤其是在npm全局安装的时候）\n<!-- more -->\n+ ps: 如果你的机器已经安装了nodejs，而且在npm全局安装是出现了各种各样的问题（比如找不到npm指向的全局安装目录，安装权限问题），那么这篇文章可能会找到一些问题的答案，或者可以完全卸载重新安装。\n\n## 在windows中完全移除nodejs（npm包含在nodejs中）\n\n1. 在 【windows设置>应用】 中，找到nodejs，然后点击卸载\n2. 删除所有与nodejs相关的文件目录以及文件\nC:\\Program Files (x86)\\Nodejs\nC:\\Program Files\\Nodejs\nC:\\Users\\{User}\\AppData\\Roaming\\npm（或%appdata%\\npm）\nC:\\Users\\{User}\\AppData\\Roaming\\npm-cache（或%appdata%\\npm-cache） \n以及之前的nodejs的安装目录（比如我刚开始将nodejs安装在了F:\\nodejs中，那就将这个目录删除）\n3. 删除所有与node或者npm相关的环境变量\n一般包括用户环境变量中的PATH和系统变量中的NODE_PATH、Path（注意：只要看见包含npm或者node就大胆把它给删除了，不管是大写的还是小写的）\n\n## 在windows中安装nodejs\n1. 打开nodejs官网 https://nodejs.org/en/\n    选择Download for Windows (x64)，LTS版本，此版为稳定版，点击下载，得到一个msi格式的nodejs安装文件\n2. 在你经常存放软件的磁盘中先建一个nodejs文件夹，比如：F:\\nodejs\n    点击刚刚下载的nodejs安装文件，记得在选择安装目录的时候选择F:\\nodejs，一路next，直到finish\n3. 此时，你使用win+R打开命令行工具，输入指令`node -v`,已经可以看见nodejs的版本号了，输入指令`npm -v`,同样可以看见npm的版本号,证明你已经成功安装了nodejs\n4. 接下来我们需要配置一些nodejs环境变量，也就是设置一下你的npm工具在全局安装一些例如webpack工具的时候，安装在哪里。\n   + 注意：这里的配置非常重要，因为你安装完nodejs之后，默认设置以后的全局安装目录在C:\\Program Files\\Nodejs这个文件夹中，所以我们在以后全局安装的时候，就会因为权限的问题而安装失败，亲测管理员身份安装也会失败。。。（这个问题困扰了我好久）\n   1. 在F:\\nodejs\\中新建两个文件夹，一个名为node_global，另外一个名为node_cache\n      + node_global就是以后全局安装的目录，node_cache就是以后全局安装时产生日志文件目录\n   2. 设置环境变量\n      + 点击用户环境变量中的变量PATH，找到C:\\User\\你的计算机用户名\\AppData\\Roaming\\npm,点击编辑，编辑为`F:\\nodejs\\node_global `\n      + 在系统环境变量中新建一个名为NODE_PATH的变量，设置变量值为`F:\\nodejs\\node_global\\node_modules`后面这个node_modules目录会在全局安装时自动生成。\n\n   3. 打开命令行工具输入`npm config set prefix \"F:\\nodejs\\node_global\"`以及`npm config set cache \"F:\\nodejs\\node_cache\"`\n   4. 尝试全局安装nodemon，`npm i -g nodemon`，等待安装完成之后，再输入`nodemon -v`,在命令行显示版本号，证明全局安装成功\n      + ps：打开【F:\\nodejs\\node_global】目录你会看到刚刚安装的nodemon相关的文件，再点击 其中的node_modules文件夹，你会看到有一个名为nodemon的文件夹。","slug":"node-install","published":1,"updated":"2020-01-20T07:45:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gij002ylktv0xcbvj5w"},{"title":"node.js复习1","abbrlink":"f9876e6a","date":"2019-04-26T01:00:00.000Z","_content":"## 深入研究module.exports与exports各种组合用法，其意义在于更加深入理解这两个对象的本质特点，以便以后灵活使用。\n<!-- more -->\n## 归根结底是探究module.exports与exports的关系，以及对象引用的指向问题\n系统默认exports = module.exports，也就是说他们两个指向了同一个对象，下面来看三种情况：\n假设在文件demo.js中：\n```javascript\nvar a = 2;\nfunction fun () {\n  console.log('this is a function')\n}\nvar b = 3\n```\n+ 情况一：\n    ```javascript\n    module.exports.a = a\n    module.exports.fun = fun\n    exports.b = b\n    ```\n    那么module.exports和exports向外暴露的是同一个对象，在test.js文件中访问demo.js：\n    ```javascript\n    var demo = require('./demo')\n    console.log(demo)\n    ```\n    并在控制台打印，得到：\n    ```bash\n    {a: a, fun: [Function: fun], b: 3}\n    ```\n\n+ 情况二：\n    ```javascript \n    module.exports = { //这样的写法，实际上已经将module.export指向一个新的对象了，但是exports指向的还是原来默认的对象\n      a: a,\n      fun: fun\n    }\n    exports.b = b //但是exports指向的是之前默认的对象\n    ```\n    最后向外暴露的是module.exports实际指向的对象，此时exports.x也失去了向外部暴露属性的功能，在test.js文件中访问demo.js\n    ```javascript\n    var demo = require('./demo')\n    var {b} = require('./demo')\n    console.log(demo)\n    console.log(b)\n    ```\n    在控制台得到的结果为：\n    ```bash\n    {a: a, fun: [Funtion: fun]}\n    undefined\n```\n\n+ 情况三：\n    使用module.exports整体暴露\n    ```javascript\n    module.exports = {\n      a: a,\n      fun: fun,\n      b: b\n    }\n    ```\n    在test中按需引入\n    ```javascript\n    var {a, fun} = require('./demo')\n    console.log(a)\n    console.log(fun)\n    ```\n    在控制台得到的结果为：\n    ```bash\n    12\n    [Function: fun]\n```\n+ 注意：\n  1. 如果要使用module.exports，在使用时尽量整体引入。\n  2. 如果要使用exports.x，千万不要在同一个文件中module.exports = {}，但是可以使用module.exports.xxx\n","source":"_posts/nodejs_review1.md","raw":"---\ntitle: node.js复习1\ncategories:\n  - node.js\ntags:\n  - node.js\nabbrlink: f9876e6a\ndate: 2019-04-26 09:00:00\n---\n## 深入研究module.exports与exports各种组合用法，其意义在于更加深入理解这两个对象的本质特点，以便以后灵活使用。\n<!-- more -->\n## 归根结底是探究module.exports与exports的关系，以及对象引用的指向问题\n系统默认exports = module.exports，也就是说他们两个指向了同一个对象，下面来看三种情况：\n假设在文件demo.js中：\n```javascript\nvar a = 2;\nfunction fun () {\n  console.log('this is a function')\n}\nvar b = 3\n```\n+ 情况一：\n    ```javascript\n    module.exports.a = a\n    module.exports.fun = fun\n    exports.b = b\n    ```\n    那么module.exports和exports向外暴露的是同一个对象，在test.js文件中访问demo.js：\n    ```javascript\n    var demo = require('./demo')\n    console.log(demo)\n    ```\n    并在控制台打印，得到：\n    ```bash\n    {a: a, fun: [Function: fun], b: 3}\n    ```\n\n+ 情况二：\n    ```javascript \n    module.exports = { //这样的写法，实际上已经将module.export指向一个新的对象了，但是exports指向的还是原来默认的对象\n      a: a,\n      fun: fun\n    }\n    exports.b = b //但是exports指向的是之前默认的对象\n    ```\n    最后向外暴露的是module.exports实际指向的对象，此时exports.x也失去了向外部暴露属性的功能，在test.js文件中访问demo.js\n    ```javascript\n    var demo = require('./demo')\n    var {b} = require('./demo')\n    console.log(demo)\n    console.log(b)\n    ```\n    在控制台得到的结果为：\n    ```bash\n    {a: a, fun: [Funtion: fun]}\n    undefined\n```\n\n+ 情况三：\n    使用module.exports整体暴露\n    ```javascript\n    module.exports = {\n      a: a,\n      fun: fun,\n      b: b\n    }\n    ```\n    在test中按需引入\n    ```javascript\n    var {a, fun} = require('./demo')\n    console.log(a)\n    console.log(fun)\n    ```\n    在控制台得到的结果为：\n    ```bash\n    12\n    [Function: fun]\n```\n+ 注意：\n  1. 如果要使用module.exports，在使用时尽量整体引入。\n  2. 如果要使用exports.x，千万不要在同一个文件中module.exports = {}，但是可以使用module.exports.xxx\n","slug":"nodejs_review1","published":1,"updated":"2020-01-20T07:45:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gik0032lktv1p1uuhwb"},{"title":"node.js复习2","abbrlink":"608e3fd0","date":"2019-04-28T00:47:00.000Z","_content":"## 今天主要来复习一下node.js内置模块的用法\n<!-- more -->\n+ http模块\n```javascript\nvar http = require('http')\n// 支持链式调用\nvar server = http\n  .createServer( function (req, res) {\n    res.write('Hello World!')\n    res.writeHead(404, 'not found', {\n        'Content-Type': 'text/html;charset=utf-8',\n        'set-Cookie': 'mycookie1=value1',\n        'Access-Control-Allow-Origin', 'http://localhost'\n      })\n    res.end()\n  })\n  .listen(3000, function () {\n\n  }) // 在listen中拿不到req 和 res\n```\n- url模块\n```javascript \nvar url = require('url')\nvar a = 'http://192.168.15.138:8080/courses/query?credit=2&name=Java'\nvar urlObj = url.parse(a)  // 将整个字符串url变成对象\nvar pathname = urlObj.pathname // '/courses/query'\nvar queryStr = urlObj.query // 'credit=2&name=Java'\nvar queryObj = url.parse(a, true).query // 将整个查询字符串'credit=2&name=Java'转化为对象 { crdit: 2, name: 'Java'}\n```\n- querystring模块\n```javascript\nvar querystring = require('querystring')\nvar queryObj = querystring.parse(queryStr) // 将查询字符串'credit=2&name=Java'转化为参数对象\nvar queryStr2 = querystring.stringify(queryObj) // 同时，当然也可以将参数对象转化为字符串\n```\n- path模块\n```javascript\nvar path = require('path')\n\nvar a = '/home/masia/a.txt'\nconsole.log('basename:', path.basename(a)) // basename: a.txt\nconsole.log('dirname:', path.dirname(a)) // dirname: c:/home/masia\nconsole.log('extname:', path.extname(a)) // extname: .txt\nconsole.log('isAbsolute', path.isAbsolute(a)) // isAbsolute true\nconsole.log('__dirname', path.join(__dirname)) // __dirname 当前文件所在目录\n```\n- fs模块\n```javascript\nvar fs = require('fs')\n// 文件读取方法\nfs.readFile(path.join(__dirname, './a.txt'), function (err, data) {\n  if (err) {\n    return res.end('read file err')\n  } else {\n    console.log(data) // 这样读取出来的文件buffer 的 16进制格式的\n    console.log(data.toString()) // 需要使用x.toString()方法来将buffer格式的数据转化为字符串形式的数据\n  }\n})\n// 目录读取方法\nfs.readdir(path.join(__dirname), function (err, files) {\n  if (err) {\n    console.log('can not find this directory')\n  } else {\n    console.log(files) // 输出的是path.join(__dirname)这个目录下面的所有目录名以及文件名\n  }\n})\n```\n- res.writeHead()和res.setHeader()的区别\n + writeHead：该方法被调用时发送响应头\n + writeHead必须要在发送数据之前调用\n```javascript\nres.writeHead(200, 'normal', {\n  'Content-Type': 'text/plain;charset=utf-8',\n  'set-Cookie': ['mycookie1=value1', 'mycookie2=value2']\n  'Access-Control-Allow-Origin': 'http://localhost'\n})\n```\n + setHeader：write方法第一次被调用时发送响应头\n```javascript\nres.statusCode = 200\nres.setHeader('Content-Type', 'text/plain')\nres.setHeader('Access-Contorl-Allow-Origin', 'http://localhost')\nres.setHeader('Set-cookie', ['mycookie1=value1', 'mycookie2=value2'])\n```\n- res.end()与res.send()区别\n + res.end()只能发送string或者buffer类型的数据，是node.js的内置方法\n + res.send()能发送对象\n","source":"_posts/nodejs_review2.md","raw":"---\ntitle: node.js复习2\ncategories:\n  - node.js\ntags:\n  - node.js\nabbrlink: 608e3fd0\ndate: 2019-04-28 08:47:00\n---\n## 今天主要来复习一下node.js内置模块的用法\n<!-- more -->\n+ http模块\n```javascript\nvar http = require('http')\n// 支持链式调用\nvar server = http\n  .createServer( function (req, res) {\n    res.write('Hello World!')\n    res.writeHead(404, 'not found', {\n        'Content-Type': 'text/html;charset=utf-8',\n        'set-Cookie': 'mycookie1=value1',\n        'Access-Control-Allow-Origin', 'http://localhost'\n      })\n    res.end()\n  })\n  .listen(3000, function () {\n\n  }) // 在listen中拿不到req 和 res\n```\n- url模块\n```javascript \nvar url = require('url')\nvar a = 'http://192.168.15.138:8080/courses/query?credit=2&name=Java'\nvar urlObj = url.parse(a)  // 将整个字符串url变成对象\nvar pathname = urlObj.pathname // '/courses/query'\nvar queryStr = urlObj.query // 'credit=2&name=Java'\nvar queryObj = url.parse(a, true).query // 将整个查询字符串'credit=2&name=Java'转化为对象 { crdit: 2, name: 'Java'}\n```\n- querystring模块\n```javascript\nvar querystring = require('querystring')\nvar queryObj = querystring.parse(queryStr) // 将查询字符串'credit=2&name=Java'转化为参数对象\nvar queryStr2 = querystring.stringify(queryObj) // 同时，当然也可以将参数对象转化为字符串\n```\n- path模块\n```javascript\nvar path = require('path')\n\nvar a = '/home/masia/a.txt'\nconsole.log('basename:', path.basename(a)) // basename: a.txt\nconsole.log('dirname:', path.dirname(a)) // dirname: c:/home/masia\nconsole.log('extname:', path.extname(a)) // extname: .txt\nconsole.log('isAbsolute', path.isAbsolute(a)) // isAbsolute true\nconsole.log('__dirname', path.join(__dirname)) // __dirname 当前文件所在目录\n```\n- fs模块\n```javascript\nvar fs = require('fs')\n// 文件读取方法\nfs.readFile(path.join(__dirname, './a.txt'), function (err, data) {\n  if (err) {\n    return res.end('read file err')\n  } else {\n    console.log(data) // 这样读取出来的文件buffer 的 16进制格式的\n    console.log(data.toString()) // 需要使用x.toString()方法来将buffer格式的数据转化为字符串形式的数据\n  }\n})\n// 目录读取方法\nfs.readdir(path.join(__dirname), function (err, files) {\n  if (err) {\n    console.log('can not find this directory')\n  } else {\n    console.log(files) // 输出的是path.join(__dirname)这个目录下面的所有目录名以及文件名\n  }\n})\n```\n- res.writeHead()和res.setHeader()的区别\n + writeHead：该方法被调用时发送响应头\n + writeHead必须要在发送数据之前调用\n```javascript\nres.writeHead(200, 'normal', {\n  'Content-Type': 'text/plain;charset=utf-8',\n  'set-Cookie': ['mycookie1=value1', 'mycookie2=value2']\n  'Access-Control-Allow-Origin': 'http://localhost'\n})\n```\n + setHeader：write方法第一次被调用时发送响应头\n```javascript\nres.statusCode = 200\nres.setHeader('Content-Type', 'text/plain')\nres.setHeader('Access-Contorl-Allow-Origin', 'http://localhost')\nres.setHeader('Set-cookie', ['mycookie1=value1', 'mycookie2=value2'])\n```\n- res.end()与res.send()区别\n + res.end()只能发送string或者buffer类型的数据，是node.js的内置方法\n + res.send()能发送对象\n","slug":"nodejs_review2","published":1,"updated":"2020-01-20T07:45:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gil0036lktv68pfze8k"},{"title":"node.js复习3：使用原生ajax与jquery版本ajax向node服务器请求数据对比","abbrlink":"1b1af260","date":"2019-04-28T09:30:00.000Z","_content":"\n一直以来没有搞清楚使用原生js以post方式发起ajax请求时，<!-- more -->是怎么向服务端发送请求参数的。在使用$.ajax()方法时，不管是get方式，还是post方式，都是可以以对象的方式向服务端提交参数的。但原生js的两种发送请求的方式，发送的参数都是查询字符串方式的，应该叫做表单格式的数据吧。\n## $.ajax()发送请求\n+ get方式\n```javascript\nvar data = {\n  email: '916527363@qq.com',\n  password: '123456'\n}\n$.ajax({\n  url: 'http://localhost:8888/login', // 这里要注意的是，既然在已经在传入对象中写了的属性，不要在这里重复写，不会覆盖的，而是会追加\n  type: 'get',\n  data: data,\n  success: function (data) {\n    console.log(data)\n  }\n})\n```\n+ post方式\n```javascript\nvar data = {\n  email: '916527363@qq.com',\n  password: '123456'\n}\n$.ajax({\n  url: 'http://localhost:8888/login',\n  type: 'post',\n  data: data,\n  success: function (data) {\n    console.log(data)\n  }\n})\n```\n## 原生js发送请求\n+ get方式\n```javascript\nfunction ajaxGet () {\n  var xhr = new XMLHttpRequest()\n  xhr.open(\"GET\", \"http://localhost:8888/login?email=916527363@qq.com&password=123456\")\n  // 原生get方式的ajax带参数发送请求的时候，只能将参数以查询字符串的方式缀在路由后面\n  xhr.onreadystatechange = function () {\n    if(xhr.readyState == 4 && xhr.status == 200) {\n      console.log(xhr.responseText) // xhr.responseText为响应数据\n    }\n  }\n  xhr.send() // 原生的get请求不能在这里传参数\n}\n```\n+ post方式\n```javascript\n// 先收集数据\nvar email = \"916527363@qq.com\"\nvar password = \"123456\"\n// 将收集到的数据组合成查询字符串\nvar msg = \"email=\"+email+\"&password=\"+password\nfunction ajaxPost () {\n  var xhr = new XMLHttpRequest()\n  xhr.open(\"POST\", \"http://localhost:8888/login\")\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); // 声明了数据格式是表单格式的\n  // 发送post请求，必须要写这一句，不然xhr.send(msg)不生效\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n      console.log(xhr.responseText) // xhr.responseText为响应数据\n    }\n  }\n  xhr.send(msg) // 即使是post请求，这里传的参数依然为查询字符串形式，不能是对象形式的参数\n}\n```\n\n## 在node服务器中\n在node服务器中，完全不需要关心前台是提交的参数是字符串类型的还是对象类型的，只需要知道，前台发送的请求是get方式的，还是post方式的\n+ 准备：创建一个基于express框架的node服务器\n```javascript\nvar express = require('express')\nvar url = require('url')\nvar query = url.paese()\nvar bodyParser = require('body-parser') // 该模块用来解析post提交的参数对象\n\n\napp.use(bodyParser.urlencoded({extended: false})) // 处理传过来的表单数据\napp.use(bodyParser.json()) // 处理传过来的json数据\n\napp.listen(3000, function () {\n  console.log('app is running at 3000')\n})\n```\n+ 如果前台提交的请求是get方式的，那么后台就需要使用\n```javascript\napp.get('/login', function (req, res) {\n  // 将req.url做处理（其中参数true的作用是，直接将查询字符串转化为了对象）\n  var urlObj = url.parse(req.url, true)\n  // 拿到参数对象\n  var queryObj = urlObj.query\n  console.log(queryObj)\n})\n```\n+ 如果前台提交的请求是get方式的，那么后台就需要使用\n```javascript\napp.post('/login', function (req, res) {\n  // 拿到参数对象\n  var queryObj = req.body\n  console.log(queryObj)\n})\n```","source":"_posts/nodejs_review3.md","raw":"---\ntitle: node.js复习3：使用原生ajax与jquery版本ajax向node服务器请求数据对比\ncategories:\n  - node.js\n  - ajax\ntags:\n  - node.js\nabbrlink: 1b1af260\ndate: 2019-04-28 17:30:00\n---\n\n一直以来没有搞清楚使用原生js以post方式发起ajax请求时，<!-- more -->是怎么向服务端发送请求参数的。在使用$.ajax()方法时，不管是get方式，还是post方式，都是可以以对象的方式向服务端提交参数的。但原生js的两种发送请求的方式，发送的参数都是查询字符串方式的，应该叫做表单格式的数据吧。\n## $.ajax()发送请求\n+ get方式\n```javascript\nvar data = {\n  email: '916527363@qq.com',\n  password: '123456'\n}\n$.ajax({\n  url: 'http://localhost:8888/login', // 这里要注意的是，既然在已经在传入对象中写了的属性，不要在这里重复写，不会覆盖的，而是会追加\n  type: 'get',\n  data: data,\n  success: function (data) {\n    console.log(data)\n  }\n})\n```\n+ post方式\n```javascript\nvar data = {\n  email: '916527363@qq.com',\n  password: '123456'\n}\n$.ajax({\n  url: 'http://localhost:8888/login',\n  type: 'post',\n  data: data,\n  success: function (data) {\n    console.log(data)\n  }\n})\n```\n## 原生js发送请求\n+ get方式\n```javascript\nfunction ajaxGet () {\n  var xhr = new XMLHttpRequest()\n  xhr.open(\"GET\", \"http://localhost:8888/login?email=916527363@qq.com&password=123456\")\n  // 原生get方式的ajax带参数发送请求的时候，只能将参数以查询字符串的方式缀在路由后面\n  xhr.onreadystatechange = function () {\n    if(xhr.readyState == 4 && xhr.status == 200) {\n      console.log(xhr.responseText) // xhr.responseText为响应数据\n    }\n  }\n  xhr.send() // 原生的get请求不能在这里传参数\n}\n```\n+ post方式\n```javascript\n// 先收集数据\nvar email = \"916527363@qq.com\"\nvar password = \"123456\"\n// 将收集到的数据组合成查询字符串\nvar msg = \"email=\"+email+\"&password=\"+password\nfunction ajaxPost () {\n  var xhr = new XMLHttpRequest()\n  xhr.open(\"POST\", \"http://localhost:8888/login\")\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); // 声明了数据格式是表单格式的\n  // 发送post请求，必须要写这一句，不然xhr.send(msg)不生效\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n      console.log(xhr.responseText) // xhr.responseText为响应数据\n    }\n  }\n  xhr.send(msg) // 即使是post请求，这里传的参数依然为查询字符串形式，不能是对象形式的参数\n}\n```\n\n## 在node服务器中\n在node服务器中，完全不需要关心前台是提交的参数是字符串类型的还是对象类型的，只需要知道，前台发送的请求是get方式的，还是post方式的\n+ 准备：创建一个基于express框架的node服务器\n```javascript\nvar express = require('express')\nvar url = require('url')\nvar query = url.paese()\nvar bodyParser = require('body-parser') // 该模块用来解析post提交的参数对象\n\n\napp.use(bodyParser.urlencoded({extended: false})) // 处理传过来的表单数据\napp.use(bodyParser.json()) // 处理传过来的json数据\n\napp.listen(3000, function () {\n  console.log('app is running at 3000')\n})\n```\n+ 如果前台提交的请求是get方式的，那么后台就需要使用\n```javascript\napp.get('/login', function (req, res) {\n  // 将req.url做处理（其中参数true的作用是，直接将查询字符串转化为了对象）\n  var urlObj = url.parse(req.url, true)\n  // 拿到参数对象\n  var queryObj = urlObj.query\n  console.log(queryObj)\n})\n```\n+ 如果前台提交的请求是get方式的，那么后台就需要使用\n```javascript\napp.post('/login', function (req, res) {\n  // 拿到参数对象\n  var queryObj = req.body\n  console.log(queryObj)\n})\n```","slug":"nodejs_review3","published":1,"updated":"2020-01-20T07:45:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gim003alktv1pr5dp4w"},{"title":"node.js复习4：token和cookie的使用","abbrlink":"7b871db4","date":"2019-04-29T02:00:00.000Z","_content":"\n## 说明：\n演示加密方式为 bcrypt 方式\n<!-- more -->\n## token方式\n\n+ 安装和导入jsonwebtoken\n\n```bash\nnpm i jsonwebtoken\n```\n```javascript\nconst jwt = require('jsonwebtoken')\n```\n+ 定义SECRET（这个secret不应该写在一个单独的文件中，比如.igonore等被忽略上传的文件中）\n\n```javascript\nconst SECRET = 'fkdsjfkasjfd' // 相当于一段密码\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n    const user = await User.findOne({\n      email: req.body.email\n    })\n    if (!user) {\n      // 一般用户提交的数据有问题，状态吗是422\n      return res.status(422).send({\n        \"message\": \"用户名不存在\"\n      })\n    }\n\n    <!-- 校验密码是否正确 -->\n    // 使用bcrypt模块的 compareSync() 方法，对密码进行校验比对，该方法的返回值是true或者false\n    const isPasswordValid = require('bcrypt').compareSync(\n      req.body.password, // 第一个参数是客户端发起请求的明文密码值\n      user.password // 第二参数是数据库中的密文密码值\n    )\n    if (!isPasswordValid) {\n      return res.status(422).send({\n        \"message\": \"输入密码错误\"\n      })\n    }\n\n    <!-- 根据id生成token -->\n    const token = jwt.sign({\n      id: String(user._id) // 这里需要注意的是，不要把密码放在token中，可以放一个其他的键，比如_id等。\n      //这里虽然写的形式是对象键值对的形式，但是实际上，token不是一个对象，而是一段hash值，id不会以键值对的形式出现。\n      // 解密时使用 jwt.verify(raw, SECRET) 方法，会得到包含id属性的对象，这里raw就是那段hash值。\n    }, SECRET) // 第二个参数为secret，这个secret不应该出现在代码库中，应该是一个环境变量之类的东西，应该是在.ignore中被忽略上传的东西\n          // 这个secret应该是全局保持唯一的\n    res.send({\n      user,\n      token: token\n    })\n  })\n```\n返回给客户端的结果为\n\n```javascript\n{\n  \"user\": {\n    \"_id\": \"5cce3ac57879e13fc45d3511\",\n    \"email\": \"user3\",\n    \"password\": \"$2b$10$/PJRuI8mnOUpMkB5an8iKOOYqUFAyhBrV6FImTUuU7mmGG6P9Ys5a\",\n    \"__v\": 0\n  },\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjVjY2UzYWM1Nzg3OWUxM2ZjNDVkMzUxMSIsImlhdCI6MTU1NzAxOTMzNn0.22ImaDk_1dkMkEbezu0ByrwkBGXPrlc7Ox-ORJ75oUQ\"\n  // 后面的这段hash值就是上面jwt对user._id加密生成的，并且每次执行发起登录请求时，会根据相同的user._id生成不同的token\n}\n```\n+ 进入个人中心\n\n客户端\n\n```javascript\npost {{url}}/profile\nContent-Type: application/json\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjVjY2UzYWM1Nzg3OWUxM2ZjNDVkMzUxMSIsImlhdCI6MTU1NzAxOTMzNn0.22ImaDk_1dkMkEbezu0ByrwkBGXPrlc7Ox-ORJ75oUQ\n```\n服务端\n\n```javascript\napp.post('/profile', async (req, res) => {\n  var raw = String(req.headers.authorization).split(' ').pop()\n  console.log(jwt.verify(raw, SECRET))\n  // { id: '5cce6f15b7e8724438c8d621', iat: 1557034387 }\n  const { id } = jwt.verify(raw, SECRET) // 当初用_id做的密钥，所以现在解密_id，再用_id做条件查找\n  const user = await User.findById(id)\n  res.send(user)\n})\n```\n  可以提取中间件 \n\n```javascript\n// 用户登录获取信息中间件\nconst authMiddleware = async (req, res, next) => {\n  var raw = String(req.headers.authorization).split(' ').pop()\n  const { id } = jwt.verify(raw, SECRET)\n  req.user = await User.findById(id) // 将查询的结果以属性的方式保存在req中\n  next() \n}\n```\n  服务端改写为\n\n```javascript\napp.post('/profile', authMiddleware, async (req, res) => {\n  res.send(req.user)\n})\n```\n\n## cookie方式\n\n+ 安装和导入express-session\n\n```bash\nnpm i express-session\n```\n```javascript\nconst session = require('express-session')\n```\n+ 配置中间件\n\n```javascript\n<!-- 中间件一定要放在使用之前 -->\napp.use(session({ \n  secret: 'keyboard cat', // 密钥\n  resave: false,\n  saveUninitialized: true \n}))\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n  const user = await User.findOne({\n    email: req.body.email\n  })\n  if (!user) {\n    // 一般用户提交的数据有问题，状态吗是422\n    return res.status(422).send({\n      \"message\": \"用户名不存在\"\n    })\n  }\n\n  <!-- 校验密码是否正确 -->\n  // 使用bcrypt模块的 compareSync() 方法，对密码进行校验比对，该方法的返回值是true或者false\n  const isPasswordValid = require('bcrypt').compareSync(\n    req.body.password, // 第一个参数是客户端发起请求的明文密码值\n    user.password // 第二参数是数据库中的密文密码值\n  )\n  if (!isPasswordValid) {\n    return res.status(422).send({\n      \"message\": \"输入密码错误\"\n    })\n  }\n\n  <!-- 成功验证后，将查询到的用户放入cookie -->\n  req.session.user = user\n  res.status(200).json({ // 返回成功信息\n    err_code: 200,\n    message: 'ok'\n  })\n})\n```\n+ 进入个人中心\n\n```javascript\napp.post('/profile', async (req, res) => {\n  console.log(req.session)\n  res.send(req.session)\n})\n```\n+ 返回结果\n\n```javascript\n{ _id: '5cce56bbecd3734398851c80',\n  email: 'user12',\n  password: '123456',\n  date: '2019-05-05T03:21:31.457Z',\n  __v: 0 }\n```\n","source":"_posts/nodejs_review4.md","raw":"---\ntitle: node.js复习4：token和cookie的使用\ncategories:\n  - node.js\ntags:\n  - node.js\nabbrlink: 7b871db4\ndate: 2019-04-29 10:00:00\n---\n\n## 说明：\n演示加密方式为 bcrypt 方式\n<!-- more -->\n## token方式\n\n+ 安装和导入jsonwebtoken\n\n```bash\nnpm i jsonwebtoken\n```\n```javascript\nconst jwt = require('jsonwebtoken')\n```\n+ 定义SECRET（这个secret不应该写在一个单独的文件中，比如.igonore等被忽略上传的文件中）\n\n```javascript\nconst SECRET = 'fkdsjfkasjfd' // 相当于一段密码\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n    const user = await User.findOne({\n      email: req.body.email\n    })\n    if (!user) {\n      // 一般用户提交的数据有问题，状态吗是422\n      return res.status(422).send({\n        \"message\": \"用户名不存在\"\n      })\n    }\n\n    <!-- 校验密码是否正确 -->\n    // 使用bcrypt模块的 compareSync() 方法，对密码进行校验比对，该方法的返回值是true或者false\n    const isPasswordValid = require('bcrypt').compareSync(\n      req.body.password, // 第一个参数是客户端发起请求的明文密码值\n      user.password // 第二参数是数据库中的密文密码值\n    )\n    if (!isPasswordValid) {\n      return res.status(422).send({\n        \"message\": \"输入密码错误\"\n      })\n    }\n\n    <!-- 根据id生成token -->\n    const token = jwt.sign({\n      id: String(user._id) // 这里需要注意的是，不要把密码放在token中，可以放一个其他的键，比如_id等。\n      //这里虽然写的形式是对象键值对的形式，但是实际上，token不是一个对象，而是一段hash值，id不会以键值对的形式出现。\n      // 解密时使用 jwt.verify(raw, SECRET) 方法，会得到包含id属性的对象，这里raw就是那段hash值。\n    }, SECRET) // 第二个参数为secret，这个secret不应该出现在代码库中，应该是一个环境变量之类的东西，应该是在.ignore中被忽略上传的东西\n          // 这个secret应该是全局保持唯一的\n    res.send({\n      user,\n      token: token\n    })\n  })\n```\n返回给客户端的结果为\n\n```javascript\n{\n  \"user\": {\n    \"_id\": \"5cce3ac57879e13fc45d3511\",\n    \"email\": \"user3\",\n    \"password\": \"$2b$10$/PJRuI8mnOUpMkB5an8iKOOYqUFAyhBrV6FImTUuU7mmGG6P9Ys5a\",\n    \"__v\": 0\n  },\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjVjY2UzYWM1Nzg3OWUxM2ZjNDVkMzUxMSIsImlhdCI6MTU1NzAxOTMzNn0.22ImaDk_1dkMkEbezu0ByrwkBGXPrlc7Ox-ORJ75oUQ\"\n  // 后面的这段hash值就是上面jwt对user._id加密生成的，并且每次执行发起登录请求时，会根据相同的user._id生成不同的token\n}\n```\n+ 进入个人中心\n\n客户端\n\n```javascript\npost {{url}}/profile\nContent-Type: application/json\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjVjY2UzYWM1Nzg3OWUxM2ZjNDVkMzUxMSIsImlhdCI6MTU1NzAxOTMzNn0.22ImaDk_1dkMkEbezu0ByrwkBGXPrlc7Ox-ORJ75oUQ\n```\n服务端\n\n```javascript\napp.post('/profile', async (req, res) => {\n  var raw = String(req.headers.authorization).split(' ').pop()\n  console.log(jwt.verify(raw, SECRET))\n  // { id: '5cce6f15b7e8724438c8d621', iat: 1557034387 }\n  const { id } = jwt.verify(raw, SECRET) // 当初用_id做的密钥，所以现在解密_id，再用_id做条件查找\n  const user = await User.findById(id)\n  res.send(user)\n})\n```\n  可以提取中间件 \n\n```javascript\n// 用户登录获取信息中间件\nconst authMiddleware = async (req, res, next) => {\n  var raw = String(req.headers.authorization).split(' ').pop()\n  const { id } = jwt.verify(raw, SECRET)\n  req.user = await User.findById(id) // 将查询的结果以属性的方式保存在req中\n  next() \n}\n```\n  服务端改写为\n\n```javascript\napp.post('/profile', authMiddleware, async (req, res) => {\n  res.send(req.user)\n})\n```\n\n## cookie方式\n\n+ 安装和导入express-session\n\n```bash\nnpm i express-session\n```\n```javascript\nconst session = require('express-session')\n```\n+ 配置中间件\n\n```javascript\n<!-- 中间件一定要放在使用之前 -->\napp.use(session({ \n  secret: 'keyboard cat', // 密钥\n  resave: false,\n  saveUninitialized: true \n}))\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n  const user = await User.findOne({\n    email: req.body.email\n  })\n  if (!user) {\n    // 一般用户提交的数据有问题，状态吗是422\n    return res.status(422).send({\n      \"message\": \"用户名不存在\"\n    })\n  }\n\n  <!-- 校验密码是否正确 -->\n  // 使用bcrypt模块的 compareSync() 方法，对密码进行校验比对，该方法的返回值是true或者false\n  const isPasswordValid = require('bcrypt').compareSync(\n    req.body.password, // 第一个参数是客户端发起请求的明文密码值\n    user.password // 第二参数是数据库中的密文密码值\n  )\n  if (!isPasswordValid) {\n    return res.status(422).send({\n      \"message\": \"输入密码错误\"\n    })\n  }\n\n  <!-- 成功验证后，将查询到的用户放入cookie -->\n  req.session.user = user\n  res.status(200).json({ // 返回成功信息\n    err_code: 200,\n    message: 'ok'\n  })\n})\n```\n+ 进入个人中心\n\n```javascript\napp.post('/profile', async (req, res) => {\n  console.log(req.session)\n  res.send(req.session)\n})\n```\n+ 返回结果\n\n```javascript\n{ _id: '5cce56bbecd3734398851c80',\n  email: 'user12',\n  password: '123456',\n  date: '2019-05-05T03:21:31.457Z',\n  __v: 0 }\n```\n","slug":"nodejs_review4","published":1,"updated":"2020-01-20T07:45:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gin003elktvd3ryz5ql"},{"title":"node.js复习5：bcrypt加密和md5加密","abbrlink":"dbf676e6","date":"2019-05-01T06:00:00.000Z","_content":"\n## 注意：\n+ md5加密方式：每个字母对应的hash值是相同的，md5有密文对应表。两个人有两个相同的密码，对应的加密后的hash也是一样的。\n+ bcrypt加密方式：对于相同的字符串，加密几次的hash值都是不一样的。也就是说两个人有相同的密码，对应加密后的hash是不一样的。bcrypt更加安全\n<!-- more -->\n+ md5使用注册时加密密码相同的算法，再次对登录时的密码做加密处理，然后当作查询条件去做组合查询，实质是email和password做多条件组合查询。\n+ bcrypt先根据email查出用户的信息，在使用`bcrypt.compareSync( req.body.password, user.password)`方法对用户登录时输入的密码和查出的用户信息中的密码做一个比对，比对成功则返回true，证明验证成功。实质上在验证密码是否合法之前，已经根据email将所需要的个人信息查出来了。\n\n## md5方式：\n+ 安装及导入\n\n```bash\nnpm i blueimp-md5\n```\n```javascript\nvar md5 = require('blueimp-md5')\nconst MD5SECRET = 'masia66666' // 配置一个密钥\n```\n+ 注册\n\n```javascript\napp.post('/register', async (req, res) => {\n  req.body.password = md5(md5(req.body.password + MD5SECRET)) // 把密钥拼在密码后面，并且加密两次\n  const user = await User.create({\n    email: req.body.email,\n    password: req.body.password\n  })\n  res.send(user)\n})\n```\n返回结果为：\n\n```javscript\n{\n  \"_id\": \"5cce5d7d4a6a314744d31a30\",\n  \"email\": \"user20\",\n  \"password\": \"cf147405dd20224eae703c23ecc3fa8d\",\n  \"date\": \"2019-05-05T03:50:21.842Z\",\n  \"__v\": 0\n}\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n  req.body.password = md5(md5(req.body.password  + MD5SECRET)) // 把登录时输入的密码加密了一遍，再与数据库中注册时间加密过的密码作比较\n  const user = await User.findOne({\n    email: req.body.email,\n    password: req.body.password  \n  })\n  res.send(user)\n})\n```\n+ 可以对密码加密的这一步写一个中间件\n\n```javascript\nconst md5MiddleWare = (req, res, next) => {\n  var password = req.body.password\n  req.password = md5(md5(password + MD5SECRET))\n  next()\n}\n```\n+ 注册使用中间件\n\n```javascript\napp.post('/register', md5MiddleWare, async (req, res) => {\n  const user = await User.creat({\n    email: req.body.email,\n    password: req.password\n  })\n  res.send(user)\n})\n```\n+ 登录使用中间件\n\n```javascript\napp.post('/login', md5MiddleWare, async (req, res) => {\n  const user = await User.findOne({\n    email: req.body.email,\n    password: req.password  \n  })\n  res.send(user)\n})\n```\n\n## bcrypt加密方式：\n+ 安装及其导入\n\n```bash\nnpm i bcrypt\n```\n```javascript\nconst bcrypt = require('bcrypt')\n```\n+ 在创建模型时使用，对password进行加密\n\n```javascript\nconst UserSchema = new mongoose.Schema({\n  email: {\n    type: String, \n    unique: true\n  },\n  password: {\n    type: String,\n    set (a) { // 在模型调用password属性时，调用这个set方法，a就是password的值\n      // 使用bctypt包，实现原理很复杂，但是实现起来很简单 ，直接调库就好\n      return bcrypt.hashSync(a, 10)\n                              // 同步方法     指数，指数越高，生成的散列值越复杂，但是花费的时间也长时，但是设置的太低，安全性又很低\n    }\n  }\n})\nconst User = mongoose.model('User', UserSchema)\n```\n+ 注册\n\n```javascript\napp.post('/register', async (req, res) => {\n  const user = await User.create({\n    email: req.body.email,\n    password: req.body.password \n  })\n  res.send(user)\n})\n```\n结果：\n\n```javascript\n{\n  \"_id\": \"5cce6f15b7e8724438c8d621\",\n  \"email\": \"user26\",\n  \"password\": \"$2b$10$DE.qpGfozZnUJs2r50C/XOw5NdIrg9Hdf2GJen3lzxa3vCoLhMVU6\", // 密码已经经过处理\n  \"date\": \"2019-05-05T05:05:25.817Z\",\n  \"__v\": 0\n}\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n  <!-- 先根据email找用户 -->\n  const user = await User.findOne({\n    email: req.body.email\n  })\n  if (!user) {\n    // 一般用户提交的数据有问题，状态吗是422\n    return res.status(422).send({\n      \"message\": \"用户名不存在\"\n    })\n  }\n  // 使用bcrypt模块的 compareSync() 方法，对密码进行校验比对，该方法的返回值是true或者false\n  const isPasswordValid = bcrypt.compareSync(\n    req.body.password, // 第一个参数是客户端发起请求的明文密码值\n    user.password // 第二参数是数据库中的密文密码值\n  )\n  if (!isPasswordValid) {\n    return res.status(422).send({\n      \"message\": \"输入密码错误\"\n    })\n  }\n  res.send(user)\n})\n```\n结果：\n\n```javascript\n{\n  \"_id\": \"5cce6f15b7e8724438c8d621\",\n  \"email\": \"user26\",\n  \"password\": \"$2b$10$DE.qpGfozZnUJs2r50C/XOw5NdIrg9Hdf2GJen3lzxa3vCoLhMVU6\",\n  \"date\": \"2019-05-05T05:05:25.817Z\",\n  \"__v\": 0\n}\n```","source":"_posts/nodejs_review5.md","raw":"---\ntitle: node.js复习5：bcrypt加密和md5加密\ncategories:\n  - node.js\n  - 加密方式\ntags:\n  - node.js\n  - 加密方式\nabbrlink: dbf676e6\ndate: 2019-05-01 14:00:00\n---\n\n## 注意：\n+ md5加密方式：每个字母对应的hash值是相同的，md5有密文对应表。两个人有两个相同的密码，对应的加密后的hash也是一样的。\n+ bcrypt加密方式：对于相同的字符串，加密几次的hash值都是不一样的。也就是说两个人有相同的密码，对应加密后的hash是不一样的。bcrypt更加安全\n<!-- more -->\n+ md5使用注册时加密密码相同的算法，再次对登录时的密码做加密处理，然后当作查询条件去做组合查询，实质是email和password做多条件组合查询。\n+ bcrypt先根据email查出用户的信息，在使用`bcrypt.compareSync( req.body.password, user.password)`方法对用户登录时输入的密码和查出的用户信息中的密码做一个比对，比对成功则返回true，证明验证成功。实质上在验证密码是否合法之前，已经根据email将所需要的个人信息查出来了。\n\n## md5方式：\n+ 安装及导入\n\n```bash\nnpm i blueimp-md5\n```\n```javascript\nvar md5 = require('blueimp-md5')\nconst MD5SECRET = 'masia66666' // 配置一个密钥\n```\n+ 注册\n\n```javascript\napp.post('/register', async (req, res) => {\n  req.body.password = md5(md5(req.body.password + MD5SECRET)) // 把密钥拼在密码后面，并且加密两次\n  const user = await User.create({\n    email: req.body.email,\n    password: req.body.password\n  })\n  res.send(user)\n})\n```\n返回结果为：\n\n```javscript\n{\n  \"_id\": \"5cce5d7d4a6a314744d31a30\",\n  \"email\": \"user20\",\n  \"password\": \"cf147405dd20224eae703c23ecc3fa8d\",\n  \"date\": \"2019-05-05T03:50:21.842Z\",\n  \"__v\": 0\n}\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n  req.body.password = md5(md5(req.body.password  + MD5SECRET)) // 把登录时输入的密码加密了一遍，再与数据库中注册时间加密过的密码作比较\n  const user = await User.findOne({\n    email: req.body.email,\n    password: req.body.password  \n  })\n  res.send(user)\n})\n```\n+ 可以对密码加密的这一步写一个中间件\n\n```javascript\nconst md5MiddleWare = (req, res, next) => {\n  var password = req.body.password\n  req.password = md5(md5(password + MD5SECRET))\n  next()\n}\n```\n+ 注册使用中间件\n\n```javascript\napp.post('/register', md5MiddleWare, async (req, res) => {\n  const user = await User.creat({\n    email: req.body.email,\n    password: req.password\n  })\n  res.send(user)\n})\n```\n+ 登录使用中间件\n\n```javascript\napp.post('/login', md5MiddleWare, async (req, res) => {\n  const user = await User.findOne({\n    email: req.body.email,\n    password: req.password  \n  })\n  res.send(user)\n})\n```\n\n## bcrypt加密方式：\n+ 安装及其导入\n\n```bash\nnpm i bcrypt\n```\n```javascript\nconst bcrypt = require('bcrypt')\n```\n+ 在创建模型时使用，对password进行加密\n\n```javascript\nconst UserSchema = new mongoose.Schema({\n  email: {\n    type: String, \n    unique: true\n  },\n  password: {\n    type: String,\n    set (a) { // 在模型调用password属性时，调用这个set方法，a就是password的值\n      // 使用bctypt包，实现原理很复杂，但是实现起来很简单 ，直接调库就好\n      return bcrypt.hashSync(a, 10)\n                              // 同步方法     指数，指数越高，生成的散列值越复杂，但是花费的时间也长时，但是设置的太低，安全性又很低\n    }\n  }\n})\nconst User = mongoose.model('User', UserSchema)\n```\n+ 注册\n\n```javascript\napp.post('/register', async (req, res) => {\n  const user = await User.create({\n    email: req.body.email,\n    password: req.body.password \n  })\n  res.send(user)\n})\n```\n结果：\n\n```javascript\n{\n  \"_id\": \"5cce6f15b7e8724438c8d621\",\n  \"email\": \"user26\",\n  \"password\": \"$2b$10$DE.qpGfozZnUJs2r50C/XOw5NdIrg9Hdf2GJen3lzxa3vCoLhMVU6\", // 密码已经经过处理\n  \"date\": \"2019-05-05T05:05:25.817Z\",\n  \"__v\": 0\n}\n```\n+ 登录\n\n```javascript\napp.post('/login', async (req, res) => {\n  <!-- 先根据email找用户 -->\n  const user = await User.findOne({\n    email: req.body.email\n  })\n  if (!user) {\n    // 一般用户提交的数据有问题，状态吗是422\n    return res.status(422).send({\n      \"message\": \"用户名不存在\"\n    })\n  }\n  // 使用bcrypt模块的 compareSync() 方法，对密码进行校验比对，该方法的返回值是true或者false\n  const isPasswordValid = bcrypt.compareSync(\n    req.body.password, // 第一个参数是客户端发起请求的明文密码值\n    user.password // 第二参数是数据库中的密文密码值\n  )\n  if (!isPasswordValid) {\n    return res.status(422).send({\n      \"message\": \"输入密码错误\"\n    })\n  }\n  res.send(user)\n})\n```\n结果：\n\n```javascript\n{\n  \"_id\": \"5cce6f15b7e8724438c8d621\",\n  \"email\": \"user26\",\n  \"password\": \"$2b$10$DE.qpGfozZnUJs2r50C/XOw5NdIrg9Hdf2GJen3lzxa3vCoLhMVU6\",\n  \"date\": \"2019-05-05T05:05:25.817Z\",\n  \"__v\": 0\n}\n```","slug":"nodejs_review5","published":1,"updated":"2020-01-20T07:45:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gio003hlktvpgauncnv"},{"title":"node.js复习6：数据模型设计","abbrlink":"806847e1","date":"2019-05-02T05:00:00.000Z","_content":"\n数据模型一般存放在model目录中\n<!-- more -->\n## 用户数据模型设计(user.js)\n\n+ 连接数据库\n```javascript\nconst mongoose = require('mongoose')\nmongoose.connect('mongodb://localhost:27017/node_template', {\n  useCreateIndex: true,\n  useNewUrlParser: true\n})\n```\n\n+ 定义模型\n```javascript\nconst UserSchema = new mongoose.Schema({\n  email: { // 登录账号\n    type: String,\n    unique: true\n  },\n  nickname: { // 昵称\n    type: String,\n    required: true\n  },\n  password: { // 密码\n    type: String,\n    set (a) {\n      // 使用bctypt包，实现原理很复杂，但是实现起来很简单 ，直接调库就好\n      return require('bcrypt').hashSync(a, 10)\n                              // 同步方法     指数，指数越高，生成的散列值越复杂，但是用的时间也长时，但是设置的太低，安全性又很低\n    }\n  },\n  created_time: { // 创建时间\n    type: Date,\n    // 传给数据库模块的时候，数据库模块发现这里是个方法，所以它就会调用这个方法，这时候，就会有真正的创建时间了\n    // 如果这里改为Date.now(), 就会在user.js执行的时候立即调用这个方法,此时拿到的是一个相对在数据库模块创建时\n    // 的过去时间,也就是相当于一个无效的死值\n    // 所以注意不要写成Date.now()\n    default: Date.now\n  },\n  last_modified_time: { // 最后修改时间\n    type: Date,\n    default: Date.now()\n  },\n  avatar: { // 头像\n    type: String,\n    default: '/public/img/youxiang.jpg'\n  },\n  bio: { // 个人简介 biography\n    type: String,\n    default: ''\n  },\n  gender: { // 性别\n    type: Number,\n    enum: [-1, 0, 1],\n    default: -1\n  },\n  birthday: { // 生日\n    type: Date,\n    default: ''\n  },\n  status: { // 权限状态\n    type: Number,\n    // 0 没有权限限制\n    // 1 不可以评论\n    // 2 不可以登录\n    // 是否可以评论\n    //是否可以登录使用\n    enum: [0, 1, 2], \n    default: 0\n  }\n})\n```\n\n+ 创建模型\n```javascript\nconst User = mongoose.model('User', UserSchema)\n// 或者直接导出, 适用于这个模块中只有一个模型\n// module.exports = mongoose.model('User', UserSchema)\n// 使用模块需要一个变量接收\n// const User = require('./user')\n```\n\n+ 导出对象\n```javascript\nmodule.exports = {\n  User\n}\n// 使用模块使用对象来接收，适用于这个模块中含有多个模型，使用模块可以按需导入\n// const { User } = require('./user')\n```","source":"_posts/nodejs_review6.md","raw":"---\ntitle: node.js复习6：数据模型设计\ncategories:\n  - node.js\n  - mongodb\n  - mongoose\ntags:\n  - node.js\n  - mongodb\n  - mongoose\nabbrlink: '806847e1'\ndate: 2019-05-02 13:00:00\n---\n\n数据模型一般存放在model目录中\n<!-- more -->\n## 用户数据模型设计(user.js)\n\n+ 连接数据库\n```javascript\nconst mongoose = require('mongoose')\nmongoose.connect('mongodb://localhost:27017/node_template', {\n  useCreateIndex: true,\n  useNewUrlParser: true\n})\n```\n\n+ 定义模型\n```javascript\nconst UserSchema = new mongoose.Schema({\n  email: { // 登录账号\n    type: String,\n    unique: true\n  },\n  nickname: { // 昵称\n    type: String,\n    required: true\n  },\n  password: { // 密码\n    type: String,\n    set (a) {\n      // 使用bctypt包，实现原理很复杂，但是实现起来很简单 ，直接调库就好\n      return require('bcrypt').hashSync(a, 10)\n                              // 同步方法     指数，指数越高，生成的散列值越复杂，但是用的时间也长时，但是设置的太低，安全性又很低\n    }\n  },\n  created_time: { // 创建时间\n    type: Date,\n    // 传给数据库模块的时候，数据库模块发现这里是个方法，所以它就会调用这个方法，这时候，就会有真正的创建时间了\n    // 如果这里改为Date.now(), 就会在user.js执行的时候立即调用这个方法,此时拿到的是一个相对在数据库模块创建时\n    // 的过去时间,也就是相当于一个无效的死值\n    // 所以注意不要写成Date.now()\n    default: Date.now\n  },\n  last_modified_time: { // 最后修改时间\n    type: Date,\n    default: Date.now()\n  },\n  avatar: { // 头像\n    type: String,\n    default: '/public/img/youxiang.jpg'\n  },\n  bio: { // 个人简介 biography\n    type: String,\n    default: ''\n  },\n  gender: { // 性别\n    type: Number,\n    enum: [-1, 0, 1],\n    default: -1\n  },\n  birthday: { // 生日\n    type: Date,\n    default: ''\n  },\n  status: { // 权限状态\n    type: Number,\n    // 0 没有权限限制\n    // 1 不可以评论\n    // 2 不可以登录\n    // 是否可以评论\n    //是否可以登录使用\n    enum: [0, 1, 2], \n    default: 0\n  }\n})\n```\n\n+ 创建模型\n```javascript\nconst User = mongoose.model('User', UserSchema)\n// 或者直接导出, 适用于这个模块中只有一个模型\n// module.exports = mongoose.model('User', UserSchema)\n// 使用模块需要一个变量接收\n// const User = require('./user')\n```\n\n+ 导出对象\n```javascript\nmodule.exports = {\n  User\n}\n// 使用模块使用对象来接收，适用于这个模块中含有多个模型，使用模块可以按需导入\n// const { User } = require('./user')\n```","slug":"nodejs_review6","published":1,"updated":"2020-01-20T07:45:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gip003mlktv2o2luhqm"},{"title":"nvm安装","time":"2019-04-25T16:00:00.000Z","_content":"### nvm用来管理多个版本的node\n但是在安装nvm之前如果本机已经安装了node，那么需要先删除node所配置的环境变量，比如在系统环境变量中的NODE_HOME等\n<!-- more -->\n# 下载安装nvm\n1. \n[nvm](https://github.com/coreybutler/nvm-windows/releases)，并且选择nvm-setup.zip，下载并解压\n\n2. 选择安装目录，会让你选择两次\n第一次选择的是nvm的系统目录，里面包含了nvm.exe等。我选择的目录是`D:\\nvm\\nvm`\n第二次选择的nodejs是一个快捷方式目录，我选择的是`D:\\nvm\\nodejs`\n\n  1. 其实nvm的原理就是在使用命令`nvm use nodejs版本`选择nodejs版本的时候，nvm帮你把`D:\\nvm\\nodejs`这个目录的指向换成了指定的版本号对应的nodejs目录。\n  2. 所有的nodejs的目录全部放在nvm中，比如你执行 `nvm use 12.6.0`，他就会先去 `D:\\nvm\\nvm` 中找有没有v12.6.0这个目录，如果有的话，他就把`D:\\nvm\\nodejs`这个文件目录的变成`D:\\nvm\\v12.6.0`的一个快捷方式。\n  3. 如果在`D:\\nvm\\nvm`中没有找到v12.6.0这个目录，那你必须先使用命令`nvm install 12.5.0`来把v12.5.0版本的nodejs安装包下载到`D:\\nvm`中，然后再去使用`nvm use 12.6.0`修改`D:\\nvm\\nodejs`的指向。\n\n{% asset_img nvm_install4.png nvm和nodejs目录说明 %}\n{% asset_img nvm_install2.png D:\\nvm中有两个版本的nodejs文件包 %}\n\n3. 配置环境变量\n  1. 用户环境变量\n  先在用户环境变量中的`path`中配置nvm的环境变量，在path中加入`D:\\nvm`,其实配置环境变量就是你在命令框中执行nvm指令的时候，他要去在环境变量中配置的目录路径去找有没有nvm.cmd或者nvm.exe，有的话才能在命令行中正常执行。否则他就会输出`nvm不是内部或者外部指令`\n  2. 系统环境变量\n  在系统环境变量中先定义两个变量`NVM_HOME=D:\\nvm\\nvm`和`NVM_SYMLINK=D:\\nvm\\nodejs`，然后再把这两个变量加到`path`中。（这里有点我有点疑惑的是网上的教程只在系统环境变量中写了`NVM_HOME=D:\\nvm\\nvm`并且加入path，然后在命令行执行`nvm -v`就正常执行了，而我这样配置却没有生效。所以我在用户环境变量中的path中写了`D:\\nvm\\nvm`，才可以正常执行`nvm`。但是执行node相关的命令是正常的，也就意味着`NVM_SYMLINK=D:\\nvm\\nodejs`生效了，系统可以通过`NVM_SYMLINK=D:\\nvm\\nodejs`这个环境变量来找到`D:\\nvm\\nodejs`目录下面的`node.exe`\n{% asset_img nvm_install3.png 执行命令就是通过环境变量所指的目录去寻找该目录下面对应的可执行程序 %}\n\n4. 配置npm的全局安装目录\n  1. 这个目录里面放的是通过npm来安装的一些全局的包，比如通过`npm i webpack@3.6.0 -g`安装的全局的webpack@3.6.0目录就在这里。\n  2. 执行命令`npm config set prefix \"D:\\nvm\\npm\"`，执行完成之后会在`C:\\Users\\MA`中出现一个名为`.npmrc`的文件，里面的内容是prefix=D:\\nvm\\npm，\n  `npm config set prefix 目录`的意思是设置npm的全局安装目录，后面生成的那个文件暂时没明白是啥意思。\n  3. 为这个npm的全局安装目录编写环境变量，在用户环境变量中的path中加入`D:\\nvm\\npm`\n5. 使用npm全局安装nodemon等工具\n  1. `npm i nodemon -g`\n  2. `nodemon -v`，打印输出nodemon的版本\n{% asset_img nvm_install5.png %}\n\n\n### 总结：","source":"_posts/nvm安装.md","raw":"---\ntitle: nvm安装\ncategories: \n  - 安装\n  - nvm\ntags: \n  - 安装\n  - nvm\ntime: 2019-04-26\n---\n### nvm用来管理多个版本的node\n但是在安装nvm之前如果本机已经安装了node，那么需要先删除node所配置的环境变量，比如在系统环境变量中的NODE_HOME等\n<!-- more -->\n# 下载安装nvm\n1. \n[nvm](https://github.com/coreybutler/nvm-windows/releases)，并且选择nvm-setup.zip，下载并解压\n\n2. 选择安装目录，会让你选择两次\n第一次选择的是nvm的系统目录，里面包含了nvm.exe等。我选择的目录是`D:\\nvm\\nvm`\n第二次选择的nodejs是一个快捷方式目录，我选择的是`D:\\nvm\\nodejs`\n\n  1. 其实nvm的原理就是在使用命令`nvm use nodejs版本`选择nodejs版本的时候，nvm帮你把`D:\\nvm\\nodejs`这个目录的指向换成了指定的版本号对应的nodejs目录。\n  2. 所有的nodejs的目录全部放在nvm中，比如你执行 `nvm use 12.6.0`，他就会先去 `D:\\nvm\\nvm` 中找有没有v12.6.0这个目录，如果有的话，他就把`D:\\nvm\\nodejs`这个文件目录的变成`D:\\nvm\\v12.6.0`的一个快捷方式。\n  3. 如果在`D:\\nvm\\nvm`中没有找到v12.6.0这个目录，那你必须先使用命令`nvm install 12.5.0`来把v12.5.0版本的nodejs安装包下载到`D:\\nvm`中，然后再去使用`nvm use 12.6.0`修改`D:\\nvm\\nodejs`的指向。\n\n{% asset_img nvm_install4.png nvm和nodejs目录说明 %}\n{% asset_img nvm_install2.png D:\\nvm中有两个版本的nodejs文件包 %}\n\n3. 配置环境变量\n  1. 用户环境变量\n  先在用户环境变量中的`path`中配置nvm的环境变量，在path中加入`D:\\nvm`,其实配置环境变量就是你在命令框中执行nvm指令的时候，他要去在环境变量中配置的目录路径去找有没有nvm.cmd或者nvm.exe，有的话才能在命令行中正常执行。否则他就会输出`nvm不是内部或者外部指令`\n  2. 系统环境变量\n  在系统环境变量中先定义两个变量`NVM_HOME=D:\\nvm\\nvm`和`NVM_SYMLINK=D:\\nvm\\nodejs`，然后再把这两个变量加到`path`中。（这里有点我有点疑惑的是网上的教程只在系统环境变量中写了`NVM_HOME=D:\\nvm\\nvm`并且加入path，然后在命令行执行`nvm -v`就正常执行了，而我这样配置却没有生效。所以我在用户环境变量中的path中写了`D:\\nvm\\nvm`，才可以正常执行`nvm`。但是执行node相关的命令是正常的，也就意味着`NVM_SYMLINK=D:\\nvm\\nodejs`生效了，系统可以通过`NVM_SYMLINK=D:\\nvm\\nodejs`这个环境变量来找到`D:\\nvm\\nodejs`目录下面的`node.exe`\n{% asset_img nvm_install3.png 执行命令就是通过环境变量所指的目录去寻找该目录下面对应的可执行程序 %}\n\n4. 配置npm的全局安装目录\n  1. 这个目录里面放的是通过npm来安装的一些全局的包，比如通过`npm i webpack@3.6.0 -g`安装的全局的webpack@3.6.0目录就在这里。\n  2. 执行命令`npm config set prefix \"D:\\nvm\\npm\"`，执行完成之后会在`C:\\Users\\MA`中出现一个名为`.npmrc`的文件，里面的内容是prefix=D:\\nvm\\npm，\n  `npm config set prefix 目录`的意思是设置npm的全局安装目录，后面生成的那个文件暂时没明白是啥意思。\n  3. 为这个npm的全局安装目录编写环境变量，在用户环境变量中的path中加入`D:\\nvm\\npm`\n5. 使用npm全局安装nodemon等工具\n  1. `npm i nodemon -g`\n  2. `nodemon -v`，打印输出nodemon的版本\n{% asset_img nvm_install5.png %}\n\n\n### 总结：","slug":"nvm安装","published":1,"date":"2020-01-20T07:45:11.000Z","updated":"2020-01-20T07:45:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75giq003plktvm50dr6ay"},{"title":"sass的使用","_content":"+ 定义变量，使用$\n<!-- more -->\n```css\n$mainColor: #ccc;\n$siteWidth: 1024px;\n$borderStyle: dotted;\nbody {\n  color: $maincolor;\n  width: $siteWidth;\n  border: 1px $borderStyle $mainColor;\n}\n```\n+ 运算符号\n```css\nbody {\n  margin: (14px/2);\n  top: 50px + 100px;\n  right: 80 * 10%;\n}\n```\n+ 颜色函数\nCSS 预处理器一般都会内置一些颜色处理函数用来对颜色值进行处理，例如加亮、变暗、颜色梯度等。\n1.sass的颜色处理函数：\n```css\nlighten($color, 10%); \ndarken($color, 10%);  \nsaturate($color, 10%);   \ndesaturate($color, 10%);\ngrayscale($color);  \ncomplement($color); \ninvert($color); \nmix($color1, $color2, 50%);\n```\n```css\n$color: #0982C1;\nh1 {\n  background: $color;\n  border: 3px solid darken($color, 50%);\n}\n```\n+ 导入 (Import)\n注意：导入文件中定义的混入、变量等信息也将会被引入到主样式文件中，因此需要避免它们互相冲突。 \nscss中的导入只是将多个文件合并成了同一个文件，导入的文件在导入语句之后生效，如：@import \"style/index.scss\"\n如下a.scss中引入了b.scss: \n\na.scss:\n```scss\n$width : 100px;\n\n.before {\n  width: $width;\n}\n\n@import \"b\";\n\n.after {\n  width: $width;\n}\n\n.container {\n  width: $width;\n  height: $height;\n  border: 1px solid;\n}\n```\nb.scss:\n```scss\n$width : 200px;\n$height : 200px\n```\n\n最后生成的\n```css\n.before {\n  width: 100px; \n}\n.after {\n  width: 200px; \n}\n.container {\n  width: 200px;\n  height: 200px;\n  border: 1px solid;\n}\n```\n默认值：$width : 200px !default\n用法：可以在被引入的文件中定义默认值，主文件@import这个文件后，如果主文件中变量有定义，就不会被覆盖。\n+ 继承\nsass可通过@extend来实现代码组合声明，使代码更加优越简洁。\n```scss\n.message {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n.success {\n  @extend .message;\n  border-color: green;\n}\n.error {\n  @extend .message;\n  border-color: red;\n}\n.warning {\n  @extend .message;\n  border-color: yellow;\n}\n```\n结果：\n```css\n.message, .success, .error, .warning {\n  border: 1px solid #cccccc;\n  padding: 10px;\n  color: #333;\n}\n.success {\n  border-color: green;\n}\n.error {\n  border-color: red;\n}\n.warning {\n  border-color: yellow;\n}\n```\n+ Mixins（混入）这个混入就好比在某个样式类中执行了一个定义好的函数，返回值就是这些函数里面的东西\nMixins 有点像是函数或者是宏，当某段 CSS 经常需要在多个元素中使用时，可以为这些共用的 CSS 定义一个 Mixin，然后只需要在需要引用这些 CSS 地方调用该 Mixin 即可。\n1.Sass 的混入语法\nsass中可用mixin定义一些代码片段，且可传参数，方便日后根据需求调用。比如说处理css3浏览器前缀：\n```scss\n@mixin error($borderWidth: 2px) {\n  border: $borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  @ include error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  @ include error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\n# 使用场景\n+ 3D文本\n要生成具有 3D 效果的文本可以使用 text-shadows ，唯一的问题就是当要修改颜色的时候就非常的麻烦，而通过 mixin 和颜色函数可以很轻松的实现：\n```scss\n@mixin text3d($color) {\n  color: $color;\n  text-shadow: 1px 1px 0px darken($color, 5%),\n               2px 2px 0px darken($color, 10%),\n               3px 3px 0px darken($color, 15%),\n               4px 4px 0px darken($color, 20%),\n               4px 4px 2px #000;\n}\n\nh1 {\n  font-size: 32pt;\n  @ include text3d(#0982c1);\n}\n```\n+ 高级语法\n在sass中，还支持条件语句： @if可一个条件单独使用，也可以和@else结合多条件使用\n```scss\n$lte7: true;\n$type: monster;\n.ib{\n    display:inline-block;\n    @if $lte7 {\n        *display:inline;\n        *zoom:1;\n    }\n}\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n```\n结果：\n```scss\n.ib{\n    display:inline-block;\n    *display:inline;\n    *zoom:1;\n}\np {\n  color: green; \n}\n```\n+ for循环\n以后再说","source":"_posts/sass的使用.md","raw":"---\ntitle: sass的使用\ncategories:\n  - css\n  - sass\ntags:\n  - css\n  - sass\n---\n+ 定义变量，使用$\n<!-- more -->\n```css\n$mainColor: #ccc;\n$siteWidth: 1024px;\n$borderStyle: dotted;\nbody {\n  color: $maincolor;\n  width: $siteWidth;\n  border: 1px $borderStyle $mainColor;\n}\n```\n+ 运算符号\n```css\nbody {\n  margin: (14px/2);\n  top: 50px + 100px;\n  right: 80 * 10%;\n}\n```\n+ 颜色函数\nCSS 预处理器一般都会内置一些颜色处理函数用来对颜色值进行处理，例如加亮、变暗、颜色梯度等。\n1.sass的颜色处理函数：\n```css\nlighten($color, 10%); \ndarken($color, 10%);  \nsaturate($color, 10%);   \ndesaturate($color, 10%);\ngrayscale($color);  \ncomplement($color); \ninvert($color); \nmix($color1, $color2, 50%);\n```\n```css\n$color: #0982C1;\nh1 {\n  background: $color;\n  border: 3px solid darken($color, 50%);\n}\n```\n+ 导入 (Import)\n注意：导入文件中定义的混入、变量等信息也将会被引入到主样式文件中，因此需要避免它们互相冲突。 \nscss中的导入只是将多个文件合并成了同一个文件，导入的文件在导入语句之后生效，如：@import \"style/index.scss\"\n如下a.scss中引入了b.scss: \n\na.scss:\n```scss\n$width : 100px;\n\n.before {\n  width: $width;\n}\n\n@import \"b\";\n\n.after {\n  width: $width;\n}\n\n.container {\n  width: $width;\n  height: $height;\n  border: 1px solid;\n}\n```\nb.scss:\n```scss\n$width : 200px;\n$height : 200px\n```\n\n最后生成的\n```css\n.before {\n  width: 100px; \n}\n.after {\n  width: 200px; \n}\n.container {\n  width: 200px;\n  height: 200px;\n  border: 1px solid;\n}\n```\n默认值：$width : 200px !default\n用法：可以在被引入的文件中定义默认值，主文件@import这个文件后，如果主文件中变量有定义，就不会被覆盖。\n+ 继承\nsass可通过@extend来实现代码组合声明，使代码更加优越简洁。\n```scss\n.message {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n.success {\n  @extend .message;\n  border-color: green;\n}\n.error {\n  @extend .message;\n  border-color: red;\n}\n.warning {\n  @extend .message;\n  border-color: yellow;\n}\n```\n结果：\n```css\n.message, .success, .error, .warning {\n  border: 1px solid #cccccc;\n  padding: 10px;\n  color: #333;\n}\n.success {\n  border-color: green;\n}\n.error {\n  border-color: red;\n}\n.warning {\n  border-color: yellow;\n}\n```\n+ Mixins（混入）这个混入就好比在某个样式类中执行了一个定义好的函数，返回值就是这些函数里面的东西\nMixins 有点像是函数或者是宏，当某段 CSS 经常需要在多个元素中使用时，可以为这些共用的 CSS 定义一个 Mixin，然后只需要在需要引用这些 CSS 地方调用该 Mixin 即可。\n1.Sass 的混入语法\nsass中可用mixin定义一些代码片段，且可传参数，方便日后根据需求调用。比如说处理css3浏览器前缀：\n```scss\n@mixin error($borderWidth: 2px) {\n  border: $borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  @ include error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  @ include error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\n# 使用场景\n+ 3D文本\n要生成具有 3D 效果的文本可以使用 text-shadows ，唯一的问题就是当要修改颜色的时候就非常的麻烦，而通过 mixin 和颜色函数可以很轻松的实现：\n```scss\n@mixin text3d($color) {\n  color: $color;\n  text-shadow: 1px 1px 0px darken($color, 5%),\n               2px 2px 0px darken($color, 10%),\n               3px 3px 0px darken($color, 15%),\n               4px 4px 0px darken($color, 20%),\n               4px 4px 2px #000;\n}\n\nh1 {\n  font-size: 32pt;\n  @ include text3d(#0982c1);\n}\n```\n+ 高级语法\n在sass中，还支持条件语句： @if可一个条件单独使用，也可以和@else结合多条件使用\n```scss\n$lte7: true;\n$type: monster;\n.ib{\n    display:inline-block;\n    @if $lte7 {\n        *display:inline;\n        *zoom:1;\n    }\n}\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n```\n结果：\n```scss\n.ib{\n    display:inline-block;\n    *display:inline;\n    *zoom:1;\n}\np {\n  color: green; \n}\n```\n+ for循环\n以后再说","slug":"sass的使用","published":1,"date":"2020-01-20T07:45:13.000Z","updated":"2020-01-20T07:45:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gir003tlktv30soukyt"},{"title":"scss使用心得","_content":"# 在做前端页面的时候，需要提取公共的样式，利用scss可以快速的规定项目主题。\n<!-- more -->\n通过过去对css样式编写以及查看element-variables.scss，得出如下总结：\n```scss\n\n\n// main-color\n$color-primary: #de4306 !default;\n$color-white: #FFFFFF !default;\n$color-black: #000000 !default;\n$color-success: #67C23A !default;\n$color-warning: #E6A23C !default;\n$color-danger: #F56C6C !default;\n$color-info: #909399 !default;\n\n\n\n// Background\n/// color|1|Background Color|4\n$background-color-base: #F5F7FA !default;\n\n// 文本颜色\n/// color|1|Font Color|2\n$color-text-primary: #303133 !default;\n/// color|1|Font Color|2\n$color-text-regular: #606266 !default;\n/// color|1|Font Color|2\n$color-text-secondary: #909399 !default;\n/// color|1|Font Color|2\n$color-text-placeholder: #C0C4CC !default;\n\n\n\n// 通用样式定义\n.color-orange {\n  color: $orange_color;\n}\n.color-gray {\n  color: $gray_color;\n}\n.color-blue {\n  color: $blue_color;\n}\n.color-black {\n  color: $black_color;\n}\n.fl {\n  float: left;\n}\n.fr {\n  float: right;\n}\n.clearFix:after {\n  display: block;\n  content: '';\n  height: 0;\n  clear: both;\n  overflow: hidden;\n}\n.ellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n// 通用mixins定义\n@mixin clearFix () {\n  *zoom: 1;\n  &::after {\n    content: '';\n    display: block;\n    clear: both;\n    height: 0;\n    overflow: hidden;\n  }\n}\n@mixin fl () {\n  float: left;\n}\n@mixin fr () {\n  float: right;\n}\n@mixin ellipsis () {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n@mixin divisionBar ($bg:#a52705) {\n  height: 40px;\n  background: $bg;\n  box-sizing: border-box;\n  padding: 5px 0;\n  line-height: 30px;\n} \n```","source":"_posts/scss使用心得.md","raw":"---\ntitle: scss使用心得\ntags: \n  - css\n  - scss\ncategories: \n  - css\n  - scss\n---\n# 在做前端页面的时候，需要提取公共的样式，利用scss可以快速的规定项目主题。\n<!-- more -->\n通过过去对css样式编写以及查看element-variables.scss，得出如下总结：\n```scss\n\n\n// main-color\n$color-primary: #de4306 !default;\n$color-white: #FFFFFF !default;\n$color-black: #000000 !default;\n$color-success: #67C23A !default;\n$color-warning: #E6A23C !default;\n$color-danger: #F56C6C !default;\n$color-info: #909399 !default;\n\n\n\n// Background\n/// color|1|Background Color|4\n$background-color-base: #F5F7FA !default;\n\n// 文本颜色\n/// color|1|Font Color|2\n$color-text-primary: #303133 !default;\n/// color|1|Font Color|2\n$color-text-regular: #606266 !default;\n/// color|1|Font Color|2\n$color-text-secondary: #909399 !default;\n/// color|1|Font Color|2\n$color-text-placeholder: #C0C4CC !default;\n\n\n\n// 通用样式定义\n.color-orange {\n  color: $orange_color;\n}\n.color-gray {\n  color: $gray_color;\n}\n.color-blue {\n  color: $blue_color;\n}\n.color-black {\n  color: $black_color;\n}\n.fl {\n  float: left;\n}\n.fr {\n  float: right;\n}\n.clearFix:after {\n  display: block;\n  content: '';\n  height: 0;\n  clear: both;\n  overflow: hidden;\n}\n.ellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n// 通用mixins定义\n@mixin clearFix () {\n  *zoom: 1;\n  &::after {\n    content: '';\n    display: block;\n    clear: both;\n    height: 0;\n    overflow: hidden;\n  }\n}\n@mixin fl () {\n  float: left;\n}\n@mixin fr () {\n  float: right;\n}\n@mixin ellipsis () {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n@mixin divisionBar ($bg:#a52705) {\n  height: 40px;\n  background: $bg;\n  box-sizing: border-box;\n  padding: 5px 0;\n  line-height: 30px;\n} \n```","slug":"scss使用心得","published":1,"date":"2020-01-20T07:45:13.000Z","updated":"2020-01-20T07:45:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75git003wlktv7kd52cp3"},{"title":"sublime的快捷键","abbrlink":"5031fbdc","date":"2019-04-26T01:00:00.000Z","_content":"# sublime使用\n熟练的使用编辑器的快捷键，能大大加快开发速度，也能让自己尽快脱离鼠标，熟悉服务器远程开发。\n<!-- more -->\n1. 整行删除`ctrl`+`x`或`ctrl`+`shift`+`k`\n2. 跳到下一行`ctrl`+`enter`\n3. 跳到上一行`ctrl`+`shift`+`enter`\n4. 一次选中一个词`shift`+`ctrl`+`右箭头`\n5. 一次选中一个字或者字母`shift`+`右箭头`\n6. 光标一次跳转一个词`ctrl`+`右箭头`\n7. 单词转大写`ctrl`+`x`\n8. 单词转小写`ctrl`+`y`\n9. 整行选中，并且光标跳到下一行`ctrl`+`l`\n10. 整行移动`ctrl`+`shift`+`上箭头`\n11. 整行向右移动一个缩进`ctrl`+`]`\n12. 整行向左移动一个缩进`ctrl`+`[`\n13. 整行复制`ctrl`+`c`，整行粘贴`ctrl`+`v`\n14. 将你刚刚输入的单词变成标签`ctrl`+`e`\n15. 跳转到文档开头`ctrl`+`home`\n16. 跳转到文档末尾`ctrl`+`end`\n17. 跳转到上一个编辑处`alt`+`-`\n18. 跳转到下一个编辑处`alt`+`shift`+`-`\n19. 自定义长度收起代码`ctrl`+`shift`+`{`，自定义长度展开代码`ctrl`+`shift`+`}`","source":"_posts/sublime使用.md","raw":"---\ntitle: sublime的快捷键\ncategories:\n  - 工具\ntags:\n  - sublime\nabbrlink: 5031fbdc\ndate: 2019-04-26 09:00:00\n---\n# sublime使用\n熟练的使用编辑器的快捷键，能大大加快开发速度，也能让自己尽快脱离鼠标，熟悉服务器远程开发。\n<!-- more -->\n1. 整行删除`ctrl`+`x`或`ctrl`+`shift`+`k`\n2. 跳到下一行`ctrl`+`enter`\n3. 跳到上一行`ctrl`+`shift`+`enter`\n4. 一次选中一个词`shift`+`ctrl`+`右箭头`\n5. 一次选中一个字或者字母`shift`+`右箭头`\n6. 光标一次跳转一个词`ctrl`+`右箭头`\n7. 单词转大写`ctrl`+`x`\n8. 单词转小写`ctrl`+`y`\n9. 整行选中，并且光标跳到下一行`ctrl`+`l`\n10. 整行移动`ctrl`+`shift`+`上箭头`\n11. 整行向右移动一个缩进`ctrl`+`]`\n12. 整行向左移动一个缩进`ctrl`+`[`\n13. 整行复制`ctrl`+`c`，整行粘贴`ctrl`+`v`\n14. 将你刚刚输入的单词变成标签`ctrl`+`e`\n15. 跳转到文档开头`ctrl`+`home`\n16. 跳转到文档末尾`ctrl`+`end`\n17. 跳转到上一个编辑处`alt`+`-`\n18. 跳转到下一个编辑处`alt`+`shift`+`-`\n19. 自定义长度收起代码`ctrl`+`shift`+`{`，自定义长度展开代码`ctrl`+`shift`+`}`","slug":"sublime使用","published":1,"updated":"2020-01-20T07:45:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75giw0040lktv5b7g9t25"},{"title":"vue-awesome-swiper使用","abbrlink":"5debe24f","date":"2019-05-06T08:00:00.000Z","_content":"## vue-awesome-swiper是基于swiper的一个vue组件，我所使用的版本是`\"vue-awesome-swiper\": \"^3.1.3\"`, 是基于swiper4的。\n<!-- more -->\n+ 安装以及导包\n```bash\nnpm i vue-awesome-swiper // 8.5之后的node不需要加 --save\n```\n\n```javasvript\n<!-- mount with global -->\nimport Vue from 'vue'\nimport VueAwesomeSwiper from 'vue-awesome-swiper'\n \n// require styles\nimport 'swiper/dist/css/swiper.css'\n \nVue.use(VueAwesomeSwiper, /* { default global options } */)\n\n<!-- mount with component -->\n// require styles\nimport 'swiper/dist/css/swiper.css'\n \nimport { swiper, swiperSlide } from 'vue-awesome-swiper'\n \nexport default {\n  components: {\n    swiper,\n    swiperSlide\n  }\n}\n\n```\n\n+ 使用\n```javascript\n<template>\n  <swiper :options=\"swiperOption\" ref=\"mySwiper\" @someSwiperEvent=\"callback\">\n    <!-- slides -->\n    <swiper-slide>I'm Slide 1</swiper-slide>\n    <swiper-slide>I'm Slide 2</swiper-slide>\n    <swiper-slide>I'm Slide 3</swiper-slide>\n    <swiper-slide>I'm Slide 4</swiper-slide>\n    <swiper-slide>I'm Slide 5</swiper-slide>\n    <swiper-slide>I'm Slide 6</swiper-slide>\n    <swiper-slide>I'm Slide 7</swiper-slide>\n    <!-- Optional controls -->\n    <div class=\"swiper-pagination\"  slot=\"pagination\"></div>\n    <div class=\"swiper-button-prev\" slot=\"button-prev\"></div>\n    <div class=\"swiper-button-next\" slot=\"button-next\"></div>\n    <div class=\"swiper-scrollbar\"   slot=\"scrollbar\"></div>\n  </swiper>\n</template>\n \n<script>\n// require styles\nimport 'swiper/dist/css/swiper.css'\n \nimport { swiper, swiperSlide } from 'vue-awesome-swiper'\n  export default {\n    name: 'carrousel',\n    data() {\n      return {\n        swiperOption: {\n          // some swiper options/callbacks\n          // 所有的参数同 swiper 官方 api 参数\n          // ...\n        }\n      }\n    },\n    components: {\n      swiper,\n      swiperSlide\n    },\n    computed: {\n      swiper() {\n        return this.$refs.mySwiper.swiper\n      }\n    },\n    mounted() {\n      // current swiper instance\n      // 然后你就可以使用当前上下文内的swiper对象去做你想做的事了\n      console.log('this is current swiper instance object', this.swiper)\n      this.swiper.slideTo(3, 1000, false)\n    }\n  }\n</script>\n```","source":"_posts/vue-awesome-swiper使用.md","raw":"---\ntitle: vue-awesome-swiper使用\ncategories:\n  - vue\n  - vue-awesome-swiper\n  - swiper\ntags:\n  - vue\n  - vue-awesome-swiper\n  - swiper\nabbrlink: 5debe24f\ndate: 2019-05-06 16:00:00\n---\n## vue-awesome-swiper是基于swiper的一个vue组件，我所使用的版本是`\"vue-awesome-swiper\": \"^3.1.3\"`, 是基于swiper4的。\n<!-- more -->\n+ 安装以及导包\n```bash\nnpm i vue-awesome-swiper // 8.5之后的node不需要加 --save\n```\n\n```javasvript\n<!-- mount with global -->\nimport Vue from 'vue'\nimport VueAwesomeSwiper from 'vue-awesome-swiper'\n \n// require styles\nimport 'swiper/dist/css/swiper.css'\n \nVue.use(VueAwesomeSwiper, /* { default global options } */)\n\n<!-- mount with component -->\n// require styles\nimport 'swiper/dist/css/swiper.css'\n \nimport { swiper, swiperSlide } from 'vue-awesome-swiper'\n \nexport default {\n  components: {\n    swiper,\n    swiperSlide\n  }\n}\n\n```\n\n+ 使用\n```javascript\n<template>\n  <swiper :options=\"swiperOption\" ref=\"mySwiper\" @someSwiperEvent=\"callback\">\n    <!-- slides -->\n    <swiper-slide>I'm Slide 1</swiper-slide>\n    <swiper-slide>I'm Slide 2</swiper-slide>\n    <swiper-slide>I'm Slide 3</swiper-slide>\n    <swiper-slide>I'm Slide 4</swiper-slide>\n    <swiper-slide>I'm Slide 5</swiper-slide>\n    <swiper-slide>I'm Slide 6</swiper-slide>\n    <swiper-slide>I'm Slide 7</swiper-slide>\n    <!-- Optional controls -->\n    <div class=\"swiper-pagination\"  slot=\"pagination\"></div>\n    <div class=\"swiper-button-prev\" slot=\"button-prev\"></div>\n    <div class=\"swiper-button-next\" slot=\"button-next\"></div>\n    <div class=\"swiper-scrollbar\"   slot=\"scrollbar\"></div>\n  </swiper>\n</template>\n \n<script>\n// require styles\nimport 'swiper/dist/css/swiper.css'\n \nimport { swiper, swiperSlide } from 'vue-awesome-swiper'\n  export default {\n    name: 'carrousel',\n    data() {\n      return {\n        swiperOption: {\n          // some swiper options/callbacks\n          // 所有的参数同 swiper 官方 api 参数\n          // ...\n        }\n      }\n    },\n    components: {\n      swiper,\n      swiperSlide\n    },\n    computed: {\n      swiper() {\n        return this.$refs.mySwiper.swiper\n      }\n    },\n    mounted() {\n      // current swiper instance\n      // 然后你就可以使用当前上下文内的swiper对象去做你想做的事了\n      console.log('this is current swiper instance object', this.swiper)\n      this.swiper.slideTo(3, 1000, false)\n    }\n  }\n</script>\n```","slug":"vue-awesome-swiper使用","published":1,"updated":"2020-01-20T07:45:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gix0044lktvv6dpkysu"},{"title":"vue-cli3.0使用","date":"2019-06-09T16:00:00.000Z","_content":"# 安装\n<!-- more -->\n + 回顾vue-cli2.0的使用\n```bash\nnpm install -g webpack // 全局安装webpack\nnpm install vue-cli -g // 全局安装vue-cli脚手架构建工具\nvue --version // 或者 vue -V 查看安装vue-cli版本 ，我之前的版本为2.9.3\nvue init webpack vue_practice // 创建项目（需要注意的是，项目名字不能包含“-”）\ncd vue_practice // 进入刚刚创建好的项目目录\nnpm i // 安装项目所需要的依赖\nnpm run dev // 本地启动项目\nnpm run build // 项目打包\nnpm i serve // 安装一个本地模拟服务器，用来运行打包完成的项目\nserve dist // 运行打包完成的项目\n```\n  + vue-cli3.0\n```bash\nnpm i @vue/cli -g\nvue ui // 启动图形化项目的创建\nnpm run serve // 本地项目启动\n```\n\n\n\n","source":"_posts/vue-cli3.0使用.md","raw":"---\ntitle: vue-cli3.0使用\ncategories: \n  - vue\n  - vue-cli3.0\ntags: \n - vue\n - vue-cli3.0\ndate: 2019-06-10\n---\n# 安装\n<!-- more -->\n + 回顾vue-cli2.0的使用\n```bash\nnpm install -g webpack // 全局安装webpack\nnpm install vue-cli -g // 全局安装vue-cli脚手架构建工具\nvue --version // 或者 vue -V 查看安装vue-cli版本 ，我之前的版本为2.9.3\nvue init webpack vue_practice // 创建项目（需要注意的是，项目名字不能包含“-”）\ncd vue_practice // 进入刚刚创建好的项目目录\nnpm i // 安装项目所需要的依赖\nnpm run dev // 本地启动项目\nnpm run build // 项目打包\nnpm i serve // 安装一个本地模拟服务器，用来运行打包完成的项目\nserve dist // 运行打包完成的项目\n```\n  + vue-cli3.0\n```bash\nnpm i @vue/cli -g\nvue ui // 启动图形化项目的创建\nnpm run serve // 本地项目启动\n```\n\n\n\n","slug":"vue-cli3.0使用","published":1,"updated":"2020-01-20T07:45:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75giy0047lktvg0vvdke2"},{"title":"vue问题小结","date":"2019-05-01T01:00:00.000Z","_content":"\n## 使用watch监听路由发生变化后，我们接下来要执行的动作\n<!-- more -->\n+ 问题：进入详情页面时，我们需要从路由中拿到参数id去请求数据，进而渲染数据。一般情况下，我们会在详情页面这样写：\n```javascript\ndata () {\n  return {\n    article_id = ''\n  }\n}\nmounted () {\n  article_id = this.$route.params.id // 1、先从路由中获取传过来的id\n  this.$http.post('/getDetail/', { // 2、发送请求\n    artical_id: this.artical_id\n  }).then((res) => {\n    //数据请求成功的回调...\n  }).catch((err) => {\n    //失败的回调...\n  })\n\n}\n```\n我们会把请求获取路由中参数的操作放在mounted()中，但是mounted()只有在第一次点击此路由的时候执行，但是回退到之前的页面，再次点击进来，不会执行mounted()。\n或者说有圣杯布局的网页，头部和底部固定，内容区域变化，头部有一个导航栏，里面有若干个选项，比如内容1、内容2、内容3。假定内容1、内容2、内容3的路由相同，params参数不同，分别对应为`/detail/1`, `/detail/2`,`/detail/3`点击内容1选项之后，路由变为`/detail/1`，执行详情组件中的mounted()，获取到数据之后，会在网站主体的内容区域显示相应的内容1。然后再点击内容2选项，页面没有发生变化并且没有显示选项内容2对应的内容。这是因为路由没有发生变化而只是params参数发生了变化，页面不会再次调用mounted()钩子函数，所以我们不因该把获取id的操作写在mounted()中。\n+ 解决方案：\n监听$route对象，如果发生变化，则执行接下来我们要的操作。要注意的是mounted()获取id的方法仍然要写，因为没有挂载之前，组件监听到不$route这个对象，所以第一次点击选项卡拿id的操作要在mounted()中执行。\n```javascript\ndata () {\n  return {\n    article_id = ''\n  }\n},\nmounted () {\n  console.log(this.$route.params.id) // 拿到第一次点击选项卡，渲染页面时拿到的id\n},\nwatch: {\n  '$route': 'routerAlter' // watch中不用写this，而且变量名都要用''包起来\n},\nmethods: {\n  routerAlter () {\n    console.log(this.$route.params.id)\n  }\n}\n```\n\n## 监听$route，解决当前页面记录上次页面浏览位置问题\n一般给App.vue中添加一个监听\n```javascript\nwatch: {\n  '$route': function () {\n    window.scrollTo(0, 0) // 此方法并不是在操纵html元素或者是body元素，而是包含html和body元素的整个文档，即使html或者body高度是0，只要整个文档有高度，此方法使用之后依然是有效果的。\n  }\n}\n```\n+ html和body设置height: 100%问题\n  当html和body设置了height: 100%之后，高度就是浏览器可是区域的高度，高度再也不会随着内容的高度而撑开。反之，body和html不设置高度，则他们的高度会随着内容而撑大。\n+ position: fixed\n  设置position: fixed的元素，位置是相对浏览器可视区域而定的。而且他们也不包含的整个文档之中。\n","source":"_posts/vue_solution1.md","raw":"---\ntitle: vue问题小结\ncategories:\n  - 总结\n  - vue\ntags:\n  - 总结\n  - vue\ndate: 2019-05-01 09:00:00\n---\n\n## 使用watch监听路由发生变化后，我们接下来要执行的动作\n<!-- more -->\n+ 问题：进入详情页面时，我们需要从路由中拿到参数id去请求数据，进而渲染数据。一般情况下，我们会在详情页面这样写：\n```javascript\ndata () {\n  return {\n    article_id = ''\n  }\n}\nmounted () {\n  article_id = this.$route.params.id // 1、先从路由中获取传过来的id\n  this.$http.post('/getDetail/', { // 2、发送请求\n    artical_id: this.artical_id\n  }).then((res) => {\n    //数据请求成功的回调...\n  }).catch((err) => {\n    //失败的回调...\n  })\n\n}\n```\n我们会把请求获取路由中参数的操作放在mounted()中，但是mounted()只有在第一次点击此路由的时候执行，但是回退到之前的页面，再次点击进来，不会执行mounted()。\n或者说有圣杯布局的网页，头部和底部固定，内容区域变化，头部有一个导航栏，里面有若干个选项，比如内容1、内容2、内容3。假定内容1、内容2、内容3的路由相同，params参数不同，分别对应为`/detail/1`, `/detail/2`,`/detail/3`点击内容1选项之后，路由变为`/detail/1`，执行详情组件中的mounted()，获取到数据之后，会在网站主体的内容区域显示相应的内容1。然后再点击内容2选项，页面没有发生变化并且没有显示选项内容2对应的内容。这是因为路由没有发生变化而只是params参数发生了变化，页面不会再次调用mounted()钩子函数，所以我们不因该把获取id的操作写在mounted()中。\n+ 解决方案：\n监听$route对象，如果发生变化，则执行接下来我们要的操作。要注意的是mounted()获取id的方法仍然要写，因为没有挂载之前，组件监听到不$route这个对象，所以第一次点击选项卡拿id的操作要在mounted()中执行。\n```javascript\ndata () {\n  return {\n    article_id = ''\n  }\n},\nmounted () {\n  console.log(this.$route.params.id) // 拿到第一次点击选项卡，渲染页面时拿到的id\n},\nwatch: {\n  '$route': 'routerAlter' // watch中不用写this，而且变量名都要用''包起来\n},\nmethods: {\n  routerAlter () {\n    console.log(this.$route.params.id)\n  }\n}\n```\n\n## 监听$route，解决当前页面记录上次页面浏览位置问题\n一般给App.vue中添加一个监听\n```javascript\nwatch: {\n  '$route': function () {\n    window.scrollTo(0, 0) // 此方法并不是在操纵html元素或者是body元素，而是包含html和body元素的整个文档，即使html或者body高度是0，只要整个文档有高度，此方法使用之后依然是有效果的。\n  }\n}\n```\n+ html和body设置height: 100%问题\n  当html和body设置了height: 100%之后，高度就是浏览器可是区域的高度，高度再也不会随着内容的高度而撑开。反之，body和html不设置高度，则他们的高度会随着内容而撑大。\n+ position: fixed\n  设置position: fixed的元素，位置是相对浏览器可视区域而定的。而且他们也不包含的整个文档之中。\n","slug":"vue_solution1","published":1,"updated":"2020-01-20T07:45:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75giz004blktv8zt71mlm"},{"title":"vuex中遇到的问题1","date":"2019-05-30T06:00:00.000Z","_content":"# 首先注意：\n  vuex解决的是一个pages中组件间的数据存储数据存储问题和共同使用问题，而不是跨page，并不是最初理解的对于整个vue项目全局的数据存储空间\n  <!-- more -->\n+ vuex\n  ① Vue Components 是我们的 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions；\n  ② 我们在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，我们不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中；\n  ③ 然后 Mutations 就去改变（Mutate）State 中的数据；\n  ④ 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。","source":"_posts/vuex中遇到的问题1.md","raw":"---\ntitle: vuex中遇到的问题1\ncategories:\n  - 总结\n  - vue\n  - vuex\ntags:\n  - 总结\n  - vue\n  - vuex\ndate: 2019-05-30 14:00:00\n---\n# 首先注意：\n  vuex解决的是一个pages中组件间的数据存储数据存储问题和共同使用问题，而不是跨page，并不是最初理解的对于整个vue项目全局的数据存储空间\n  <!-- more -->\n+ vuex\n  ① Vue Components 是我们的 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions；\n  ② 我们在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，我们不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中；\n  ③ 然后 Mutations 就去改变（Mutate）State 中的数据；\n  ④ 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。","slug":"vuex中遇到的问题1","published":1,"updated":"2020-01-20T07:45:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75giz004elktvhlxzxtvn"},{"title":"两个action依次执行，第一个赋值，第二个立即取值","date":"2019-05-30T06:00:00.000Z","_content":"\n# 在mounted中的两个actions依次执行，第一个给state中的属性赋值，另外一个获取刚刚赋值的属性。commmit()是异步的，所以赋值操作其实是发生在第二个action获取属性之后。\n<!-- more -->\n```javascript\n// vue 组件中： \nmounted() {\n  this.$store.dispatch('setTest', 'test已经被赋值')\n  this.$store.dispatch('getTest')\n}\n```\n```javascript\n// state.js中\nexport default {\n  test: null // test初值为null\n}\n```\n```javascript\n// actions.js中\nexport default {\n  setTest ({commit}, val) {\n    commit('setTest', {val}) // 1\n  },\n  getTest ({commit, state}) {\n    console.log('test:', state.test) // 2\n  }\n}\n```\n```javascript\n// mutations.js中\nexport default {\n  setTest (state, {val}) {\n    state.test = val // 3\n  }\n}\n```\n控制台打印：`test: null`\n\n执行顺序其实是： 1  2  3 ， 也就是说赋值操作在取值操作之后。\n\n\n# 利用setTimeout验证commit是异步执行的\n```javascript\n// vue组件中\nmounted() {\n  this.$store.dispatch('setTest', 'test的赋值操作')\n  setTimeout(() => {\n    this.$store.dispatch('getTest')\n  }, 2000) // 延迟两秒，在执行\n}\n```\n控制台打印：`test: test已经被赋值`\n\n此时的执行顺序为：1  3  2 ， 利用setTimeout使得`this.$store.dispatch('getTest')`异步且在 步骤2赋值操作 之后执行。\n\n# 使用监听，让取值操作在所取值在变化之后进行\n```javascript\n// vue组件中\nmounted() {\n  this.$store.diapatch('setTest', 'test已经被赋值')\n},\nwatch: {\n  '$store.state.test' () {\n    this.$store.dispatch('getTest')\n  }\n}\n```\n控制台打印：`test: test已经被赋值\n\n当然，此时的执行顺序为：1  3  2","source":"_posts/vuex使用-两个action依次执行.md","raw":"---\ntitle: 两个action依次执行，第一个赋值，第二个立即取值\ncategories:\n  - vue\n  - vuex\ntags:\n  - vue\n  - vuex\ndate: 2019-05-30 14:00:00\n---\n\n# 在mounted中的两个actions依次执行，第一个给state中的属性赋值，另外一个获取刚刚赋值的属性。commmit()是异步的，所以赋值操作其实是发生在第二个action获取属性之后。\n<!-- more -->\n```javascript\n// vue 组件中： \nmounted() {\n  this.$store.dispatch('setTest', 'test已经被赋值')\n  this.$store.dispatch('getTest')\n}\n```\n```javascript\n// state.js中\nexport default {\n  test: null // test初值为null\n}\n```\n```javascript\n// actions.js中\nexport default {\n  setTest ({commit}, val) {\n    commit('setTest', {val}) // 1\n  },\n  getTest ({commit, state}) {\n    console.log('test:', state.test) // 2\n  }\n}\n```\n```javascript\n// mutations.js中\nexport default {\n  setTest (state, {val}) {\n    state.test = val // 3\n  }\n}\n```\n控制台打印：`test: null`\n\n执行顺序其实是： 1  2  3 ， 也就是说赋值操作在取值操作之后。\n\n\n# 利用setTimeout验证commit是异步执行的\n```javascript\n// vue组件中\nmounted() {\n  this.$store.dispatch('setTest', 'test的赋值操作')\n  setTimeout(() => {\n    this.$store.dispatch('getTest')\n  }, 2000) // 延迟两秒，在执行\n}\n```\n控制台打印：`test: test已经被赋值`\n\n此时的执行顺序为：1  3  2 ， 利用setTimeout使得`this.$store.dispatch('getTest')`异步且在 步骤2赋值操作 之后执行。\n\n# 使用监听，让取值操作在所取值在变化之后进行\n```javascript\n// vue组件中\nmounted() {\n  this.$store.diapatch('setTest', 'test已经被赋值')\n},\nwatch: {\n  '$store.state.test' () {\n    this.$store.dispatch('getTest')\n  }\n}\n```\n控制台打印：`test: test已经被赋值\n\n当然，此时的执行顺序为：1  3  2","slug":"vuex使用-两个action依次执行","published":1,"updated":"2020-01-20T07:45:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gj1004jlktvrngpmvum"},{"title":"vuex使用","date":"2019-05-17T03:00:00.000Z","_content":"\n## ","source":"_posts/vuex使用.md","raw":"---\ntitle: vuex使用\ncategories: \n  - vue\n  - vuex\ntags: \n  - vue\n  - vuex \ndate: 2019-05-17 11:00:00\n---\n\n## ","slug":"vuex使用","published":1,"updated":"2020-01-20T07:45:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gj2004mlktvoizllwkd"},{"title":"vuex在登录、获取用户信息状态的应用","date":"2019-05-30T06:30:00.000Z","_content":"## 问题分析：\n之前的想法是后台只做一个登录接口，然后登录之后，获取用户的信息，并且保存在vuex中，供整个vue项目中的pages页面使用。但实践证明，我并没有真正了解vuex的基本使用和适用场景。\n<!-- more -->\n所以，首先要说的是，vuex的解决的是同一个页面中组件间的数据存储和公用问题，vuex并不是最初理解的对于整个vue项目全局的数据存储空间\n\n显然，如果只有一个获取用户信息的方法并且封装在登录接口中执行是考虑不周全的，比如：在订单页面，个人中心我都需要用户信息，难道我还要调用登录接口来取数据吗？还需要再输入密码吗？还是需要将密码保存在某个地方，调用登录接口，自动去登录？这样做是不是会造成密码泄露？\n\n## 解决方案：\n+  将登录操作和获取用户信息状态分开执行：\n1. 登录操作只获取token，并把token保存在session中\n2. 获取个人用户信息的接口再根据session中的token去获取个人用户信息\n\n需要注意的是：这里有一个细节，在用户正确输入密码，点击登录按钮并且拿到token之后，我们要监听token是否拿到，如果拿到，将页面跳转到我的订单或者个人中心等非登录页面。\n\n\n后台接口代码：router/users.js\n```javascript\nconst jwt = require('jsonwebtoken') \nconst md5 = require('blueimp-md5')\nconst { User } = require('../models/users')\nconst SECRET = 'masia'\nconst MD5SECRET = 'masia66666'\n\nrouter\n  .post('/login', async (req, res) => {\n    req.body.password = md5(md5(req.body.password + MD5SECRET))\n    const user = await User.findOne().where({\n      email: req.body.email\n    })\n    if (!user) { // 如果对象为空\n      return res.send({ \n        code: 1,\n        msg: '输入的用户名不存在'\n      })\n    } else { // 如果对象存在\n      if (user.password != req.body.password) { \n        return res.send({\n          code: 2,\n          msg: '输入的密码错误'\n        })\n      } else {\n        const token = jwt.sign({\n          id: String(user._id) \n        }, SECRET)\n        res.send({\n          code: 0, // code为0时，登录成功\n          msg: '登录成功',\n          token\n        })\n      }\n    }\n```\n```javascript\n// state.js\nexport default {\n  currentUser: null, // 未登录状态，当前用户为null,\n  token: null, // 从后台返回到的token，一方面保存在vuex中，用来判断是否登录成功，另一方面，保存在session中，供其他页面获取用户信息使用\n  loginStatus: {\n    code: -1, // 默认状态为 -1 ，状态为未登录\n    msg: '未登录'\n  }\n}\n```\n```javascript\n// actions.js\nimport axios from 'axios'\n\nimport {\n  reqLogin\n} from '../api'\n\nimport {\n  RECEIVE_PROFILE,\n  RECEIVE_LOGIN,\n  RECEIVE_LOGINSTATUS \n} from './mutation-types'\n\nexport default {\n  async getLogin ({commit, state}, formData) { // 登录,formData中包含了用户名，密码等属性\n    const res = await reqLogin(formData) // 已经封装好的登录方法，已经过滤掉了headers等信息，返回的是data对象\n    if (res.code) { // 当 res.code 不为0时，均为登录失败\n      return commit(RECEIVE_LOGINSTATUS, {res}) // 根据返回结果，更新登录状态\n    }\n    // code 为0，执行下面的代码\n    let token = res.token // 拿到token\n    sessionStorage.setItem('token', token) // 把token写入session中\n    commit(RECEIVE_LOGIN, {res})\n  },\n   async getProfile ({commit}) { // 获取用户个人信息\n    const token = sessionStorage.getItem('token') //获取session中的token\n    if (token) {  // 如果token存在，发送获取个人用户信息请求\n      const user = await axios({\n        method: 'POST',\n        url: '/users/profile',\n        headers: {\n          'Authorization': 'Bearer ' + token\n        }\n      })\n      const currentUser = user.data\n      commit(RECEIVE_PROFILE, {currentUser})\n    }\n    return;\n  }\n}\n```\n```javascript\n// mutation-types.js\nexport const RECEIVE_LOGINSTATUS = 'receive_loginStatus' // 改变state.loginStatus\nexport const RECEIVE_LOGIN = 'receive_login' // 改变state.token\nexport const RECEIVE_PROFILE = 'receive_profile' // 接收个人信息\n```\n```javascript\n// mutations.js\nimport {\n  RECEIVE_LOGINSTATUS, \n  RECEIVE_LOGIN\n} from './mutation-types'\n\nexport default {\n  [RECEIVE_LOGINSTATUS] (state, {res}) {\n    state.loginStatus.code = res.code\n    state.loginStatus.msg = res.msg\n  },\n  [RECEIVE_LOGIN] (state, {res}) {\n    state.token = res.token\n  }，\n  [RECEIVE_PROFILE] (state, {currentUser}) {\n    state.currentUser = currentUser \n  },\n}\n```\n\n在login.vue页面中：\n```javascript\nwatch: {\n  '$store.state.token' (newVal, oldVal) { // 必须监视到登录成功，且把token存入到session中之后，方可跳转页面\n    console.log('masia')\n    this.$router.push('/profile')\n  }\n},\nmethods: {\n  login () {\n    this.$store.dispatch('getLogin')\n  }\n}\n```\n\n在profile.vue页面中：\n```javascript\nmounted () {\n  this.$store.dispatch('getProfile')\n}\n```","source":"_posts/vuex在登录中的应用.md","raw":"---\ntitle: vuex在登录、获取用户信息状态的应用\ncategories:\n  - vue\n  - vuex\ntags:\n  - vue\n  - vuex\ndate: 2019-05-30 14:30:00\n---\n## 问题分析：\n之前的想法是后台只做一个登录接口，然后登录之后，获取用户的信息，并且保存在vuex中，供整个vue项目中的pages页面使用。但实践证明，我并没有真正了解vuex的基本使用和适用场景。\n<!-- more -->\n所以，首先要说的是，vuex的解决的是同一个页面中组件间的数据存储和公用问题，vuex并不是最初理解的对于整个vue项目全局的数据存储空间\n\n显然，如果只有一个获取用户信息的方法并且封装在登录接口中执行是考虑不周全的，比如：在订单页面，个人中心我都需要用户信息，难道我还要调用登录接口来取数据吗？还需要再输入密码吗？还是需要将密码保存在某个地方，调用登录接口，自动去登录？这样做是不是会造成密码泄露？\n\n## 解决方案：\n+  将登录操作和获取用户信息状态分开执行：\n1. 登录操作只获取token，并把token保存在session中\n2. 获取个人用户信息的接口再根据session中的token去获取个人用户信息\n\n需要注意的是：这里有一个细节，在用户正确输入密码，点击登录按钮并且拿到token之后，我们要监听token是否拿到，如果拿到，将页面跳转到我的订单或者个人中心等非登录页面。\n\n\n后台接口代码：router/users.js\n```javascript\nconst jwt = require('jsonwebtoken') \nconst md5 = require('blueimp-md5')\nconst { User } = require('../models/users')\nconst SECRET = 'masia'\nconst MD5SECRET = 'masia66666'\n\nrouter\n  .post('/login', async (req, res) => {\n    req.body.password = md5(md5(req.body.password + MD5SECRET))\n    const user = await User.findOne().where({\n      email: req.body.email\n    })\n    if (!user) { // 如果对象为空\n      return res.send({ \n        code: 1,\n        msg: '输入的用户名不存在'\n      })\n    } else { // 如果对象存在\n      if (user.password != req.body.password) { \n        return res.send({\n          code: 2,\n          msg: '输入的密码错误'\n        })\n      } else {\n        const token = jwt.sign({\n          id: String(user._id) \n        }, SECRET)\n        res.send({\n          code: 0, // code为0时，登录成功\n          msg: '登录成功',\n          token\n        })\n      }\n    }\n```\n```javascript\n// state.js\nexport default {\n  currentUser: null, // 未登录状态，当前用户为null,\n  token: null, // 从后台返回到的token，一方面保存在vuex中，用来判断是否登录成功，另一方面，保存在session中，供其他页面获取用户信息使用\n  loginStatus: {\n    code: -1, // 默认状态为 -1 ，状态为未登录\n    msg: '未登录'\n  }\n}\n```\n```javascript\n// actions.js\nimport axios from 'axios'\n\nimport {\n  reqLogin\n} from '../api'\n\nimport {\n  RECEIVE_PROFILE,\n  RECEIVE_LOGIN,\n  RECEIVE_LOGINSTATUS \n} from './mutation-types'\n\nexport default {\n  async getLogin ({commit, state}, formData) { // 登录,formData中包含了用户名，密码等属性\n    const res = await reqLogin(formData) // 已经封装好的登录方法，已经过滤掉了headers等信息，返回的是data对象\n    if (res.code) { // 当 res.code 不为0时，均为登录失败\n      return commit(RECEIVE_LOGINSTATUS, {res}) // 根据返回结果，更新登录状态\n    }\n    // code 为0，执行下面的代码\n    let token = res.token // 拿到token\n    sessionStorage.setItem('token', token) // 把token写入session中\n    commit(RECEIVE_LOGIN, {res})\n  },\n   async getProfile ({commit}) { // 获取用户个人信息\n    const token = sessionStorage.getItem('token') //获取session中的token\n    if (token) {  // 如果token存在，发送获取个人用户信息请求\n      const user = await axios({\n        method: 'POST',\n        url: '/users/profile',\n        headers: {\n          'Authorization': 'Bearer ' + token\n        }\n      })\n      const currentUser = user.data\n      commit(RECEIVE_PROFILE, {currentUser})\n    }\n    return;\n  }\n}\n```\n```javascript\n// mutation-types.js\nexport const RECEIVE_LOGINSTATUS = 'receive_loginStatus' // 改变state.loginStatus\nexport const RECEIVE_LOGIN = 'receive_login' // 改变state.token\nexport const RECEIVE_PROFILE = 'receive_profile' // 接收个人信息\n```\n```javascript\n// mutations.js\nimport {\n  RECEIVE_LOGINSTATUS, \n  RECEIVE_LOGIN\n} from './mutation-types'\n\nexport default {\n  [RECEIVE_LOGINSTATUS] (state, {res}) {\n    state.loginStatus.code = res.code\n    state.loginStatus.msg = res.msg\n  },\n  [RECEIVE_LOGIN] (state, {res}) {\n    state.token = res.token\n  }，\n  [RECEIVE_PROFILE] (state, {currentUser}) {\n    state.currentUser = currentUser \n  },\n}\n```\n\n在login.vue页面中：\n```javascript\nwatch: {\n  '$store.state.token' (newVal, oldVal) { // 必须监视到登录成功，且把token存入到session中之后，方可跳转页面\n    console.log('masia')\n    this.$router.push('/profile')\n  }\n},\nmethods: {\n  login () {\n    this.$store.dispatch('getLogin')\n  }\n}\n```\n\n在profile.vue页面中：\n```javascript\nmounted () {\n  this.$store.dispatch('getProfile')\n}\n```","slug":"vuex在登录中的应用","published":1,"updated":"2020-01-20T07:45:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gj3004qlktvhqpjd97j"},{"title":"vue中axios的封装","date":"2019-05-17T01:00:00.000Z","_content":"\n## 在vue中我们可以把调用接口的代码封装起来，一方面减少重复代码的编写，另一方面我们可以使本身的vue页面变得简洁易读。\n<!-- more -->\n+ 引入，原本的axios使用方式是: \n1. 首先在main.js文件中修改Vue原型链\n\n```javascript\nimport axios from 'axios'\nVue.prototype.$http = axios\n```\n2. 在其他.vue文件中使用\n\n```javascript\n// post方式\nthis.$http({\n  method: 'post', // 请求方式\n  url: '/users/register', // 请求地址\n  data: form.data // 传入参数\n})\n.then(res => {\n  console.log(res) // 成功返回的数据\n})\n.catch(err => {\n  console.log(err) // 失败返回的数据\n})\n// get方式\nthis.$http({\n  method: 'get',\n  url: 'products?id=1&name=maisa'\n})\n.then(res => {\n  console.log(res)\n})\n.catch(err => {\n  console.log(err)\n})\n```\n+ 封装axios使用方式\n在`src`文件夹中创建一个`api`文件夹，在这个文件下面有两个文件，一个是`ajax.js`，另外一个是`index.js`\n1. 在`ajax.js`中：\n```javascript\nimport axios from 'axios'\n\nexport default function ajax (url, data = {}, type = 'GET') {\n  return new Promise((resolve, reject) => {\n    let promise\n    if (type === 'GET') {\n      let dataStr = ''\n      Object.keys(data).forEach(key => {\n        dataStr += key + '=' + data[key] + '&'\n      })\n      if (dataStr !== '') {\n        dataStr = dataStr.substring(0, dataStr.lastIndexOf('&')) // 删除字符串中最后一个&\n        url = url + '?' + dataStr \n      }\n      promise = axios.get(url)\n    } else {\n      promise = axios.post(url, data)\n    }\n    promise.then(res => {\n      resolve(res.data) // 直接返回res中的data\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n```\n\n2. 在`index.js`中\n```javascript\nimport ajax from './ajax'\nconst BASE_URL = ''\n\n// 1.注册\nexport const reqRegister = (formData) => ajax('/users/register', formData)\n// 2.登录\nexport const reqLogin = (formData) => ajax('/users/login', formData)\n```\n\n3. 在`.vue`中使用\n\n```javascript\n<script>\nimport {reqRegister} from '@/api/index' // 按需导入\n\nexport default {\n  data () {\n    return {\n      form: {\n        email: '',\n        nickname: '',\n        birthday: '',\n        gender: '',\n        bio: ''\n      }\n    }\n  }\n  methods: {\n    submit () {\n      reqRegister(this.form)\n        .then(res => {\n          console.log(res)\n        })\n        .catch(err => {\n          console.log(err)\n        })\n    }\n  }\n};\n</script>\n```","source":"_posts/vue中axios封装.md","raw":"---\ntitle: vue中axios的封装\ncategories: \n  - vue\n  - axios\n  - ajax\ntags: \n  - vue \n  - axios\n  - ajax\ndate: 2019-05-17 09:00:00\n---\n\n## 在vue中我们可以把调用接口的代码封装起来，一方面减少重复代码的编写，另一方面我们可以使本身的vue页面变得简洁易读。\n<!-- more -->\n+ 引入，原本的axios使用方式是: \n1. 首先在main.js文件中修改Vue原型链\n\n```javascript\nimport axios from 'axios'\nVue.prototype.$http = axios\n```\n2. 在其他.vue文件中使用\n\n```javascript\n// post方式\nthis.$http({\n  method: 'post', // 请求方式\n  url: '/users/register', // 请求地址\n  data: form.data // 传入参数\n})\n.then(res => {\n  console.log(res) // 成功返回的数据\n})\n.catch(err => {\n  console.log(err) // 失败返回的数据\n})\n// get方式\nthis.$http({\n  method: 'get',\n  url: 'products?id=1&name=maisa'\n})\n.then(res => {\n  console.log(res)\n})\n.catch(err => {\n  console.log(err)\n})\n```\n+ 封装axios使用方式\n在`src`文件夹中创建一个`api`文件夹，在这个文件下面有两个文件，一个是`ajax.js`，另外一个是`index.js`\n1. 在`ajax.js`中：\n```javascript\nimport axios from 'axios'\n\nexport default function ajax (url, data = {}, type = 'GET') {\n  return new Promise((resolve, reject) => {\n    let promise\n    if (type === 'GET') {\n      let dataStr = ''\n      Object.keys(data).forEach(key => {\n        dataStr += key + '=' + data[key] + '&'\n      })\n      if (dataStr !== '') {\n        dataStr = dataStr.substring(0, dataStr.lastIndexOf('&')) // 删除字符串中最后一个&\n        url = url + '?' + dataStr \n      }\n      promise = axios.get(url)\n    } else {\n      promise = axios.post(url, data)\n    }\n    promise.then(res => {\n      resolve(res.data) // 直接返回res中的data\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n```\n\n2. 在`index.js`中\n```javascript\nimport ajax from './ajax'\nconst BASE_URL = ''\n\n// 1.注册\nexport const reqRegister = (formData) => ajax('/users/register', formData)\n// 2.登录\nexport const reqLogin = (formData) => ajax('/users/login', formData)\n```\n\n3. 在`.vue`中使用\n\n```javascript\n<script>\nimport {reqRegister} from '@/api/index' // 按需导入\n\nexport default {\n  data () {\n    return {\n      form: {\n        email: '',\n        nickname: '',\n        birthday: '',\n        gender: '',\n        bio: ''\n      }\n    }\n  }\n  methods: {\n    submit () {\n      reqRegister(this.form)\n        .then(res => {\n          console.log(res)\n        })\n        .catch(err => {\n          console.log(err)\n        })\n    }\n  }\n};\n</script>\n```","slug":"vue中axios封装","published":1,"updated":"2020-01-20T07:45:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gj4004tlktvbsv0axlw"},{"title":"vue引入多个局部使用ui库","_content":"\n### 假如同时局部引入element-ui和mint-ui\n```javascript\n// 在.babelrc文件中配置\n\n```","source":"_posts/vue引入多个局部使用的ui库.md","raw":"---\ntitle: vue引入多个局部使用ui库\ntags:\n  - vue\ncategories:\n  - vue\n---\n\n### 假如同时局部引入element-ui和mint-ui\n```javascript\n// 在.babelrc文件中配置\n\n```","slug":"vue引入多个局部使用的ui库","published":1,"date":"2020-01-20T07:45:15.000Z","updated":"2020-01-20T07:45:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gj5004wlktv06t75ruj"},{"title":"vue强制刷新dom","date":"2019-06-01T01:00:00.000Z","_content":"\n## 有这样一个业务需求，实现一个轮播效果，如果后台数据项小于4个，那么就让这几个数据项一组显示出来，并且水平flex排列。如果后台数据项大于等于4个，那么让数据4个为一组显示，并且让这组数据项实现轮播效果，点击一次导航键，只滑动一个数据项。\n<!-- more -->\n分析：\n1. 涉及到轮播图插件的使用，vue-awesome-swiper\n2. 轮播图组规划问题，几个为一组，组内项的间隔是多少，点击一次导航滑动一组，还是滑动一个组内项\n3. 有两个选项卡，点击任意一个选项卡，只会引起params参数的变化，从而发起请求，而不是因为跳转路由而发起的数据请求，所以页面只在第一次加载的时候执行一次mounted()。\n4. 根据后台数据，动态规划vue-awesome-swiper的配置（注意：这里不是动态给swiper嵌套数据，而是动态配置swiper的参数）\n\n## 解决思路：\n首先想到的是，点击选项卡，实现的不是路由的跳转，而实现的是`/solution/3`与`/solution/4`这样的路由变化，但是仅有这样的路由变化不会再次引起页面的mounted()。\n然后想到为后台接收到的数据设置监听，然后根据后台数据的数组长度，从而修改 swiper 配置参数。\n还需要在修改swiper配置参数之后，重新渲染页面或者swiper代码段，不然修改的swiper参数不会生效。\n\n## 之前的失败尝试：\n```javascript\n// vue 组件\n<template>\n    <!--轮播图-->\n    <div class=\"swiper-con\">\n      <swiper :options=\"swiperOption1\" id=\"swiper1\"> // swiperOption1为配置参数\n        <swiper-slide v-for=\"item of msg\" :key=\"item.index\">\n          <img src=\"@/assets/computer_icon.png\" alt=\"\">\n          <h1>{{item.title}}</h1>\n          <p class=\"ellipsis\">{{item.con}}</p>\n        </swiper-slide>\n      </swiper> \n      <div class=\"swiper-button-next swiper-button-next1\"></div>\n      <div class=\"swiper-button-prev swiper-button-prev1\"></div>\n      <div class=\"swiper-pagination\"></div>\n    </div>\n\n</template>\n\n<script>\nimport axios from 'axios'\nimport \"swiper/dist/css/swiper.min.css\";\nimport { swiper, swiperSlide } from \"vue-awesome-swiper\";\n\nexport default {\n\n  name: 'swiper_bussiness',\n  data () {\n    return {\n      msg: [{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }, {\n        title: '医院：急需培养人才',\n        con: '医疗从业人员短缺，优质专家资源短缺，医院间、医院与医学院校间临床教学和研讨开展困难。'\n      },{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }]\n    }\n  },\n  computed: {\n    swiperOption1 () {\n      if (this.msg.length<4) { // 监听接收后台数据的数组长度的变化，从而动态修改swiper参数，事实上，swiperOption1 会因为this.msg的变化而执行这个计算属性，但不会根据新的 swiperOption1 作为参数去自动渲染dom，解决此问题必须让其在新生成的 swiperOption1 之后去强制渲染dom\n        return {\n          slidesPerView: this.msg.length, // 数组长度小于四个时，一组全部显示\n          spaceBetween: 70, // 数组项间隔\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } else {\n        return {\n          slidesPerView: 4,\n          spaceBetween: 32,\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } \n    }\n  },\n  components: {\n    swiper,\n    swiperSlide\n  },\n  mounted () { // 页面第一次加载进来，会执行数组赋值操作，并且swiperOption1会根据this.msg.length计算之后去配置swiper\n    axios.get('/api/detail/'+ this.$route.params.id).then(res => {\n      this.msg = res.data \n    })\n  },\n  methods: {\n    \n  },\n  watch: {\n    '$route.params.id' () { // 监听params参数的变化，如有变化，则重新发起请求，并且为this.msg赋值\n      axios.get('/api/detail/'+this.$route.params.id).then(res => {\n        console.log(res.data)\n        this.msg = res.data[0].val\n      })\n    }\n  }\n}\n</script>\n```\n\n<!-- 最终解决 -->\n\n## 利用v-if去重新强制渲染dom\n\n```javascript\n// vue 组件\n<template>\n    <!--轮播图-->\n    <div class=\"swiper-con\">\n      <swiper :options=\"swiperOption1\" id=\"swiper1\" v-if=\"showSwiper\">\n        <swiper-slide v-for=\"item of msg\" :key=\"item.index\">\n          <img src=\"@/assets/computer_icon.png\" alt=\"\">\n          <h1>{{item.title}}</h1>\n          <p class=\"ellipsis\">{{item.con}}</p>\n        </swiper-slide>\n      </swiper> \n      <div class=\"swiper-button-next swiper-button-next1\"></div>\n      <div class=\"swiper-button-prev swiper-button-prev1\"></div>\n      <div class=\"swiper-pagination\"></div>\n    </div>\n\n</template>\n\n<script>\nimport axios from 'axios'\nimport \"swiper/dist/css/swiper.min.css\";\nimport { swiper, swiperSlide } from \"vue-awesome-swiper\";\n\nexport default {\n\n  name: 'swiper_bussiness',\n  data () {\n    return {\n      msg: [{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }, {\n        title: '医院：急需培养人才',\n        con: '医疗从业人员短缺，优质专家资源短缺，医院间、医院与医学院校间临床教学和研讨开展困难。'\n      },{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }],\n      showSwiper: true // 显示 swiper\n    }\n  },\n  computed: {\n    swiperOption1 () {\n      if (this.msg.length<4) { // 监听接收后台数据的数组长度的变化，从而动态修改swiper参数，事实上，swiperOption1 会因为this.msg的变化而执行这个计算属性，但不会根据新的 swiperOption1 作为参数去自动渲染dom，解决此问题必须让其在新生成的 swiperOption1 之后去强制渲染dom\n        return {\n          slidesPerView: this.msg.length,\n          spaceBetween: 70,\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } else {\n        return {\n          slidesPerView: 4,\n          spaceBetween: 32,\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } \n    }\n  },\n  components: {\n    swiper,\n    swiperSlide\n  },\n  mounted () { // 页面第一次加载进来，会执行数组赋值操作，并且swiperOption1会根据this.msg.length计算之后去配置swiper\n    axios.get('/api/detail/'+ this.$route.params.id).then(res => {\n      this.msg = res.data\n    })\n  },\n  methods: {\n    \n  },\n  watch: {\n    '$route.params.id' () { // 监听params参数的变化，如有变化，则重新发起请求，并且为this.msg赋值\n      axios.get('/api/detail/'+this.$route.params.id).then(res => {\n        this.msg = res.data // 为this.msg赋值\n      })\n    },\n    msg () { // 监视数据变化之后，在强制刷新\n      this.showSwiper = false // 让 swiper 的display 变为none \n      this.$nextTick(() => { // 等到所有数据处理完成，当然也包括 swiperOption1 根据数组长度重新计算完成\n        this.showSwiper = true // 让 swiper 的diaplay 变为block，即手动完成重新渲染\n      })\n    }\n  }\n}\n</script>\n```","source":"_posts/vue强制刷新dom.md","raw":"---\ntitle: vue强制刷新dom\ncategories: \n  - vue\n  - vue-awesome-swiper\ntags: \n  - vue\n  - vue-awesome-swiper\ndate: 2019-06-01 09:00:00\n---\n\n## 有这样一个业务需求，实现一个轮播效果，如果后台数据项小于4个，那么就让这几个数据项一组显示出来，并且水平flex排列。如果后台数据项大于等于4个，那么让数据4个为一组显示，并且让这组数据项实现轮播效果，点击一次导航键，只滑动一个数据项。\n<!-- more -->\n分析：\n1. 涉及到轮播图插件的使用，vue-awesome-swiper\n2. 轮播图组规划问题，几个为一组，组内项的间隔是多少，点击一次导航滑动一组，还是滑动一个组内项\n3. 有两个选项卡，点击任意一个选项卡，只会引起params参数的变化，从而发起请求，而不是因为跳转路由而发起的数据请求，所以页面只在第一次加载的时候执行一次mounted()。\n4. 根据后台数据，动态规划vue-awesome-swiper的配置（注意：这里不是动态给swiper嵌套数据，而是动态配置swiper的参数）\n\n## 解决思路：\n首先想到的是，点击选项卡，实现的不是路由的跳转，而实现的是`/solution/3`与`/solution/4`这样的路由变化，但是仅有这样的路由变化不会再次引起页面的mounted()。\n然后想到为后台接收到的数据设置监听，然后根据后台数据的数组长度，从而修改 swiper 配置参数。\n还需要在修改swiper配置参数之后，重新渲染页面或者swiper代码段，不然修改的swiper参数不会生效。\n\n## 之前的失败尝试：\n```javascript\n// vue 组件\n<template>\n    <!--轮播图-->\n    <div class=\"swiper-con\">\n      <swiper :options=\"swiperOption1\" id=\"swiper1\"> // swiperOption1为配置参数\n        <swiper-slide v-for=\"item of msg\" :key=\"item.index\">\n          <img src=\"@/assets/computer_icon.png\" alt=\"\">\n          <h1>{{item.title}}</h1>\n          <p class=\"ellipsis\">{{item.con}}</p>\n        </swiper-slide>\n      </swiper> \n      <div class=\"swiper-button-next swiper-button-next1\"></div>\n      <div class=\"swiper-button-prev swiper-button-prev1\"></div>\n      <div class=\"swiper-pagination\"></div>\n    </div>\n\n</template>\n\n<script>\nimport axios from 'axios'\nimport \"swiper/dist/css/swiper.min.css\";\nimport { swiper, swiperSlide } from \"vue-awesome-swiper\";\n\nexport default {\n\n  name: 'swiper_bussiness',\n  data () {\n    return {\n      msg: [{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }, {\n        title: '医院：急需培养人才',\n        con: '医疗从业人员短缺，优质专家资源短缺，医院间、医院与医学院校间临床教学和研讨开展困难。'\n      },{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }]\n    }\n  },\n  computed: {\n    swiperOption1 () {\n      if (this.msg.length<4) { // 监听接收后台数据的数组长度的变化，从而动态修改swiper参数，事实上，swiperOption1 会因为this.msg的变化而执行这个计算属性，但不会根据新的 swiperOption1 作为参数去自动渲染dom，解决此问题必须让其在新生成的 swiperOption1 之后去强制渲染dom\n        return {\n          slidesPerView: this.msg.length, // 数组长度小于四个时，一组全部显示\n          spaceBetween: 70, // 数组项间隔\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } else {\n        return {\n          slidesPerView: 4,\n          spaceBetween: 32,\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } \n    }\n  },\n  components: {\n    swiper,\n    swiperSlide\n  },\n  mounted () { // 页面第一次加载进来，会执行数组赋值操作，并且swiperOption1会根据this.msg.length计算之后去配置swiper\n    axios.get('/api/detail/'+ this.$route.params.id).then(res => {\n      this.msg = res.data \n    })\n  },\n  methods: {\n    \n  },\n  watch: {\n    '$route.params.id' () { // 监听params参数的变化，如有变化，则重新发起请求，并且为this.msg赋值\n      axios.get('/api/detail/'+this.$route.params.id).then(res => {\n        console.log(res.data)\n        this.msg = res.data[0].val\n      })\n    }\n  }\n}\n</script>\n```\n\n<!-- 最终解决 -->\n\n## 利用v-if去重新强制渲染dom\n\n```javascript\n// vue 组件\n<template>\n    <!--轮播图-->\n    <div class=\"swiper-con\">\n      <swiper :options=\"swiperOption1\" id=\"swiper1\" v-if=\"showSwiper\">\n        <swiper-slide v-for=\"item of msg\" :key=\"item.index\">\n          <img src=\"@/assets/computer_icon.png\" alt=\"\">\n          <h1>{{item.title}}</h1>\n          <p class=\"ellipsis\">{{item.con}}</p>\n        </swiper-slide>\n      </swiper> \n      <div class=\"swiper-button-next swiper-button-next1\"></div>\n      <div class=\"swiper-button-prev swiper-button-prev1\"></div>\n      <div class=\"swiper-pagination\"></div>\n    </div>\n\n</template>\n\n<script>\nimport axios from 'axios'\nimport \"swiper/dist/css/swiper.min.css\";\nimport { swiper, swiperSlide } from \"vue-awesome-swiper\";\n\nexport default {\n\n  name: 'swiper_bussiness',\n  data () {\n    return {\n      msg: [{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }, {\n        title: '医院：急需培养人才',\n        con: '医疗从业人员短缺，优质专家资源短缺，医院间、医院与医学院校间临床教学和研讨开展困难。'\n      },{\n        title: '政府：资源分布不均',\n        con: '资源分布不均，专家不能充分利用。中国30%大城市集中了80%的优质医疗资源，同时，跨科室跨机构协同业务开展困难，突发情况下，医疗救援效率低。'\n      }],\n      showSwiper: true // 显示 swiper\n    }\n  },\n  computed: {\n    swiperOption1 () {\n      if (this.msg.length<4) { // 监听接收后台数据的数组长度的变化，从而动态修改swiper参数，事实上，swiperOption1 会因为this.msg的变化而执行这个计算属性，但不会根据新的 swiperOption1 作为参数去自动渲染dom，解决此问题必须让其在新生成的 swiperOption1 之后去强制渲染dom\n        return {\n          slidesPerView: this.msg.length,\n          spaceBetween: 70,\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } else {\n        return {\n          slidesPerView: 4,\n          spaceBetween: 32,\n          freeMode: true,\n          navigation: {\n            nextEl: '.swiper-button-next1',\n            prevEl: '.swiper-button-prev1'\n          }\n        } \n      } \n    }\n  },\n  components: {\n    swiper,\n    swiperSlide\n  },\n  mounted () { // 页面第一次加载进来，会执行数组赋值操作，并且swiperOption1会根据this.msg.length计算之后去配置swiper\n    axios.get('/api/detail/'+ this.$route.params.id).then(res => {\n      this.msg = res.data\n    })\n  },\n  methods: {\n    \n  },\n  watch: {\n    '$route.params.id' () { // 监听params参数的变化，如有变化，则重新发起请求，并且为this.msg赋值\n      axios.get('/api/detail/'+this.$route.params.id).then(res => {\n        this.msg = res.data // 为this.msg赋值\n      })\n    },\n    msg () { // 监视数据变化之后，在强制刷新\n      this.showSwiper = false // 让 swiper 的display 变为none \n      this.$nextTick(() => { // 等到所有数据处理完成，当然也包括 swiperOption1 根据数组长度重新计算完成\n        this.showSwiper = true // 让 swiper 的diaplay 变为block，即手动完成重新渲染\n      })\n    }\n  }\n}\n</script>\n```","slug":"vue强制刷新dom","published":1,"updated":"2020-01-20T07:45:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gj7004zlktvkwg79tac"},{"title":"vue技术栈梳理-状态管理篇","date":"2019-06-11T16:00:00.000Z","_content":"#### 首先复习父子组件间的通信\n<!-- more -->\n编写组件实现 input的 v-model 功能\n+ myInput 组件\n```javascript\n<template>\n  <div>\n    <input :type=\"type\" @input=\"handleInput\" :value=\"value\"/>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n\n      }\n  },\n  props: {\n    type: {\n      type: String,\n      default: 'text'\n    },\n    value: {\n      type: [String, Number],\n      default: ''\n    }\n  },\n  components: {\n    \n  },\n  methods: {\n    handleInput (event) {\n      const value = event.target.value\n      this.$emit('input', value)\n    }\n  }\n}\n</script>\n```\n在页面中使用myInput组件\n```javascript\n<template>\n  <div>\n    <p>input component</p>\n    <div>\n      <myInput @input=\"getInputVal\" :value=\"inputValue\"/>\n      // 这个组件就相当于 <input v-model=\"inputValue\"/>\n      // 因为自定义的事件名比较特殊，为input，\n      // 组件接收的参数名也比较特殊，为value，\n      // 所以可以直接改写为 <myInput v-model=\"inputValue\"/>\n      // 当然下面也就省去了写getInput函数了\n      <div>{{inputValue}}</div>\n    </div>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">4\nimport myInput from '_c/myInput' // 导入 自己编写的 输入组件\nexport default {\n  data () {\n    return {\n      inputValue: 'this is input value'\n    }\n  },\n  components: {\n    myInput\n  },\n  methods: {\n    getInputVal (inputValue) {\n      this.inputValue = inputValue\n    }\n  }\n}\n</script>\n```\n\n要注意的是： \n父子组件传值是单向数据流，不能在子组件中直接去修改父组件中的值，而必须通过emit向父组件提交一个自定义事件，然后把要修改的值，传在这个自定义事件函数的参数  中，让父组件自己去修改。\n\n#### 兄弟组件通信\n+ 当然也可以这样做，child1 组件使用自定义事件向父组件提交一个参数，然后在父组件中使用事件接收函数用这个参数去修改绑定给child2组件的参数值\n这种情况适用于，两个兄弟组件依赖同一个父组件\n+ 那么两个同时存在的路由组件如何通行呢？\n比如：\n```javascript\n<div>\n  <router-view name=\"default\"/> // 组件A\n  <router-view name=\"tel\"/> // 组件B\n</div>\n```\n当然，如果这两个router-view写在App.vue中，也可以借助App.vue 作为桥梁完成这两个兄弟组件间的传值（router-view组件的属性绑定和事件绑定和一般的自定义组件的操作方式相同）。因为router-view是一个用于替换内容的通用容器，如果给router-view上绑定很多属性和自定义事件函数，如：<router-view :value=\"value\" :tel=\"tel\" :desc=\"desc\" @toSilbing=\"toSibling\"/>，一方面会给我们的App.vue这个根组件中写入很多帮助兄弟组件间传值的中间属性和中间方法，污染全局的根组件，不符合高内聚低耦合的编程思想，另一方面在某个单独的组件中也需要定义大量的可能用到的属性和传值事件函数，代码量冗余，工作量也会加大。\n\n#### 使用bus完成兄弟组件间的传值\n文件`lib/bus/index.js`\n```javascript\nimport Vue from 'vue'\nconst Bus = new Vue()\nexport default Bus\n```\n在main.js中引入bus\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport bus from './lib/bux'\n\nVue.config.productionTip = false\nVue.prptotype.$bus = bus // 在vue的原型对象上添加$bus\n\nnew Vue({\n  router,\n  render: h => h(App)\n}).$mount('#app')\n\n```\n组件child1.vue\n```javascript\n<template>\n  <div>\n    <p>child1 component</p>\n    <p>使用bus传递来自child2的值 {{ fromSiblingValue }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n        fromSiblingValue: ''\n      }\n  },\n  components: {\n\n  },\n  mounted () { // 在mountd的时候，名为为bus的vue实例绑定事件，因为bus实例永远不会消失，所以使用$on为bus绑定事件，等待$emit去触发事件。\n    this.$bus.$on('use-bus', mes => {\n      this.fromSiblingValue = mes\n    })\n  }\n}\n</script>\n```\n组件child2.vue\n```javascript\n<template>\n  <div>\n    <p>child2 component</p>\n    <button @click=\"useBus\">使用bus</button>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n\n      }\n  },\n  methods: {\n    useBus () { // 使用$emit去触发 已经在bus中绑定的 'use-bus' 事件。\n      this.$bus.$emit('use-bus', 'this is came from sibling')\n    }\n  }\n}\n</script>\n```\n注意： 使用$emit和$on，触发和绑定事件，必须只能在同一个vue实例中完成。\n\n#### 使用vuex\n在main.js中\n```javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport App from './App'\nimport router from './router'\nimport Bus from './lib/bus'\n\nVue.config.profuctionTip = false\nVue.prototype.$bus = Bus\n\nnew Vue({\n  router,\n  store,\n  render: h => h(App)\n}).$mount('#app')\n```\n文件`/store/index.js`\n```javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport state from './state'\nimport getters from './getters'\nimport actions from './actions'\nimport mutations from './mutations'\nimport user from './modules/user'\n\nimport config from '@/config' // 引入配置对象\nVue.use(Vuex)\n\nexport default new Vuex.Store({ // 这里要注意使用的Vuex.Store\n  state,\n  getters,\n  mutations,\n  actions,\n  mudules: {\n    user\n  }\n})\n\n```\n需要注意的是：在如何操作在模块中定义的状态，比如user模块\n```javascript\nconst state = {\n  userName = 'masia'\n}\nconst getters = {\n\n}\nconst actions = {\n\n}\nconst mutations = {\n\n}\n\nexport default {\n  state,\n  getters,\n  mutations,\n  actions\n}\n```\n在组件中的使用方式\n```javascript\n<template>\n  <div>\n    <p>{{ userName }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n\n  },\n  computed: {\n    userName () {\n      return this.$store.state.user.userName\n                              // 这里得写模块名\n    }\n  }\n}\n</script>\n```\n使用mapState等工具函数来操作模块中的状态\n```javascript\n<template>\n  <div>\n    <p>{{ userName }}</p>\n    <p>{{ appName }}</P>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nimport { mapState } from 'vuex' \nexport default {\n  data () {\n\n  },\n  computed: {\n    ...mapState(['appName']) // ... 是es6中的展开操作符，也是剩余操作符\n    /* 这里用作展开操作，会展开一个对象，这里这样写，相当于\n     appName () {\n      return this.$store.state.appName\n    }\n    \n    // 当然也可以传入一个对象\n    ...map({\n     appName: state => state.appName \n     userName: state => state.user.userName \n    })\n    */\n    userName () {\n      return this.$store.state.user.userName\n                              // 这里得写模块名\n    }\n  }\n}\n</script>\n```\n+ 注意\n  1. 使用`...mapState(['appName', 'userName'])`这种方式，获取不到在user模块中state中的userName，在chrome dev tools中可以看到userName: undefined\n  2. 使用对象方式可以获取到 userName\n  ```javascript\n  ...mapState({\n    userName: state => state.user.userName,\n    appName: state => state.appName \n  })\n  ```\n  3. 在user模块中使用命名空间，在组件中使用createNamespacedHelpers重新为mapState绑定模块\n```javascript\n// user模块\nconst state = {\n  userName = 'masia'\n}\nconst getters = {\n\n}\nconst actions = {\n\n}\nconst mutations = {\n\n}\n\nexport default {\n  namespaced: true, // 设置命名空间\n  state,\n  getters,\n  mutations,\n  actions\n}\n```\n  在组件中使用：\n```javascript\n<template>\n  <div>\n    <p>login</p> \n    <p>{{ userName }}</p>\n    <p>{{ appName }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nimport { createNamespacedHelpers } from 'vuex' // 使用createNamespaceHelpers\nconst { mapState } = createNamespacedHelpers('user')\nexport default {\n  data () {\n      return {\n\n      }\n  },\n  mounted () {\n    console.log(createNamespacedHelpers)\n    /*\n      var createNamespacedHelpers = function (namespace) { return ({\n        mapState: mapState.bind(null, namespace),\n        mapGetters: mapGetters.bind(null, namespace),\n        mapMutations: mapMutations.bind(null, namespace),\n        mapActions: mapActions.bind(null, namespace)\n      }); };\n      */\n  },\n  components: {\n    \n  },\n  computed: {\n    ...mapState(['appName', 'userName']), // 这里的appName就为undefined了，因为user中没有appName\n    // ...mapState({\n    //   userName: state => state.userName, // 则这里直接在state中获取uesrName\n    // })\n  }\n}\n</script>\n```\n也可以在组件中使用：\n```javascript\n<template>\n  <div>\n    <p>login</p> \n    <p>{{ userName }}</p>\n    <p>{{ appName }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nimport { mapState } from 'vuex' \nexport default {\n  data () {\n      return {\n\n      }\n  },\n  computed: {\n    ...mapState('user', ['appName', 'userName']),\n    /**\n     *  或者\n     * ...mapState('user', {\n     *  userName: state => state.userName,\n     *  appName: state => state.appName\n     * }) \n     */\n  }\n}\n</script>\n```\n\n#### 使用getters\n首先明确getters的使用场景，在同一个路由组件中，如果只有一个局部组件依赖state中的某个属性来得到一个计算值，那么完全可以把这个计算属性写在他自己的组件中。但是，如果页面上多个局部组件都要使用计算值，那么应该直接把计算属性写在vuex中，在局部组件中拿来使用即可。\ngetters中有四个参数，全为系统默认参数，没有留用户参数的位置\n1. 第一个参数是state对象的引用\n2. 第二个参数是项目vuex中全部（所有模块中）的state，不管是在哪个模块，都可以找到。比如有两个模块list和user，他可以找到list和user模块下面的所有具体属性，并且包括了每个属性的get和set，所以可以任意修改别的模块里面的state\n3. 第三个参数是当前模块的getters，并且包括每一个getter的get\n4. 第四个参数是vuex中全部（所有模块中）的getter，并且包括每个getter的get\n+ 注意：只有第一个参数是当前模块state的引用，其他不是\n\n#### 使用actions\nactions中每一个函数在定义的时候只能有两个参数\n1. 第一个参数是系统赋予的当前的模块的vuex对象；\n2. 第二个参数可以供用户使用，做一些传参操作，可以使用对象传参的方式，但要注意传参的属性名和定义的属性名必须相同。\n\n#### 使用mutations\nmutations中每一个函数在定义的时候也只能有两个参数\n1. 第一个参数是系统赋予的当前vuex对象的state对象，这个参数是state对象的引用值；\n2. 第二个参数是可以供用户使用\n以user模块为例：\n```javascript\nconst state = {\n  userName: 'masia',\n  number: 15\n}\nconst getters = {\n  bigOrSmall (state, bothState, currentGetters, bothGetters) {\n    console.log('state', state) // 当前模块的state的引用\n    console.log('bothState', bothState) // 所有模块中的state\n    console.log('currentGetters', currentGetters) // 当前模块中的getters\n    console.log('bothGetters', bothGetters) // 所有模块中的getters\n    console.log('第三个参数', sss)\n    bothState.appName = '修改了吧' // 可以修改其他模块中的state中的某个属性\n    return state.number > 10 ? '大' : '小'\n  },\n  testGetter (state) {\n\n  }\n}\nconst actions = {\n  modifyNumber ({ state, commit }, {isAdd, size, cb}) {\n    if (isAdd) {\n      commit('addNum', { size })\n    } else {\n      commit('subNum', { size })\n    }\n    cb && cb()\n  }\n}\nconst mutations = {\n  addNum (_state, { size }) {\n    state.number += size\n  },\n  subNum (state, { size }, name ) {\n    state.number -= size\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  getters,\n  mutations,\n  actions\n}\n\n```","source":"_posts/vue技术栈梳理-状态管理篇.md","raw":"---\ntitle: vue技术栈梳理-状态管理篇\ncategories: \n  - vue\n  - vuex\ntags: \n - vue\n - vuex\ndate: 2019-06-12\n---\n#### 首先复习父子组件间的通信\n<!-- more -->\n编写组件实现 input的 v-model 功能\n+ myInput 组件\n```javascript\n<template>\n  <div>\n    <input :type=\"type\" @input=\"handleInput\" :value=\"value\"/>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n\n      }\n  },\n  props: {\n    type: {\n      type: String,\n      default: 'text'\n    },\n    value: {\n      type: [String, Number],\n      default: ''\n    }\n  },\n  components: {\n    \n  },\n  methods: {\n    handleInput (event) {\n      const value = event.target.value\n      this.$emit('input', value)\n    }\n  }\n}\n</script>\n```\n在页面中使用myInput组件\n```javascript\n<template>\n  <div>\n    <p>input component</p>\n    <div>\n      <myInput @input=\"getInputVal\" :value=\"inputValue\"/>\n      // 这个组件就相当于 <input v-model=\"inputValue\"/>\n      // 因为自定义的事件名比较特殊，为input，\n      // 组件接收的参数名也比较特殊，为value，\n      // 所以可以直接改写为 <myInput v-model=\"inputValue\"/>\n      // 当然下面也就省去了写getInput函数了\n      <div>{{inputValue}}</div>\n    </div>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">4\nimport myInput from '_c/myInput' // 导入 自己编写的 输入组件\nexport default {\n  data () {\n    return {\n      inputValue: 'this is input value'\n    }\n  },\n  components: {\n    myInput\n  },\n  methods: {\n    getInputVal (inputValue) {\n      this.inputValue = inputValue\n    }\n  }\n}\n</script>\n```\n\n要注意的是： \n父子组件传值是单向数据流，不能在子组件中直接去修改父组件中的值，而必须通过emit向父组件提交一个自定义事件，然后把要修改的值，传在这个自定义事件函数的参数  中，让父组件自己去修改。\n\n#### 兄弟组件通信\n+ 当然也可以这样做，child1 组件使用自定义事件向父组件提交一个参数，然后在父组件中使用事件接收函数用这个参数去修改绑定给child2组件的参数值\n这种情况适用于，两个兄弟组件依赖同一个父组件\n+ 那么两个同时存在的路由组件如何通行呢？\n比如：\n```javascript\n<div>\n  <router-view name=\"default\"/> // 组件A\n  <router-view name=\"tel\"/> // 组件B\n</div>\n```\n当然，如果这两个router-view写在App.vue中，也可以借助App.vue 作为桥梁完成这两个兄弟组件间的传值（router-view组件的属性绑定和事件绑定和一般的自定义组件的操作方式相同）。因为router-view是一个用于替换内容的通用容器，如果给router-view上绑定很多属性和自定义事件函数，如：<router-view :value=\"value\" :tel=\"tel\" :desc=\"desc\" @toSilbing=\"toSibling\"/>，一方面会给我们的App.vue这个根组件中写入很多帮助兄弟组件间传值的中间属性和中间方法，污染全局的根组件，不符合高内聚低耦合的编程思想，另一方面在某个单独的组件中也需要定义大量的可能用到的属性和传值事件函数，代码量冗余，工作量也会加大。\n\n#### 使用bus完成兄弟组件间的传值\n文件`lib/bus/index.js`\n```javascript\nimport Vue from 'vue'\nconst Bus = new Vue()\nexport default Bus\n```\n在main.js中引入bus\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport bus from './lib/bux'\n\nVue.config.productionTip = false\nVue.prptotype.$bus = bus // 在vue的原型对象上添加$bus\n\nnew Vue({\n  router,\n  render: h => h(App)\n}).$mount('#app')\n\n```\n组件child1.vue\n```javascript\n<template>\n  <div>\n    <p>child1 component</p>\n    <p>使用bus传递来自child2的值 {{ fromSiblingValue }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n        fromSiblingValue: ''\n      }\n  },\n  components: {\n\n  },\n  mounted () { // 在mountd的时候，名为为bus的vue实例绑定事件，因为bus实例永远不会消失，所以使用$on为bus绑定事件，等待$emit去触发事件。\n    this.$bus.$on('use-bus', mes => {\n      this.fromSiblingValue = mes\n    })\n  }\n}\n</script>\n```\n组件child2.vue\n```javascript\n<template>\n  <div>\n    <p>child2 component</p>\n    <button @click=\"useBus\">使用bus</button>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n\n      }\n  },\n  methods: {\n    useBus () { // 使用$emit去触发 已经在bus中绑定的 'use-bus' 事件。\n      this.$bus.$emit('use-bus', 'this is came from sibling')\n    }\n  }\n}\n</script>\n```\n注意： 使用$emit和$on，触发和绑定事件，必须只能在同一个vue实例中完成。\n\n#### 使用vuex\n在main.js中\n```javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport App from './App'\nimport router from './router'\nimport Bus from './lib/bus'\n\nVue.config.profuctionTip = false\nVue.prototype.$bus = Bus\n\nnew Vue({\n  router,\n  store,\n  render: h => h(App)\n}).$mount('#app')\n```\n文件`/store/index.js`\n```javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport state from './state'\nimport getters from './getters'\nimport actions from './actions'\nimport mutations from './mutations'\nimport user from './modules/user'\n\nimport config from '@/config' // 引入配置对象\nVue.use(Vuex)\n\nexport default new Vuex.Store({ // 这里要注意使用的Vuex.Store\n  state,\n  getters,\n  mutations,\n  actions,\n  mudules: {\n    user\n  }\n})\n\n```\n需要注意的是：在如何操作在模块中定义的状态，比如user模块\n```javascript\nconst state = {\n  userName = 'masia'\n}\nconst getters = {\n\n}\nconst actions = {\n\n}\nconst mutations = {\n\n}\n\nexport default {\n  state,\n  getters,\n  mutations,\n  actions\n}\n```\n在组件中的使用方式\n```javascript\n<template>\n  <div>\n    <p>{{ userName }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n\n  },\n  computed: {\n    userName () {\n      return this.$store.state.user.userName\n                              // 这里得写模块名\n    }\n  }\n}\n</script>\n```\n使用mapState等工具函数来操作模块中的状态\n```javascript\n<template>\n  <div>\n    <p>{{ userName }}</p>\n    <p>{{ appName }}</P>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nimport { mapState } from 'vuex' \nexport default {\n  data () {\n\n  },\n  computed: {\n    ...mapState(['appName']) // ... 是es6中的展开操作符，也是剩余操作符\n    /* 这里用作展开操作，会展开一个对象，这里这样写，相当于\n     appName () {\n      return this.$store.state.appName\n    }\n    \n    // 当然也可以传入一个对象\n    ...map({\n     appName: state => state.appName \n     userName: state => state.user.userName \n    })\n    */\n    userName () {\n      return this.$store.state.user.userName\n                              // 这里得写模块名\n    }\n  }\n}\n</script>\n```\n+ 注意\n  1. 使用`...mapState(['appName', 'userName'])`这种方式，获取不到在user模块中state中的userName，在chrome dev tools中可以看到userName: undefined\n  2. 使用对象方式可以获取到 userName\n  ```javascript\n  ...mapState({\n    userName: state => state.user.userName,\n    appName: state => state.appName \n  })\n  ```\n  3. 在user模块中使用命名空间，在组件中使用createNamespacedHelpers重新为mapState绑定模块\n```javascript\n// user模块\nconst state = {\n  userName = 'masia'\n}\nconst getters = {\n\n}\nconst actions = {\n\n}\nconst mutations = {\n\n}\n\nexport default {\n  namespaced: true, // 设置命名空间\n  state,\n  getters,\n  mutations,\n  actions\n}\n```\n  在组件中使用：\n```javascript\n<template>\n  <div>\n    <p>login</p> \n    <p>{{ userName }}</p>\n    <p>{{ appName }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nimport { createNamespacedHelpers } from 'vuex' // 使用createNamespaceHelpers\nconst { mapState } = createNamespacedHelpers('user')\nexport default {\n  data () {\n      return {\n\n      }\n  },\n  mounted () {\n    console.log(createNamespacedHelpers)\n    /*\n      var createNamespacedHelpers = function (namespace) { return ({\n        mapState: mapState.bind(null, namespace),\n        mapGetters: mapGetters.bind(null, namespace),\n        mapMutations: mapMutations.bind(null, namespace),\n        mapActions: mapActions.bind(null, namespace)\n      }); };\n      */\n  },\n  components: {\n    \n  },\n  computed: {\n    ...mapState(['appName', 'userName']), // 这里的appName就为undefined了，因为user中没有appName\n    // ...mapState({\n    //   userName: state => state.userName, // 则这里直接在state中获取uesrName\n    // })\n  }\n}\n</script>\n```\n也可以在组件中使用：\n```javascript\n<template>\n  <div>\n    <p>login</p> \n    <p>{{ userName }}</p>\n    <p>{{ appName }}</p>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nimport { mapState } from 'vuex' \nexport default {\n  data () {\n      return {\n\n      }\n  },\n  computed: {\n    ...mapState('user', ['appName', 'userName']),\n    /**\n     *  或者\n     * ...mapState('user', {\n     *  userName: state => state.userName,\n     *  appName: state => state.appName\n     * }) \n     */\n  }\n}\n</script>\n```\n\n#### 使用getters\n首先明确getters的使用场景，在同一个路由组件中，如果只有一个局部组件依赖state中的某个属性来得到一个计算值，那么完全可以把这个计算属性写在他自己的组件中。但是，如果页面上多个局部组件都要使用计算值，那么应该直接把计算属性写在vuex中，在局部组件中拿来使用即可。\ngetters中有四个参数，全为系统默认参数，没有留用户参数的位置\n1. 第一个参数是state对象的引用\n2. 第二个参数是项目vuex中全部（所有模块中）的state，不管是在哪个模块，都可以找到。比如有两个模块list和user，他可以找到list和user模块下面的所有具体属性，并且包括了每个属性的get和set，所以可以任意修改别的模块里面的state\n3. 第三个参数是当前模块的getters，并且包括每一个getter的get\n4. 第四个参数是vuex中全部（所有模块中）的getter，并且包括每个getter的get\n+ 注意：只有第一个参数是当前模块state的引用，其他不是\n\n#### 使用actions\nactions中每一个函数在定义的时候只能有两个参数\n1. 第一个参数是系统赋予的当前的模块的vuex对象；\n2. 第二个参数可以供用户使用，做一些传参操作，可以使用对象传参的方式，但要注意传参的属性名和定义的属性名必须相同。\n\n#### 使用mutations\nmutations中每一个函数在定义的时候也只能有两个参数\n1. 第一个参数是系统赋予的当前vuex对象的state对象，这个参数是state对象的引用值；\n2. 第二个参数是可以供用户使用\n以user模块为例：\n```javascript\nconst state = {\n  userName: 'masia',\n  number: 15\n}\nconst getters = {\n  bigOrSmall (state, bothState, currentGetters, bothGetters) {\n    console.log('state', state) // 当前模块的state的引用\n    console.log('bothState', bothState) // 所有模块中的state\n    console.log('currentGetters', currentGetters) // 当前模块中的getters\n    console.log('bothGetters', bothGetters) // 所有模块中的getters\n    console.log('第三个参数', sss)\n    bothState.appName = '修改了吧' // 可以修改其他模块中的state中的某个属性\n    return state.number > 10 ? '大' : '小'\n  },\n  testGetter (state) {\n\n  }\n}\nconst actions = {\n  modifyNumber ({ state, commit }, {isAdd, size, cb}) {\n    if (isAdd) {\n      commit('addNum', { size })\n    } else {\n      commit('subNum', { size })\n    }\n    cb && cb()\n  }\n}\nconst mutations = {\n  addNum (_state, { size }) {\n    state.number += size\n  },\n  subNum (state, { size }, name ) {\n    state.number -= size\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  getters,\n  mutations,\n  actions\n}\n\n```","slug":"vue技术栈梳理-状态管理篇","published":1,"updated":"2020-01-20T07:45:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gj80052lktv9yaabprg"},{"title":"vue技术栈梳理-路由篇","date":"2019-06-10T16:00:00.000Z","_content":"# 对平时使用的vue技术栈进行系统的梳理，有助于以后更加全面和系统的掌握vue技术栈，并且提高编码的熟练度，加快以后的开发速度\n<!-- more -->\n## vue-router\n1. router-link和router-view组件\n2. 路由配置\n  1. 动态路由\n  2. 嵌套路由\n  3. 命名路由\n  4. 命名视图\n3. js操作路由\n4. 重定向和别名\n\n### router-link和router-view组件\n  router-link在没有参数tag的情况下面会被渲染成为a标签\n### 路由配置\n```javascript\n// 在router.js中\nimport Home from '@/views/Home'\n\nexport default {\n  routes: [\n    { \n      path: '/home',\n      name: 'home',\n      component: Home,\n    },\n    {\n      path: '/about',\n      name: 'about',\n      component: () => import('@/views/About')\n    },\n    {\n      path: '/argu/:name',\n      name: 'argu',\n      component: () => import('@/views/argu')\n    },\n    {\n      path: '/parent',\n      name: 'parent',\n      component: () => import('@/views/parent'),\n      children: [\n        {\n          path: '/child1',\n          name: 'child1',\n          components: {\n            right: () => import('@/views/child2'),\n            left: () => import('@/views/child1')\n          } \n        },\n        {\n          path: '/child2',\n          name: 'child2',\n          components: {\n            right: () => import('@/views/child1')\n          }\n        }\n      ]\n    }\n  ]\n}\n```\n#### 简单路由 \n`/about`和`/home`为最简单的两种路由配置，因为home页是访问平时访问比较多的页面，所以我们选择在router.js 文件在加载的时候就引入，而about页是平时访问频率较低的页面，所以我们选择按需引入，等到有路由请求的时候，再去动态引入。\n\n#### 传参路由\n`/argu/:name`是一种常见的传参路由，比如使用router-link来发送一个路由请求，并且给$route对象中传入params参数name。\n`<router-link to=\"/argu/masia\">传入参数name: 'masia'</router-link>`\n\n需要注意的是： \n  1. 如果选择上述 `to=\"/argu/masia\"` 这种方式传参数，系统会把路由中的参数写在地址栏中，比如：`localhost:8080/argu/masia`，这样用户在刷新页面的时候，系统会拿 地址栏的中的url地址，并且截取端口号后面的字符串，进行路由匹配。\n  2. 如果路由匹配规则是\n  ```javascript\n  routes: [\n    {\n      path: '/argu',\n      name: 'argu',\n      component: () => import('@/views/argu')\n    }\n  ]\n  ```\n  选择 `:to=\"{ name: 'argu', params: { id: 2 }}\"` 或者使用编程式路由 `this.$router.push({ name: 'argu', params: { id: 2 }})`这种方式传递参数，系统不会把params中的参数写在地址栏中，比如：`localhost:8080/argu`，第一次进入页面时，可以拿到params参数，但这样用户在刷新页面的时候，系统会拿地址栏的中的url端口号后面的字符串`/argu`，进行路由匹配。如果路由匹配规则中有path为`/argu`的路由，则会跳转到path为`/argu`这个页面，但是在这一次，系统在也拿不到params参数了。\n  所以，要使用name进行路由匹配，并且传参，务必在路由匹配规则中将path上面的形参定义完整，正确规则定义如下：\n  ```javascript\n  routes: [\n    {\n      path: '/argu/:id',\n      name: 'argu',\n      component: () => import('@/views/argu')\n    }\n  ]\n  ```\n  3. 还遇到了好多不规范的路由规则定义，问题总结解决方案如下：\n   1. 同名不同p，名匹配，谁前听谁，p匹配，正常\n   2. 不同名同p，名匹配，正常，p匹配，谁前听谁\n   3. 不同名不同p，正常\n   4. 同p否，看p串\n   5. 路由形参未定义，用名匹配并传参，刷新丢参\n\n+ 编程式路由\n```javascript\n// 一般路由，使用router-link\n<router-link to=\"/test/33\">实参为id: 33</router-link>\n<router-link :to=\"{ path: '/test/33' }\">实参为id: 33</router-link>\n<router-link :to=\"{ name: 'test', params: { id: 3 }}\">实参为id: 33</router-link>\n// 编程式路由\nthis.$router.push('/test/33') // 可以直接写path字符串\nthis.$router.push({ // 也可以传入一个包含了path的配置对象\n  path: '/test/33'\n})\nthis.$router.push({ // 也可以传入包含name和params参数的配置对象\n  name: 'test',\n  params: {\n    id: 33\n  }\n})\n// 还有一个常见的路由方法，\nthis.$router.replace() // 替换当前的路由，假如路由从A跳到B，然后从B到C使用的此方法，那么从C执行this.$router.go(-1)，退回的是A。\n```\n#### 嵌套路由\n```javascript\nroutes: [\n  {\n    path: '/home',\n    name: 'home',\n    component: () => import('@/views/home'),\n    children: [\n      {\n        path: '/child1',\n        name: 'child1',\n        component: () => import('@/views/child1')\n      },\n      {\n        path: '/child2',\n        name: 'child2',\n        component: () => import('@/views/child2')\n      }\n    ]\n  }\n]\n```\n需要注意的是：\n  1. 如果在children中的path中写`/child1`，那么访问child1子组件的path实际就为`/chlid`，在地址栏中也写为`/child`\n  2. 如果在children中的path中写`child`，那么访问child1子组件的path实际就为`/parent/child`，在地址栏中也写为`/parent/child`\n口诀：有杠为己p，无杠拼其父\n\n#### 命名视图\n```javascript\n// 路由匹配规则\nroutes: [\n  {\n    path: '/home',\n    name: 'home',\n    components: {\n      default: () => import('@/components/center')\n      left: () => import('@/components/left'),\n      right: () => import('@/components/right'),\n    }\n  }\n]\n```\n对应的router-view\n```html\n<router-view name=\"left\"/>\n<router-view/> // 没有命名，代表填充的是default对应的路由组件\n<router-view name=\"right\"/>\n```\n\n#### 命名路由\n在组件定义的时候加上name属性，在调用的时候通过$route中的name属性去调用。\n\n#### 路由重定向\n```javascript\nroutes: [\n  {\n    path: '/', // 在一级路由中设置重定向，则访问网站域名，直接重定向到/parent\n    redirect: '/parent'\n  },\n  {\n    path: '/parent',\n    name: 'parent',\n    component: () => import('@/views/parent'),\n    children: [\n      {\n        path: '/', // 在子级路由设置'/'或者''，那么访问父级路由'/parent'，则会直接重定向到'/parent/child'\n                  //  如果在子级路由中设置 '/fisrt'，任意的带斜杠的path，则会将当前重定向的路由按照一级路由处理\n                  //  不能重定向有params参数定义的路由\n                  //  重新定向可以传query参数，字符串方式和对象方式都可以\n        redirect: 'child'\n      },\n      {\n        path: 'child',\n        name: 'child',\n        component: () => import('@/views/child')\n      }\n    ]\n  }\n]\n```\n#### 路由组件接收props\n非路由父组件给子组件传值，一般使用的是自定义属性，然后子组件中使用props接收。路由组件在路由跳转后，需要传递的参数值一般保存在$route中。\n但是，其实路由组件也可以使用props来传值。\n1. 布尔模式：路由中的props为一个布尔值：\n路由匹配规则：\n```javascript\nroutes: [\n  {\n    path: '/list/:name',\n    name: 'name',\n    component: () => import('@/components/list'),\n    props: true // 启用props传参，给props传一个boolean类型的值\n  }\n]\n```\nlist路由组件\n```javascript\n<template>\n <div>\n   {{ name }}\n </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  date () {\n\n  },\n  props: {\n    name: {\n      type: String\n    }\n  }\n}\n</script>\n```\n2. 对象模式：路由匹配规则中的props值为一个对象\n```javascript\nroutes: [\n  {\n    path: '/list', // 这里不需要定义形参 :food\n    name: 'name',\n    component: () => import('@/components/list'),\n    props: { // 给props传一个对象\n      food: 'banner' // 不用的路由可以给food不同的值，虽然我不知道这个能用来干什么\n    } \n  }\n]\n```\nlist路由组件\n```javascript\n<template>\n <div>\n   {{ food }}\n </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  date () {\n\n  },\n  props: {\n    food: {\n      type: String\n    }\n  }\n}\n</script>\n```\n3. 函数模式：适合根据当前的路由来做一些处理逻辑 ，从而设置传入组件的属性值\n```javascript\nexport default [\n  {\n    path: '/list', // 这里不需要定义形参 :food\n    name: 'name',\n    component: () => import('@/components/list'),\n    props: route => ({\n      food: route.query.food // 把$route对象中query对象的food属性值拿出来，动态赋值给props中的food\n                              // 但是好像这么做是多此一举，在路由组件中干嘛不直接取this.$route.query.food\n    }) \n  }\n]\n```\nlist路由组件\n```javascript\n<template>\n <div>\n   {{ food }}\n </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  date () {\n\n  },\n  props: {\n    food: {\n      type: String\n    }\n  }\n}\n</script>\n```\n#### html5 history模式\n文件 `/router/index.js`\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport routes from './router'\n\nVue.use(Router)\n\nconst router = new Router({\n  // mode: 'hash', // 默认值 是 hash模式，就是在url里面有一个＃号，在#号后面做路由的变化，页面是不会刷新的，本来就是单页面，只在这一个页面中变化\n  mode: 'history', // history模式是利用history的一些api来做无刷新页面的路由跳转\n  routes\n})\n\n// 在这里可以写路由守卫\n\nexport default router\n```\n使用history模式，必须后端做一些配置，因为当你访问localhost:8080的时候，后台会自动访问index.html，但是当你访问localhost:8080/list的时候，后端会把这个url当作静态资源来匹配，如果后台不做处理，浏览器会报404错误。\n所以，后端需要配置如果没有匹配到指定的url，那么就返回index.html\n但是当你既匹配不到静态资源，又匹配不到路由时，那就出问题了，所以一般需要在路由列表中最底下配置一个通用路由匹配规则\n```javascript\nroutes: [\n  // 上面都是具体的匹配规则\n  {\n    path: '*',\n    component: () => import('@/views/error_404')\n  }\n]\n```\n\n#### 导航守卫\n执行生命周期：路由发生跳转 -- 导航结束\n比如：在跳转到一个页面的时候，判断用户有没有登录，如果已经登录了，则正常跳转，如果没有登录，则跳转到登录页面。\n还有判断是否有访问某个页面的权限\n+ 全局守卫（三个：router.beforeEach，router.beforeResolve，router.afterEach）\n`文件router/index.js`\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport routes from './router'\n\nVue.use(Router)\n\nconst router = new Router({\n  mode: 'hash'\n  routes\n})\n\nconst HAS_LOGIN = true\n// 在这里可以写路由守卫\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'login') {\n    if (HAS_LOGIN) next()\n    else next({ //如果还没有登录， 则跳转到login页面\n    // next() 和 this.$router.push() 方法中传入的值是一样的，可以是一个path字符串，也可以是对象\n      name: 'login'\n    })\n  } else { // 如果访问的是登录页面，但是之前已经登录了，那么我们把让它跳到首页\n    if (HAS_LOGIN) next({ name: 'home' }) \n  }\n})\n\n// 导航被确认（导航被确认指的是：所有导航钩子被确认）之前，所有组件内守卫和异步路由组件被解析之后被调用\nrouter.beforeResolve((to, from, next) => {\n  next()\n})\n\n// 导航被确认之后，使用场景：可以在条状之前写一个loading的样式，而在跳转之后，取消这个loading样式\nrouter.afterEach((to, from, next) => {\n  // afterEach中没有next，所以可以不传\n  console.log('afterEach next: ',nexts) // afterEach next: undefined\n})\nexport default router\n```\n+ 路由独享守卫（只有一个：beforeEnter）\n文件`/router/router.js`\n```javascript\nexport default [\n  {\n    path: '/home', // 这里不需要定义形参 :food\n    name: 'home',\n    component: () => import('@/views/home'),\n    beforeEnter: (to, from, next) => {\n      // 在这里进行路径的处理\n      if (from.name === 'login') alert('这是从登录页来的')\n      else alert('这不是从登录页来的')\n      next()\n    }\n  }\n]\n```\n+ 组件内守卫\n<!-- home组件 -->\n```javascript\n<template>\n  <div>\n    this is home\n  </div>\n</template>\n\n<sciprt type=\"text/esmascript-6\">4\nexport default {\n  name: 'home',\n  data () {\n    return {\n\n    }\n  },\n  beforeRouteEnter: (to, from, next) => {\n    // 路由触发，还没进来的时候调用，页面还没有渲染，在这里使用this，是获取不到实例的，但是可以next中使用组件实例\n    next(vm => { // vm 就是当前的组件实例\n      console.log(vm)\n    })\n  }),\n  beforeRouteLeave: (to, from, next) => {\n    // 路由即将离开时调用\n    // 在这里可以做提示，比如：提示当前编辑内容还未保存，是否选择离开？ \n    const leave = confirm('您确定要离开吗？')\n    if (leave) next();\n    else next(false) // 给next传入false就不会发生跳转\n\n    // 这个方法一般适用与适用router-link做跳转的场景\n    // 如果我用的this.$route.push('/xxx')这样的方式做跳转，那我完全可以在确定点击之后去执行this.$route.puth('/xxx')\n  }),\n  beforeRouteUpdate: (to, from, next) => {\n    // 这个钩子发生在，路由发生变化，组件被复用的时候调用\n    // 比如：路由发生了 '/list/33' 到 '/list/22' 这样变化的时候，\n    // mounted钩子只在请求为'/list/33'时执行了一次，但是我们的数据请求写在mounted中，\n    // 所以点击选项卡，改变参数，执行路由'/list/22'时，mounted没有被执行，那么数据请求就没有被执行，\n    // 以前的做法是 监听 $route 对象，然后在监听函数中再去写数据请求\n    // 有了这个钩子，就可以直接在这个里面写了\n    this.getDate(to.params.id) // 只需要在给选项卡绑定click时间，去改变id值\n    next()\n  }\n}\n</script>\n```\n\n#### 在这三种守卫中访问this\n```javascript\n<template>\n  <div>\n    <div ref=\"testTmp\">\n      this is test component\n    </div>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n        list: [{\n          id: 1\n        },{\n          id: 2\n        },{\n          id: 3\n        }]\n      }\n  },\n  components: {\n\n  },\n  beforeRouteEnter: (to, from, next) => {\n    console.log('before', this) // 拿不到this，输出undefined\n    next(vm => console.log('vm', vm)) // 能拿到当前组件实例，但是拿不到组件中的数据，即使组件数据还未初始化\n  },\n  create () {\n    console.log(this.list) // 没执行\n    console.log(this.$refs.testTmp) // 没执行\n  },\n  mounted () {\n    console.log(this.list) // 能拿到数据\n    console.log(this.$refs.testTmp) // 能拿到模板\n  },\n  beforeRouteUpdate: (to, from, next) => {\n    console.log('update', this) // 能拿到当前组件实例，但是拿不到组件中的数据，即使组件数据还未初始化\n    next()\n  }\n}\n</script>\n```\n\n#### beforeRouteUpdate 钩子的使用示例子，取代以前监听$route对象那种方法\n```javascript\n<template>\n  <div>\n    <div>\n      <template v-for=\"item in list\">\n        <!-- 这里假如是一组选项卡，点击不同的选项卡，对应列表的id不同，点击完成之后要使用新的id来当作参数获取数据 -->\n        <a @click=\"$router.push('/list' + item.id)\">id为{{item.id}}</a> |\n      </template>\n    </div>\n    <div>\n      params中的id值为: {{$route.params.id}}\n    </div>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n        list: [{\n          id: 1\n        },{\n          id: 2\n        },{\n          id: 3\n        }]\n      }\n  },\n  components: {\n\n  },\n  mounted () {\n    console.log(this.$route.params.id) // 只在页面第一次加载的时候输出\n  },\n  beforeRouteUpdate: (to, from, next) => {\n    // 这个钩子发生在，路由发生变化，组件被复用的时候调用\n    // 比如：路由发生了 '/list/33' 到 '/list/22' 这样变化的时候，\n    // mounted钩子只在请求为'/list/33'时执行了一次，但是我们的数据请求写在mounted中，\n    // 所以点击选项卡，改变参数，执行路由'/list/22'时，mounted没有被执行，那么数据请求就没有被执行，\n    // 以前的做法是 监听 $route 对象，然后在监听函数中再去写数据请求\n    // 有了这个钩子，就可以直接在这个里面写了\n    // 只需要在给选项卡绑定click时间，去改变id值\n    console.log(to.params.id) // 点击选项卡会在控制台输出对应的 id 值\n    next()\n  }\n}\n</script>\n\n<style scoped>\n\n \n</style>\n```\n\n#### 总结：整个执行顺序\n1. 导航被触发\n2. 在失活的组件（即将离开的页面组件）里调用离开守卫 beforeRouteLeave\n3. 调用全局的前置守卫 beforeEach\n4. 在重用的组件里调用 beforeRouteUpdate（如果没有重用组件，则跳过这步骤）\n5. 调用路由独享的守卫 beforeEnter\n6. 解析异步路由组件\n7. 在被激活的组件（即将进入页面的组件）里调用 beforeRouteEnter\n8. 调用全局的解析守卫 beforeResolve\n9. 导航被确认\n10. 调用全局的 后置守卫afterEach\n11. 触发DOM更新\n12. 用创建好的实例调用beforeEnter守卫中的next回调函数\n\n#### 路由中meta源信息的使用\n修改不同路由下面的对应不同的title值\n工具文件`lib/tools.js`\n```javascript\nconst setTitle = (title) => {\n  window.document.title = title || 'admin' // 如果title没有的话，会设置默认的admin\n}\n```\n文件`router/index.js`\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport routes from './router'\n\nVue.use(Router)\n\nconst router = new Router({\n  routes\n})\n// 在此文件中引入工具函数，setTitle\nimport { setTitle } from '@/lib/tools'\n\nrouter.beforeEach((to, from, next) => {\n  to.meta && setTitle(to.meta.title) // 这里必须判断meta存在吗，如果meta存在，但是title不存在，访问to.meta.title也不会出错，会报title is undefined \n  //但是meta不存在，访问to.meta.title就会出错，因为title是to.meta.title中的第三级，一般情况下，如果没有二级，但是去访问二级，不会报undefined，\n  //但是连二级都没有，再去访问第三级，就是出错\n  next();\n})\nexport default router\n```\n文件`router/router.js`\n```javascript\nexport default [\n  {\n    path: '/home',\n    name: 'home',\n    component: () => import('@/views/home')\n  }\n]\n```\n#### 组件的过渡动效\n如果值给一个组件设置过渡，则只需要用<transition></transtion>包住\n```javascript\n<transition name=\"router\">\n  <router-view/>\n</transtion>\n```\n如果给多个路由逐渐设置过渡，需要使用<transition-group></transition-group>保住多个<router-view/>, 并且为每一个<router-view/>设置一个key值\n```javascript\n<transition-group  name=\"router\">\n  <router-view key=\"default\" name=\"default\"/>\n  <router-view key=\"email\" name=\"email\"/>\n  <router-view key=\"tel\" name=\"tel\"/>\n</transtion-group>\n```\n```css\n.router-enter { // 从无到进入时\n  opacity: 0;\n}\n.router-enter-active { 进入到完全显示，一般transition属性设置在这个阶段\n  transition: opacity 1s ease;\n}\n.router-enter-to { 完全显示时\n  opacity: 1;\n}\n.router-leave { // 从完全显示到开始离开时\n  opacity: 1;\n}\n.router-leave-active { // 从开始离开到消失\n  transition: opacity 1s ease;\n}\n.router-leave-to { // 完全消失\n  opacity: 0;\n}\n```\n\n#### keep-alive","source":"_posts/vue技术栈梳理-路由篇.md","raw":"---\ntitle: vue技术栈梳理-路由篇\ncategories: \n  - vue\n  - vue-router\ntags: \n - vue\n - vue-router\ndate: 2019-06-11\n---\n# 对平时使用的vue技术栈进行系统的梳理，有助于以后更加全面和系统的掌握vue技术栈，并且提高编码的熟练度，加快以后的开发速度\n<!-- more -->\n## vue-router\n1. router-link和router-view组件\n2. 路由配置\n  1. 动态路由\n  2. 嵌套路由\n  3. 命名路由\n  4. 命名视图\n3. js操作路由\n4. 重定向和别名\n\n### router-link和router-view组件\n  router-link在没有参数tag的情况下面会被渲染成为a标签\n### 路由配置\n```javascript\n// 在router.js中\nimport Home from '@/views/Home'\n\nexport default {\n  routes: [\n    { \n      path: '/home',\n      name: 'home',\n      component: Home,\n    },\n    {\n      path: '/about',\n      name: 'about',\n      component: () => import('@/views/About')\n    },\n    {\n      path: '/argu/:name',\n      name: 'argu',\n      component: () => import('@/views/argu')\n    },\n    {\n      path: '/parent',\n      name: 'parent',\n      component: () => import('@/views/parent'),\n      children: [\n        {\n          path: '/child1',\n          name: 'child1',\n          components: {\n            right: () => import('@/views/child2'),\n            left: () => import('@/views/child1')\n          } \n        },\n        {\n          path: '/child2',\n          name: 'child2',\n          components: {\n            right: () => import('@/views/child1')\n          }\n        }\n      ]\n    }\n  ]\n}\n```\n#### 简单路由 \n`/about`和`/home`为最简单的两种路由配置，因为home页是访问平时访问比较多的页面，所以我们选择在router.js 文件在加载的时候就引入，而about页是平时访问频率较低的页面，所以我们选择按需引入，等到有路由请求的时候，再去动态引入。\n\n#### 传参路由\n`/argu/:name`是一种常见的传参路由，比如使用router-link来发送一个路由请求，并且给$route对象中传入params参数name。\n`<router-link to=\"/argu/masia\">传入参数name: 'masia'</router-link>`\n\n需要注意的是： \n  1. 如果选择上述 `to=\"/argu/masia\"` 这种方式传参数，系统会把路由中的参数写在地址栏中，比如：`localhost:8080/argu/masia`，这样用户在刷新页面的时候，系统会拿 地址栏的中的url地址，并且截取端口号后面的字符串，进行路由匹配。\n  2. 如果路由匹配规则是\n  ```javascript\n  routes: [\n    {\n      path: '/argu',\n      name: 'argu',\n      component: () => import('@/views/argu')\n    }\n  ]\n  ```\n  选择 `:to=\"{ name: 'argu', params: { id: 2 }}\"` 或者使用编程式路由 `this.$router.push({ name: 'argu', params: { id: 2 }})`这种方式传递参数，系统不会把params中的参数写在地址栏中，比如：`localhost:8080/argu`，第一次进入页面时，可以拿到params参数，但这样用户在刷新页面的时候，系统会拿地址栏的中的url端口号后面的字符串`/argu`，进行路由匹配。如果路由匹配规则中有path为`/argu`的路由，则会跳转到path为`/argu`这个页面，但是在这一次，系统在也拿不到params参数了。\n  所以，要使用name进行路由匹配，并且传参，务必在路由匹配规则中将path上面的形参定义完整，正确规则定义如下：\n  ```javascript\n  routes: [\n    {\n      path: '/argu/:id',\n      name: 'argu',\n      component: () => import('@/views/argu')\n    }\n  ]\n  ```\n  3. 还遇到了好多不规范的路由规则定义，问题总结解决方案如下：\n   1. 同名不同p，名匹配，谁前听谁，p匹配，正常\n   2. 不同名同p，名匹配，正常，p匹配，谁前听谁\n   3. 不同名不同p，正常\n   4. 同p否，看p串\n   5. 路由形参未定义，用名匹配并传参，刷新丢参\n\n+ 编程式路由\n```javascript\n// 一般路由，使用router-link\n<router-link to=\"/test/33\">实参为id: 33</router-link>\n<router-link :to=\"{ path: '/test/33' }\">实参为id: 33</router-link>\n<router-link :to=\"{ name: 'test', params: { id: 3 }}\">实参为id: 33</router-link>\n// 编程式路由\nthis.$router.push('/test/33') // 可以直接写path字符串\nthis.$router.push({ // 也可以传入一个包含了path的配置对象\n  path: '/test/33'\n})\nthis.$router.push({ // 也可以传入包含name和params参数的配置对象\n  name: 'test',\n  params: {\n    id: 33\n  }\n})\n// 还有一个常见的路由方法，\nthis.$router.replace() // 替换当前的路由，假如路由从A跳到B，然后从B到C使用的此方法，那么从C执行this.$router.go(-1)，退回的是A。\n```\n#### 嵌套路由\n```javascript\nroutes: [\n  {\n    path: '/home',\n    name: 'home',\n    component: () => import('@/views/home'),\n    children: [\n      {\n        path: '/child1',\n        name: 'child1',\n        component: () => import('@/views/child1')\n      },\n      {\n        path: '/child2',\n        name: 'child2',\n        component: () => import('@/views/child2')\n      }\n    ]\n  }\n]\n```\n需要注意的是：\n  1. 如果在children中的path中写`/child1`，那么访问child1子组件的path实际就为`/chlid`，在地址栏中也写为`/child`\n  2. 如果在children中的path中写`child`，那么访问child1子组件的path实际就为`/parent/child`，在地址栏中也写为`/parent/child`\n口诀：有杠为己p，无杠拼其父\n\n#### 命名视图\n```javascript\n// 路由匹配规则\nroutes: [\n  {\n    path: '/home',\n    name: 'home',\n    components: {\n      default: () => import('@/components/center')\n      left: () => import('@/components/left'),\n      right: () => import('@/components/right'),\n    }\n  }\n]\n```\n对应的router-view\n```html\n<router-view name=\"left\"/>\n<router-view/> // 没有命名，代表填充的是default对应的路由组件\n<router-view name=\"right\"/>\n```\n\n#### 命名路由\n在组件定义的时候加上name属性，在调用的时候通过$route中的name属性去调用。\n\n#### 路由重定向\n```javascript\nroutes: [\n  {\n    path: '/', // 在一级路由中设置重定向，则访问网站域名，直接重定向到/parent\n    redirect: '/parent'\n  },\n  {\n    path: '/parent',\n    name: 'parent',\n    component: () => import('@/views/parent'),\n    children: [\n      {\n        path: '/', // 在子级路由设置'/'或者''，那么访问父级路由'/parent'，则会直接重定向到'/parent/child'\n                  //  如果在子级路由中设置 '/fisrt'，任意的带斜杠的path，则会将当前重定向的路由按照一级路由处理\n                  //  不能重定向有params参数定义的路由\n                  //  重新定向可以传query参数，字符串方式和对象方式都可以\n        redirect: 'child'\n      },\n      {\n        path: 'child',\n        name: 'child',\n        component: () => import('@/views/child')\n      }\n    ]\n  }\n]\n```\n#### 路由组件接收props\n非路由父组件给子组件传值，一般使用的是自定义属性，然后子组件中使用props接收。路由组件在路由跳转后，需要传递的参数值一般保存在$route中。\n但是，其实路由组件也可以使用props来传值。\n1. 布尔模式：路由中的props为一个布尔值：\n路由匹配规则：\n```javascript\nroutes: [\n  {\n    path: '/list/:name',\n    name: 'name',\n    component: () => import('@/components/list'),\n    props: true // 启用props传参，给props传一个boolean类型的值\n  }\n]\n```\nlist路由组件\n```javascript\n<template>\n <div>\n   {{ name }}\n </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  date () {\n\n  },\n  props: {\n    name: {\n      type: String\n    }\n  }\n}\n</script>\n```\n2. 对象模式：路由匹配规则中的props值为一个对象\n```javascript\nroutes: [\n  {\n    path: '/list', // 这里不需要定义形参 :food\n    name: 'name',\n    component: () => import('@/components/list'),\n    props: { // 给props传一个对象\n      food: 'banner' // 不用的路由可以给food不同的值，虽然我不知道这个能用来干什么\n    } \n  }\n]\n```\nlist路由组件\n```javascript\n<template>\n <div>\n   {{ food }}\n </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  date () {\n\n  },\n  props: {\n    food: {\n      type: String\n    }\n  }\n}\n</script>\n```\n3. 函数模式：适合根据当前的路由来做一些处理逻辑 ，从而设置传入组件的属性值\n```javascript\nexport default [\n  {\n    path: '/list', // 这里不需要定义形参 :food\n    name: 'name',\n    component: () => import('@/components/list'),\n    props: route => ({\n      food: route.query.food // 把$route对象中query对象的food属性值拿出来，动态赋值给props中的food\n                              // 但是好像这么做是多此一举，在路由组件中干嘛不直接取this.$route.query.food\n    }) \n  }\n]\n```\nlist路由组件\n```javascript\n<template>\n <div>\n   {{ food }}\n </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  date () {\n\n  },\n  props: {\n    food: {\n      type: String\n    }\n  }\n}\n</script>\n```\n#### html5 history模式\n文件 `/router/index.js`\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport routes from './router'\n\nVue.use(Router)\n\nconst router = new Router({\n  // mode: 'hash', // 默认值 是 hash模式，就是在url里面有一个＃号，在#号后面做路由的变化，页面是不会刷新的，本来就是单页面，只在这一个页面中变化\n  mode: 'history', // history模式是利用history的一些api来做无刷新页面的路由跳转\n  routes\n})\n\n// 在这里可以写路由守卫\n\nexport default router\n```\n使用history模式，必须后端做一些配置，因为当你访问localhost:8080的时候，后台会自动访问index.html，但是当你访问localhost:8080/list的时候，后端会把这个url当作静态资源来匹配，如果后台不做处理，浏览器会报404错误。\n所以，后端需要配置如果没有匹配到指定的url，那么就返回index.html\n但是当你既匹配不到静态资源，又匹配不到路由时，那就出问题了，所以一般需要在路由列表中最底下配置一个通用路由匹配规则\n```javascript\nroutes: [\n  // 上面都是具体的匹配规则\n  {\n    path: '*',\n    component: () => import('@/views/error_404')\n  }\n]\n```\n\n#### 导航守卫\n执行生命周期：路由发生跳转 -- 导航结束\n比如：在跳转到一个页面的时候，判断用户有没有登录，如果已经登录了，则正常跳转，如果没有登录，则跳转到登录页面。\n还有判断是否有访问某个页面的权限\n+ 全局守卫（三个：router.beforeEach，router.beforeResolve，router.afterEach）\n`文件router/index.js`\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport routes from './router'\n\nVue.use(Router)\n\nconst router = new Router({\n  mode: 'hash'\n  routes\n})\n\nconst HAS_LOGIN = true\n// 在这里可以写路由守卫\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'login') {\n    if (HAS_LOGIN) next()\n    else next({ //如果还没有登录， 则跳转到login页面\n    // next() 和 this.$router.push() 方法中传入的值是一样的，可以是一个path字符串，也可以是对象\n      name: 'login'\n    })\n  } else { // 如果访问的是登录页面，但是之前已经登录了，那么我们把让它跳到首页\n    if (HAS_LOGIN) next({ name: 'home' }) \n  }\n})\n\n// 导航被确认（导航被确认指的是：所有导航钩子被确认）之前，所有组件内守卫和异步路由组件被解析之后被调用\nrouter.beforeResolve((to, from, next) => {\n  next()\n})\n\n// 导航被确认之后，使用场景：可以在条状之前写一个loading的样式，而在跳转之后，取消这个loading样式\nrouter.afterEach((to, from, next) => {\n  // afterEach中没有next，所以可以不传\n  console.log('afterEach next: ',nexts) // afterEach next: undefined\n})\nexport default router\n```\n+ 路由独享守卫（只有一个：beforeEnter）\n文件`/router/router.js`\n```javascript\nexport default [\n  {\n    path: '/home', // 这里不需要定义形参 :food\n    name: 'home',\n    component: () => import('@/views/home'),\n    beforeEnter: (to, from, next) => {\n      // 在这里进行路径的处理\n      if (from.name === 'login') alert('这是从登录页来的')\n      else alert('这不是从登录页来的')\n      next()\n    }\n  }\n]\n```\n+ 组件内守卫\n<!-- home组件 -->\n```javascript\n<template>\n  <div>\n    this is home\n  </div>\n</template>\n\n<sciprt type=\"text/esmascript-6\">4\nexport default {\n  name: 'home',\n  data () {\n    return {\n\n    }\n  },\n  beforeRouteEnter: (to, from, next) => {\n    // 路由触发，还没进来的时候调用，页面还没有渲染，在这里使用this，是获取不到实例的，但是可以next中使用组件实例\n    next(vm => { // vm 就是当前的组件实例\n      console.log(vm)\n    })\n  }),\n  beforeRouteLeave: (to, from, next) => {\n    // 路由即将离开时调用\n    // 在这里可以做提示，比如：提示当前编辑内容还未保存，是否选择离开？ \n    const leave = confirm('您确定要离开吗？')\n    if (leave) next();\n    else next(false) // 给next传入false就不会发生跳转\n\n    // 这个方法一般适用与适用router-link做跳转的场景\n    // 如果我用的this.$route.push('/xxx')这样的方式做跳转，那我完全可以在确定点击之后去执行this.$route.puth('/xxx')\n  }),\n  beforeRouteUpdate: (to, from, next) => {\n    // 这个钩子发生在，路由发生变化，组件被复用的时候调用\n    // 比如：路由发生了 '/list/33' 到 '/list/22' 这样变化的时候，\n    // mounted钩子只在请求为'/list/33'时执行了一次，但是我们的数据请求写在mounted中，\n    // 所以点击选项卡，改变参数，执行路由'/list/22'时，mounted没有被执行，那么数据请求就没有被执行，\n    // 以前的做法是 监听 $route 对象，然后在监听函数中再去写数据请求\n    // 有了这个钩子，就可以直接在这个里面写了\n    this.getDate(to.params.id) // 只需要在给选项卡绑定click时间，去改变id值\n    next()\n  }\n}\n</script>\n```\n\n#### 在这三种守卫中访问this\n```javascript\n<template>\n  <div>\n    <div ref=\"testTmp\">\n      this is test component\n    </div>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n        list: [{\n          id: 1\n        },{\n          id: 2\n        },{\n          id: 3\n        }]\n      }\n  },\n  components: {\n\n  },\n  beforeRouteEnter: (to, from, next) => {\n    console.log('before', this) // 拿不到this，输出undefined\n    next(vm => console.log('vm', vm)) // 能拿到当前组件实例，但是拿不到组件中的数据，即使组件数据还未初始化\n  },\n  create () {\n    console.log(this.list) // 没执行\n    console.log(this.$refs.testTmp) // 没执行\n  },\n  mounted () {\n    console.log(this.list) // 能拿到数据\n    console.log(this.$refs.testTmp) // 能拿到模板\n  },\n  beforeRouteUpdate: (to, from, next) => {\n    console.log('update', this) // 能拿到当前组件实例，但是拿不到组件中的数据，即使组件数据还未初始化\n    next()\n  }\n}\n</script>\n```\n\n#### beforeRouteUpdate 钩子的使用示例子，取代以前监听$route对象那种方法\n```javascript\n<template>\n  <div>\n    <div>\n      <template v-for=\"item in list\">\n        <!-- 这里假如是一组选项卡，点击不同的选项卡，对应列表的id不同，点击完成之后要使用新的id来当作参数获取数据 -->\n        <a @click=\"$router.push('/list' + item.id)\">id为{{item.id}}</a> |\n      </template>\n    </div>\n    <div>\n      params中的id值为: {{$route.params.id}}\n    </div>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\nexport default {\n  data () {\n      return {\n        list: [{\n          id: 1\n        },{\n          id: 2\n        },{\n          id: 3\n        }]\n      }\n  },\n  components: {\n\n  },\n  mounted () {\n    console.log(this.$route.params.id) // 只在页面第一次加载的时候输出\n  },\n  beforeRouteUpdate: (to, from, next) => {\n    // 这个钩子发生在，路由发生变化，组件被复用的时候调用\n    // 比如：路由发生了 '/list/33' 到 '/list/22' 这样变化的时候，\n    // mounted钩子只在请求为'/list/33'时执行了一次，但是我们的数据请求写在mounted中，\n    // 所以点击选项卡，改变参数，执行路由'/list/22'时，mounted没有被执行，那么数据请求就没有被执行，\n    // 以前的做法是 监听 $route 对象，然后在监听函数中再去写数据请求\n    // 有了这个钩子，就可以直接在这个里面写了\n    // 只需要在给选项卡绑定click时间，去改变id值\n    console.log(to.params.id) // 点击选项卡会在控制台输出对应的 id 值\n    next()\n  }\n}\n</script>\n\n<style scoped>\n\n \n</style>\n```\n\n#### 总结：整个执行顺序\n1. 导航被触发\n2. 在失活的组件（即将离开的页面组件）里调用离开守卫 beforeRouteLeave\n3. 调用全局的前置守卫 beforeEach\n4. 在重用的组件里调用 beforeRouteUpdate（如果没有重用组件，则跳过这步骤）\n5. 调用路由独享的守卫 beforeEnter\n6. 解析异步路由组件\n7. 在被激活的组件（即将进入页面的组件）里调用 beforeRouteEnter\n8. 调用全局的解析守卫 beforeResolve\n9. 导航被确认\n10. 调用全局的 后置守卫afterEach\n11. 触发DOM更新\n12. 用创建好的实例调用beforeEnter守卫中的next回调函数\n\n#### 路由中meta源信息的使用\n修改不同路由下面的对应不同的title值\n工具文件`lib/tools.js`\n```javascript\nconst setTitle = (title) => {\n  window.document.title = title || 'admin' // 如果title没有的话，会设置默认的admin\n}\n```\n文件`router/index.js`\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport routes from './router'\n\nVue.use(Router)\n\nconst router = new Router({\n  routes\n})\n// 在此文件中引入工具函数，setTitle\nimport { setTitle } from '@/lib/tools'\n\nrouter.beforeEach((to, from, next) => {\n  to.meta && setTitle(to.meta.title) // 这里必须判断meta存在吗，如果meta存在，但是title不存在，访问to.meta.title也不会出错，会报title is undefined \n  //但是meta不存在，访问to.meta.title就会出错，因为title是to.meta.title中的第三级，一般情况下，如果没有二级，但是去访问二级，不会报undefined，\n  //但是连二级都没有，再去访问第三级，就是出错\n  next();\n})\nexport default router\n```\n文件`router/router.js`\n```javascript\nexport default [\n  {\n    path: '/home',\n    name: 'home',\n    component: () => import('@/views/home')\n  }\n]\n```\n#### 组件的过渡动效\n如果值给一个组件设置过渡，则只需要用<transition></transtion>包住\n```javascript\n<transition name=\"router\">\n  <router-view/>\n</transtion>\n```\n如果给多个路由逐渐设置过渡，需要使用<transition-group></transition-group>保住多个<router-view/>, 并且为每一个<router-view/>设置一个key值\n```javascript\n<transition-group  name=\"router\">\n  <router-view key=\"default\" name=\"default\"/>\n  <router-view key=\"email\" name=\"email\"/>\n  <router-view key=\"tel\" name=\"tel\"/>\n</transtion-group>\n```\n```css\n.router-enter { // 从无到进入时\n  opacity: 0;\n}\n.router-enter-active { 进入到完全显示，一般transition属性设置在这个阶段\n  transition: opacity 1s ease;\n}\n.router-enter-to { 完全显示时\n  opacity: 1;\n}\n.router-leave { // 从完全显示到开始离开时\n  opacity: 1;\n}\n.router-leave-active { // 从开始离开到消失\n  transition: opacity 1s ease;\n}\n.router-leave-to { // 完全消失\n  opacity: 0;\n}\n```\n\n#### keep-alive","slug":"vue技术栈梳理-路由篇","published":1,"updated":"2020-01-20T07:45:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gja0054lktv3xous43n"},{"title":"vue本地代理配置","date":"2019-05-16T06:00:00.000Z","_content":"\n## 原来在网上找了好多设置的方法，比如：\n由于没有真正理解里面的原理，所以在用的时候，这种所谓路由重写的方式带来了一些麻烦，如请求的地址无效等，让我误以为proxyTable没有设置成功。\n<!-- more -->\n\n+ 说明： \n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n        pathRewrite: { \n          '^/api': '/' // 或 '^/api': ''\n        }\n      }\n    },\n```\n前端请求路由为： `/api/api/test`\n后台实际的路由为： `/api/test`\n上段代码打包之后的执行过程是这样的(实际上对`/api/api/test`使用了两次)：\n1. 第一次，发起请求 `/api/api/test`，系统识别到`/api/api/test`中的第一个`/api`，就认为在请求`http://127.0.0.1:4000`下面的路由；\n2. 第二次，在对`/api/api/test`路由进行重写，找到了第一个`/api`并且把他换成`/`，最终完整的请求路由为：`http://127.0.0.1:4000//api/test`，事实上，这里的`//api`和`/api`是一样的，并不会报错。\n注意： 在浏览器中看到的请求url是：`http:127.0.0.1:8080/api/api/test`\n\n+ 配置1：\n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n        pathRewrite: { \n          '^/api': ''\n        }\n      }\n    },\n```\n如果这样配置，那么在请求路径那里需要将原来的 /api/test 需要改成 /api/api/test\n\n+ 配置2：\n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n        pathRewrite: { \n          '^/api': '/'\n        }\n      }\n    },\n```\n如果这样配置，那么在请求路径那里需要将原来的 /api/test 需要改成 /api/api/test\n\n+ 配置3：\n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n      }\n    },\n```\n如果这样配置，那么在请求路径那里需要将原来的 /api/test 不需要修改\n\n+ 配置4：\n```javascript\nproxyTable: {\n      '/': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        changeOrigin: true,\n      }\n    },\n```\n使用：\n假如接口是 `http://127.0.0.1:4000/api/list`,那么访问的地址是`/api/list`\n假如接口是 `http://127.0.0.1:4000/users/register`, 那么访问的地址是`/users/register`","source":"_posts/vue本地代理配置.md","raw":"---\ntitle: vue本地代理配置\ncategories: \n  - vue\n  - webpack\ntags: \n  - vue\n  - webpack\ndate: 2019-05-16 14:00:00\n---\n\n## 原来在网上找了好多设置的方法，比如：\n由于没有真正理解里面的原理，所以在用的时候，这种所谓路由重写的方式带来了一些麻烦，如请求的地址无效等，让我误以为proxyTable没有设置成功。\n<!-- more -->\n\n+ 说明： \n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n        pathRewrite: { \n          '^/api': '/' // 或 '^/api': ''\n        }\n      }\n    },\n```\n前端请求路由为： `/api/api/test`\n后台实际的路由为： `/api/test`\n上段代码打包之后的执行过程是这样的(实际上对`/api/api/test`使用了两次)：\n1. 第一次，发起请求 `/api/api/test`，系统识别到`/api/api/test`中的第一个`/api`，就认为在请求`http://127.0.0.1:4000`下面的路由；\n2. 第二次，在对`/api/api/test`路由进行重写，找到了第一个`/api`并且把他换成`/`，最终完整的请求路由为：`http://127.0.0.1:4000//api/test`，事实上，这里的`//api`和`/api`是一样的，并不会报错。\n注意： 在浏览器中看到的请求url是：`http:127.0.0.1:8080/api/api/test`\n\n+ 配置1：\n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n        pathRewrite: { \n          '^/api': ''\n        }\n      }\n    },\n```\n如果这样配置，那么在请求路径那里需要将原来的 /api/test 需要改成 /api/api/test\n\n+ 配置2：\n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n        pathRewrite: { \n          '^/api': '/'\n        }\n      }\n    },\n```\n如果这样配置，那么在请求路径那里需要将原来的 /api/test 需要改成 /api/api/test\n\n+ 配置3：\n```javascript\nproxyTable: {\n      '/api': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        // secure: false,  // 如果是https接口，需要配置这个参数\n        changeOrigin: true, // 如果接口跨域，需要进行这个参数配置\n      }\n    },\n```\n如果这样配置，那么在请求路径那里需要将原来的 /api/test 不需要修改\n\n+ 配置4：\n```javascript\nproxyTable: {\n      '/': {\n        target: 'http://127.0.0.1:4000', // 要访问接口的域名\n        changeOrigin: true,\n      }\n    },\n```\n使用：\n假如接口是 `http://127.0.0.1:4000/api/list`,那么访问的地址是`/api/list`\n假如接口是 `http://127.0.0.1:4000/users/register`, 那么访问的地址是`/users/register`","slug":"vue本地代理配置","published":1,"updated":"2020-01-20T07:45:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjb0055lktvnryh3zwu"},{"title":"事件捕获和冒泡原理及其应用","_content":"### 任何一个元素的一个事件的执行顺序都是从body开始，一路向分直寻找，一直找到触发事件的元素，并且执行该路径上的所有该类事件，次过程叫做事件捕获。等到事件源元素执行相应的事件之后，再反过来一路向上查找，再执行这条路径上所有的该类事件。\n<!-- more -->\n{% asset_img propagation.png 事件捕获与事件冒泡 %}\n### onclick事件是在冒泡阶段执行的\n\n### 通过设置addEventListener的第三个属性来规定当前事件是捕获阶段执行还是冒泡阶段执行\n```html\n<!DOCTYPE html>\n<head>\n  <html lang=\"en\">\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <div id=\"div\">\n      <ul id=\"ul\">\n          <li>1</li>\n          <li>2</li>\n          <li>3</li>\n          <li>4</li>\n          <li>5</li>\n          <li>6</li>\n          <li>7</li>\n          <li>8</li>\n          <li>9</li>\n          <li>10</li>\n        </ul>\n  </div>\n  \n  <script>\n    let ul = document.getElementById('ul');\n    ul.addEventListener('click', function (e) {\n      if (e.target.nodeName == 'LI') { // 这里给ul设置了关于li的事件委托\n        console.log(e.target.innerText);\n      }\n    }, true)\n    document.getElementById('div').addEventListener('click', function (e) {\n      console.log('div在捕获阶段的click事件');\n    }, true); // addEventListener可以重复绑定，并且可以指定在捕获和冒泡阶段不同的回调函数\n    document.getElementById('div').addEventListener('click', function (e) {\n      console.log('div在冒泡阶段的click事件');\n    }, false);\n    let body = document.body;\n    body.addEventListener('click', function (e) {\n      console.log('body 在捕获阶段的click事件');\n    }, true)\n\n\n    // 点击任意一个li，执行的结果为\n    /**\n     * body 在捕获阶段的click事件\n     * div在捕获阶段的click事件\n     * 1\n     * div在冒泡阶段的click事件\n     **/\n  </script>\n</body>\n</html>\n```\n### e.stopPropagation()阻止事件冒泡和捕获\ne.stopPropagation()在整个事件执行的回路中的每一个节点都可以执行。执行的结果就是，事件不再继续向后传递。\n+ 比如刚刚从body的click事件捕获阶段，就停止传播，那么后来的所有click事件都不再执行。当然这是一个无聊的作死操作。\n```javascript\nbody.addEventListener('click', function (e) {\n  e.stopPropagation();\n  console.log('body 在捕获阶段的click事件');\n}, true)\n```\n+ 真正的用处在于阻止事件冒泡\n执行子元素的click，不想冒泡执行父元素的click\n那么在ul的click事件回调函数中，写入e.stopPropagation(),他就不会冒泡执行div甚至body的click事件了。\n```javascript\nul.addEventListener('click', function (e) {\n  e.stopPropagation();\n  if (e.target.nodeName == 'LI') { // 这里给ul设置了关于li的事件委托\n    console.log(e.target.innerText);\n  }\n}, true)\n```","source":"_posts/事件捕获和冒泡原理及其应用.md","raw":"---\ntitle: 事件捕获和冒泡原理及其应用\ncategories: \n  - js\n  - 事件\ntags:\n  - js\n  - 事件\n---\n### 任何一个元素的一个事件的执行顺序都是从body开始，一路向分直寻找，一直找到触发事件的元素，并且执行该路径上的所有该类事件，次过程叫做事件捕获。等到事件源元素执行相应的事件之后，再反过来一路向上查找，再执行这条路径上所有的该类事件。\n<!-- more -->\n{% asset_img propagation.png 事件捕获与事件冒泡 %}\n### onclick事件是在冒泡阶段执行的\n\n### 通过设置addEventListener的第三个属性来规定当前事件是捕获阶段执行还是冒泡阶段执行\n```html\n<!DOCTYPE html>\n<head>\n  <html lang=\"en\">\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <div id=\"div\">\n      <ul id=\"ul\">\n          <li>1</li>\n          <li>2</li>\n          <li>3</li>\n          <li>4</li>\n          <li>5</li>\n          <li>6</li>\n          <li>7</li>\n          <li>8</li>\n          <li>9</li>\n          <li>10</li>\n        </ul>\n  </div>\n  \n  <script>\n    let ul = document.getElementById('ul');\n    ul.addEventListener('click', function (e) {\n      if (e.target.nodeName == 'LI') { // 这里给ul设置了关于li的事件委托\n        console.log(e.target.innerText);\n      }\n    }, true)\n    document.getElementById('div').addEventListener('click', function (e) {\n      console.log('div在捕获阶段的click事件');\n    }, true); // addEventListener可以重复绑定，并且可以指定在捕获和冒泡阶段不同的回调函数\n    document.getElementById('div').addEventListener('click', function (e) {\n      console.log('div在冒泡阶段的click事件');\n    }, false);\n    let body = document.body;\n    body.addEventListener('click', function (e) {\n      console.log('body 在捕获阶段的click事件');\n    }, true)\n\n\n    // 点击任意一个li，执行的结果为\n    /**\n     * body 在捕获阶段的click事件\n     * div在捕获阶段的click事件\n     * 1\n     * div在冒泡阶段的click事件\n     **/\n  </script>\n</body>\n</html>\n```\n### e.stopPropagation()阻止事件冒泡和捕获\ne.stopPropagation()在整个事件执行的回路中的每一个节点都可以执行。执行的结果就是，事件不再继续向后传递。\n+ 比如刚刚从body的click事件捕获阶段，就停止传播，那么后来的所有click事件都不再执行。当然这是一个无聊的作死操作。\n```javascript\nbody.addEventListener('click', function (e) {\n  e.stopPropagation();\n  console.log('body 在捕获阶段的click事件');\n}, true)\n```\n+ 真正的用处在于阻止事件冒泡\n执行子元素的click，不想冒泡执行父元素的click\n那么在ul的click事件回调函数中，写入e.stopPropagation(),他就不会冒泡执行div甚至body的click事件了。\n```javascript\nul.addEventListener('click', function (e) {\n  e.stopPropagation();\n  if (e.target.nodeName == 'LI') { // 这里给ul设置了关于li的事件委托\n    console.log(e.target.innerText);\n  }\n}, true)\n```","slug":"事件捕获和冒泡原理及其应用","published":1,"date":"2020-01-20T07:45:16.000Z","updated":"2020-01-20T07:45:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjc0059lktv6ghypk2b"},{"title":"字符串方法","date":"2019-07-08T02:49:30.000Z","_content":"# 常用字符串方法\n+ str.split(\",\") 将字符串装入数组\n+ str.slice(start, end); 截取字符串，一个参数时，会截取该位置参数之后的所以字符\n+ str.substring(start, end); 截取字符串，一个参数时，只会截取该位置参数的所在字符\n+ str.indexOf(\"&\") 返回第一个“&”字符的位置\n+ str.lastIndexOf(\"&\") 返回最后一个“&”字符的位置\n+ replace(/&$/g, \"\") 将最后一个“&”字符替换成空\n<!-- more -->\n### str.indexOf(\"&\")与str.lastIndexOf(\"&\")\nstr.indexOf(\"&\")找到字符串中第一个指定字符的位置，并且返回\nstr.lastIndexOf(\"&\")找到字符串中第一个指定字符的位置，并且返回\n```javascript\n{\n  let str = \"/product?id=1&name=ball&\";\n  console.log(str.length); // 24\n  console.log(str.indexOf(\"&\")); // 13 \n  console.log(str.lastIndexOf(\"&\")); // 23 找到最后一个\"&\"的位置在字符串的末尾\n} \n```\n### str.lastIndexOf(\"&\")和subtring()的组合使用\n```javascript\n{\n  // 将data中的数据改写为query组合条件查询字符串\n  const data = {\n    id: 123,\n    name: 'masia'\n  }\n  let url = \"http://127.0.0.1:8080/product\";\n  let keysArr = Object.keys(data);\n  console.log(keysArr);\n  if (!keysArr.length) {\n    return url;\n  }\n  url += \"?\";\n  console.log(url)\n  keysArr.forEach(item => {\n    url += item+'='+data[item]+'&';\n  });\n  // 方法1： 使用replace()实现字符替换，该方法不会改变原来的字符串\n  console.log(url.replace(/&$/g, \"\")); // http://127.0.0.1:8080/product?id=123&name=masia \n  console.log(url); // http://127.0.0.1:8080/product?id=123&name=masia&\n  // 方法2： 使用substring()方法截取最后一个“&”之前的字符串，该方法不会改变原来的字符串\n  console.log(url.substring(0, url.lastIndexOf(\"&\"))); // http://127.0.0.1:8080/product?id=123&name=masia \n  console.log(url); // http://127.0.0.1:8080/product?id=123&name=masia&\n}\n```","source":"_posts/字符串的常用方法.md","raw":"---\ntitle: 字符串方法\ndate: 2019-07-08 10:49:30\ncategories:\n  - js\n  - 数组和字符串\n  - 字符串\ntags:\n  - js\n  - 数组和字符串\n  - 字符串\n---\n# 常用字符串方法\n+ str.split(\",\") 将字符串装入数组\n+ str.slice(start, end); 截取字符串，一个参数时，会截取该位置参数之后的所以字符\n+ str.substring(start, end); 截取字符串，一个参数时，只会截取该位置参数的所在字符\n+ str.indexOf(\"&\") 返回第一个“&”字符的位置\n+ str.lastIndexOf(\"&\") 返回最后一个“&”字符的位置\n+ replace(/&$/g, \"\") 将最后一个“&”字符替换成空\n<!-- more -->\n### str.indexOf(\"&\")与str.lastIndexOf(\"&\")\nstr.indexOf(\"&\")找到字符串中第一个指定字符的位置，并且返回\nstr.lastIndexOf(\"&\")找到字符串中第一个指定字符的位置，并且返回\n```javascript\n{\n  let str = \"/product?id=1&name=ball&\";\n  console.log(str.length); // 24\n  console.log(str.indexOf(\"&\")); // 13 \n  console.log(str.lastIndexOf(\"&\")); // 23 找到最后一个\"&\"的位置在字符串的末尾\n} \n```\n### str.lastIndexOf(\"&\")和subtring()的组合使用\n```javascript\n{\n  // 将data中的数据改写为query组合条件查询字符串\n  const data = {\n    id: 123,\n    name: 'masia'\n  }\n  let url = \"http://127.0.0.1:8080/product\";\n  let keysArr = Object.keys(data);\n  console.log(keysArr);\n  if (!keysArr.length) {\n    return url;\n  }\n  url += \"?\";\n  console.log(url)\n  keysArr.forEach(item => {\n    url += item+'='+data[item]+'&';\n  });\n  // 方法1： 使用replace()实现字符替换，该方法不会改变原来的字符串\n  console.log(url.replace(/&$/g, \"\")); // http://127.0.0.1:8080/product?id=123&name=masia \n  console.log(url); // http://127.0.0.1:8080/product?id=123&name=masia&\n  // 方法2： 使用substring()方法截取最后一个“&”之前的字符串，该方法不会改变原来的字符串\n  console.log(url.substring(0, url.lastIndexOf(\"&\"))); // http://127.0.0.1:8080/product?id=123&name=masia \n  console.log(url); // http://127.0.0.1:8080/product?id=123&name=masia&\n}\n```","slug":"字符串的常用方法","published":1,"updated":"2020-01-20T07:45:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjd005blktv6nu1m35c"},{"title":"数组和对象的深度复制（浅显的不严谨理解）","date":"2019-07-01T06:00:00.000Z","_content":"\n# 数组和对象\n在面向过程中，我们对数组和对象的操作实际上是对计算机堆内存那块存储区域的操作，即我们创建的变量里面保存的也只是那块堆内存的一个引用值，也就是堆内存空间的地址值，我们对对象操作时，首先根据地址值找到那块内存空间，然后再进行操作。同时，也意味着我们不管给多个变量使用\"=\"赋值时，实际是在赋予它一个地址值。这样就实现了多个变量中保存了同一个内存空间地址的内容 。深度复制的意思就是在堆内存中再开辟一块空间，然后把目标内存空间中的东西完全照搬一份放在这个新的空间中。\n<!-- more -->\n\n### 深度复制对象\n+ 深度复制对象思路：\n首先，对对象的复制我们需要在内存中再开辟一块新的空间，往这个对象中填充内容，最后把这个对象的地址使用变量记录下来。\n其次，先不考虑对象的特殊情况：\n我已经知道基本数据类型的存储是直接存在变量所在的栈内存中的，所以我们如果遇到基本数据类型就直接使用\"=\"来进行复制。那么可以写出：\n```javascript\n{\n  let oldObj = { // 假如存在一个这样的对象，里面保存的都是一些基本数据类型\n    a: 'maisa', // String类型\n    b: 666, // Number类型\n    c: true, // Boolean类型\n    d: undefined, // undefined类型\n    e: null // 使用typeof null 返回的是Object，但是实际上是把堆内存中一片空的空间的地址给了变量，所以值为null的变量都指向同一片内存空间。\n  };\n  function cloneObj (oldObj) {\n    const newObj = {}; // 首先创建一个对象\n    for (let i in oldObj) { // 遍历对象\n      newObj[i] = oldObj[i] // 把老对象的基本类型的属性的值赋给新对象的属性\n    }\n    return newObj; // 最后把填充好的对象返回\n  };\n  const newObj = cloneObj(oldObj); // 使用一个新的变量去保存新对象的地址\n  console.log('oldObj', oldObj) // oldObj {a: \"maisa\", b: 666, c: true}\n  console.log('newObj', newObj) // newObj {a: \"maisa\", b: 666, c: true}\n  console.log(newObj == oldObj) // false\n}\n```\n下面，我们讨论一个对象的属性是特殊类型的情况，即引用类型的情况，但是我们知道引用类型实际上都是对象，但是从数据结构上分又变成了三种：即数组、普通对象、函数。所以我们必须要把这三种情况分别处理。\n1. 如果属性类型是普通对象，那么按照分治的思想，那么问题又将归结到深度复制对象，即递归的调用cloneObj()\n2. 如果属性类型是数组，那么我们需要符合数组的结构做复制，但其实每一个数组项的类型又是不确定的，即又有可能是基本类型、普通对象、数组以及函数。所以在对每一个数组项又要做相应的判断和合适的递归操作。\n3. 如果属性类型是函数，那么直接开辟一块新的堆内存空间去保存它\n\n其实，我们只需要知道对象的构造函数，然后使用构造函数去创建对象，并且我们可以使用for in 来统一数组和普通对象的操作。\n```javascript\n{\n  function Masia () { // 定义个构造函数，用于创建该类型的对象\n    this.constructorName = 'Masia';\n  }\n\n  const oldObj = {\n    a: 'masia', // String类型\n    b: 666, // Number类型\n    c: undefined, // undefined类型\n    d: null, // null类型\n    e: new Masia(), // Masia对象类型\n    f: {}, // Object对象类型\n    g: [\n      'masia', // 数组中的基本类型\n      new Masia(), // Masia 对象类型\n      [] // 数组中的数组类型\n    ] // 数组类型\n  }\n\n  function deepClone (oldObj) {\n    if (oldObj == null) return oldObj; // 如果oldObj是null，那么返回null\n    const newObj = new oldObj.constructor(); // 使用oldObj的构造函数创建一个对象,如果传入的oldObj是Array类型的，那么就创建Array类型的对象，如果是Masia类型的，那就创建Masia类型的对象\n    for (i in oldObj) { // 使用for in 统一了普通对象和数组的操作\n      newObj[i] = typeof oldObj[i] == 'object' ? deepClone(oldObj[i]) : oldObj[i]\n    }\n    return newObj;\n  }\n  const newObj = deepClone(oldObj)\n  console.log('oldObj', oldObj) // oldObj {a: \"masia\", b: 666, c: undefined, d: null, e: Masia, …}\n  console.log('newObj', newObj) // newObj {a: \"masia\", b: 666, c: undefined, d: null, e: Masia, …}\n  console.log(oldObj == newObj) // false\n  console.log(oldObj.e == newObj.e) //false\n  console.log(oldObj.f == newObj.f) // false\n  console.log(oldObj.g == newObj.g) // false\n  console.log(oldObj.g[1] == newObj.g[1]) // false\n}\n```\n打印输出了oldObj对象和newObj中的子对象、子数组的的引用值都不相同，证明实现了对象的深度复制。事实上也实现了数组的深度复制，因为函数体内创建的新对象是基于构造函数创建的，而且使用for in又统一了普通对象与数组的操作，所以说上面的深度复制统对普通对象以及数组都适用。\n但是，仍然存在弊端，当属性值为函数时，虽然在迭代的过程中先创建了一个Function类型的对象，但是由于typeof对函数操作返回的结果是'function'，所以程序还是将原来对象的属性值直接赋给新对象的属性，新老对象的这个属性指向了统一片堆空间。所以，对属性值为函数的属性并没有实现复制。\n\n\n### 深度复制数组（要注意的是，输入和输出都是数组，这绝对是固定的）\n+ 深度复制数组思路：\n深度复制数组的思路其实和深度复制对象的思路其实是一样的\n首先，创建一个新的对象\n然后，遍历每一个索引位置，如果索引位置的值是基本类型，则直接复制，如果是拿三种引用类型，则做相应的递归\n最后，使用一个变量去接受这个新数组内存空间的地址\n\n+ 问题也归结到简单问题和复杂问题\n1. 那么简单问题就是对基本数据类型位置的处理： \n```javascript\n{\n  const oldArr = ['masia', 6, true, undefined, null] \n                // 这个数组包含了物种基本类型\n  function cloneArr (oldArr) {\n    const newArr = [];\n    for (i in oldArr) { // 当然这里对数组的遍历也可以使用forEach等等...\n      newArr[i] = oldArr[i]\n    }\n    return newArr;\n  }\n  const newArr = cloneArr(oldArr) \n  console.log('oldArr', oldArr) // oldArr (5) [\"masia\", 6, true, undefined, null]\n  console.log('newArr', newArr) // newArr (5) [\"masia\", 6, true, undefined, null]\n  console.log(oldArr == newArr) // false\n}\n```\n2. 复杂问题的处理同深度复制对象复杂问题的处理\n\n\n### 网上处理方法的见解\n我看到网上有很多博客写的是使用`JSON.parse(JOSN.stringify(oldObj))`这种方式处理的,但经过测试,我发现其实还是不严谨的.\n比如:\n```javascript\n{\n  function Masia () { // 定义个构造函数，用于创建该类型的对象\n    \n  }\n  Object.assign(Masia.prototype, {\n    sayHi () {\n      console.log('Hello World!')\n    }\n  })\n  const oldObj = {\n    a: 'masia',\n    b: {\n      bb: 'masia'\n    },\n    c: new Masia(),\n    d: []\n  }\n  const newObj = JSON.parse(JSON.stringify(oldObj));\n  console.log('oldObj', oldObj) // {a: \"masia\", b: {…}, c: Masia, d: Array(0)}\n  console.log('newObj', newObj) // {a: \"masia\", b: {…}, c: {…}, d: Array(0)}\n  console.log(oldObj == newObj) // false\n  console.log(oldObj.b == newObj.b) // false\n  console.log(oldObj.c == newObj.c) // false\n  console.log(oldObj.c.sayHi()) // Hello World!\n  console.log(newObj.c.sayHi()) // 报错: newObj.c.sayHi is not a function\n}\n```\n表面上,好像也实现了对象的深度复制,但是JSON.parse在将字符串转化为对象时,始终都是以Object来作为构造函数进行对象的创建的,打印oldObj.c.constructor和newObj.c.constructor就可以看出,前者是Masia,而后者是Object,那么也就说明oldObj.c可以使用Masia的prototype上面的方法,而newObj.c则不可以,如果使用,则直接报错.而且这种方式,也不能实现函数的复制,如果原对象中有函数属性,则该方法执行会直接略过.\n\n### 也有创建的基本类型的数据不是字面量情况\n```javascript\n// 比如：\nlet str = 'masia';\nlet str2 = new String('masia');\n```","source":"_posts/对象和数组的深度复制.md","raw":"---\ntitle: 数组和对象的深度复制（浅显的不严谨理解）\ncategories:\n  - 数组和对象的深度复制\ntags:\n  - 数组和对象的深度复制\ndate: 2019-07-01 14:00:00\n---\n\n# 数组和对象\n在面向过程中，我们对数组和对象的操作实际上是对计算机堆内存那块存储区域的操作，即我们创建的变量里面保存的也只是那块堆内存的一个引用值，也就是堆内存空间的地址值，我们对对象操作时，首先根据地址值找到那块内存空间，然后再进行操作。同时，也意味着我们不管给多个变量使用\"=\"赋值时，实际是在赋予它一个地址值。这样就实现了多个变量中保存了同一个内存空间地址的内容 。深度复制的意思就是在堆内存中再开辟一块空间，然后把目标内存空间中的东西完全照搬一份放在这个新的空间中。\n<!-- more -->\n\n### 深度复制对象\n+ 深度复制对象思路：\n首先，对对象的复制我们需要在内存中再开辟一块新的空间，往这个对象中填充内容，最后把这个对象的地址使用变量记录下来。\n其次，先不考虑对象的特殊情况：\n我已经知道基本数据类型的存储是直接存在变量所在的栈内存中的，所以我们如果遇到基本数据类型就直接使用\"=\"来进行复制。那么可以写出：\n```javascript\n{\n  let oldObj = { // 假如存在一个这样的对象，里面保存的都是一些基本数据类型\n    a: 'maisa', // String类型\n    b: 666, // Number类型\n    c: true, // Boolean类型\n    d: undefined, // undefined类型\n    e: null // 使用typeof null 返回的是Object，但是实际上是把堆内存中一片空的空间的地址给了变量，所以值为null的变量都指向同一片内存空间。\n  };\n  function cloneObj (oldObj) {\n    const newObj = {}; // 首先创建一个对象\n    for (let i in oldObj) { // 遍历对象\n      newObj[i] = oldObj[i] // 把老对象的基本类型的属性的值赋给新对象的属性\n    }\n    return newObj; // 最后把填充好的对象返回\n  };\n  const newObj = cloneObj(oldObj); // 使用一个新的变量去保存新对象的地址\n  console.log('oldObj', oldObj) // oldObj {a: \"maisa\", b: 666, c: true}\n  console.log('newObj', newObj) // newObj {a: \"maisa\", b: 666, c: true}\n  console.log(newObj == oldObj) // false\n}\n```\n下面，我们讨论一个对象的属性是特殊类型的情况，即引用类型的情况，但是我们知道引用类型实际上都是对象，但是从数据结构上分又变成了三种：即数组、普通对象、函数。所以我们必须要把这三种情况分别处理。\n1. 如果属性类型是普通对象，那么按照分治的思想，那么问题又将归结到深度复制对象，即递归的调用cloneObj()\n2. 如果属性类型是数组，那么我们需要符合数组的结构做复制，但其实每一个数组项的类型又是不确定的，即又有可能是基本类型、普通对象、数组以及函数。所以在对每一个数组项又要做相应的判断和合适的递归操作。\n3. 如果属性类型是函数，那么直接开辟一块新的堆内存空间去保存它\n\n其实，我们只需要知道对象的构造函数，然后使用构造函数去创建对象，并且我们可以使用for in 来统一数组和普通对象的操作。\n```javascript\n{\n  function Masia () { // 定义个构造函数，用于创建该类型的对象\n    this.constructorName = 'Masia';\n  }\n\n  const oldObj = {\n    a: 'masia', // String类型\n    b: 666, // Number类型\n    c: undefined, // undefined类型\n    d: null, // null类型\n    e: new Masia(), // Masia对象类型\n    f: {}, // Object对象类型\n    g: [\n      'masia', // 数组中的基本类型\n      new Masia(), // Masia 对象类型\n      [] // 数组中的数组类型\n    ] // 数组类型\n  }\n\n  function deepClone (oldObj) {\n    if (oldObj == null) return oldObj; // 如果oldObj是null，那么返回null\n    const newObj = new oldObj.constructor(); // 使用oldObj的构造函数创建一个对象,如果传入的oldObj是Array类型的，那么就创建Array类型的对象，如果是Masia类型的，那就创建Masia类型的对象\n    for (i in oldObj) { // 使用for in 统一了普通对象和数组的操作\n      newObj[i] = typeof oldObj[i] == 'object' ? deepClone(oldObj[i]) : oldObj[i]\n    }\n    return newObj;\n  }\n  const newObj = deepClone(oldObj)\n  console.log('oldObj', oldObj) // oldObj {a: \"masia\", b: 666, c: undefined, d: null, e: Masia, …}\n  console.log('newObj', newObj) // newObj {a: \"masia\", b: 666, c: undefined, d: null, e: Masia, …}\n  console.log(oldObj == newObj) // false\n  console.log(oldObj.e == newObj.e) //false\n  console.log(oldObj.f == newObj.f) // false\n  console.log(oldObj.g == newObj.g) // false\n  console.log(oldObj.g[1] == newObj.g[1]) // false\n}\n```\n打印输出了oldObj对象和newObj中的子对象、子数组的的引用值都不相同，证明实现了对象的深度复制。事实上也实现了数组的深度复制，因为函数体内创建的新对象是基于构造函数创建的，而且使用for in又统一了普通对象与数组的操作，所以说上面的深度复制统对普通对象以及数组都适用。\n但是，仍然存在弊端，当属性值为函数时，虽然在迭代的过程中先创建了一个Function类型的对象，但是由于typeof对函数操作返回的结果是'function'，所以程序还是将原来对象的属性值直接赋给新对象的属性，新老对象的这个属性指向了统一片堆空间。所以，对属性值为函数的属性并没有实现复制。\n\n\n### 深度复制数组（要注意的是，输入和输出都是数组，这绝对是固定的）\n+ 深度复制数组思路：\n深度复制数组的思路其实和深度复制对象的思路其实是一样的\n首先，创建一个新的对象\n然后，遍历每一个索引位置，如果索引位置的值是基本类型，则直接复制，如果是拿三种引用类型，则做相应的递归\n最后，使用一个变量去接受这个新数组内存空间的地址\n\n+ 问题也归结到简单问题和复杂问题\n1. 那么简单问题就是对基本数据类型位置的处理： \n```javascript\n{\n  const oldArr = ['masia', 6, true, undefined, null] \n                // 这个数组包含了物种基本类型\n  function cloneArr (oldArr) {\n    const newArr = [];\n    for (i in oldArr) { // 当然这里对数组的遍历也可以使用forEach等等...\n      newArr[i] = oldArr[i]\n    }\n    return newArr;\n  }\n  const newArr = cloneArr(oldArr) \n  console.log('oldArr', oldArr) // oldArr (5) [\"masia\", 6, true, undefined, null]\n  console.log('newArr', newArr) // newArr (5) [\"masia\", 6, true, undefined, null]\n  console.log(oldArr == newArr) // false\n}\n```\n2. 复杂问题的处理同深度复制对象复杂问题的处理\n\n\n### 网上处理方法的见解\n我看到网上有很多博客写的是使用`JSON.parse(JOSN.stringify(oldObj))`这种方式处理的,但经过测试,我发现其实还是不严谨的.\n比如:\n```javascript\n{\n  function Masia () { // 定义个构造函数，用于创建该类型的对象\n    \n  }\n  Object.assign(Masia.prototype, {\n    sayHi () {\n      console.log('Hello World!')\n    }\n  })\n  const oldObj = {\n    a: 'masia',\n    b: {\n      bb: 'masia'\n    },\n    c: new Masia(),\n    d: []\n  }\n  const newObj = JSON.parse(JSON.stringify(oldObj));\n  console.log('oldObj', oldObj) // {a: \"masia\", b: {…}, c: Masia, d: Array(0)}\n  console.log('newObj', newObj) // {a: \"masia\", b: {…}, c: {…}, d: Array(0)}\n  console.log(oldObj == newObj) // false\n  console.log(oldObj.b == newObj.b) // false\n  console.log(oldObj.c == newObj.c) // false\n  console.log(oldObj.c.sayHi()) // Hello World!\n  console.log(newObj.c.sayHi()) // 报错: newObj.c.sayHi is not a function\n}\n```\n表面上,好像也实现了对象的深度复制,但是JSON.parse在将字符串转化为对象时,始终都是以Object来作为构造函数进行对象的创建的,打印oldObj.c.constructor和newObj.c.constructor就可以看出,前者是Masia,而后者是Object,那么也就说明oldObj.c可以使用Masia的prototype上面的方法,而newObj.c则不可以,如果使用,则直接报错.而且这种方式,也不能实现函数的复制,如果原对象中有函数属性,则该方法执行会直接略过.\n\n### 也有创建的基本类型的数据不是字面量情况\n```javascript\n// 比如：\nlet str = 'masia';\nlet str2 = new String('masia');\n```","slug":"对象和数组的深度复制","published":1,"updated":"2020-01-20T07:45:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gje005elktv5p6gh01i"},{"title":"数组和字符串易混淆方法集合","date":"2019-07-08T02:49:33.000Z","_content":"\n# 数组和字符串易混淆方法集合\n可使用者 | split | splice | slice\n-|-|-|-\n数组对象 | 否 | 是 | 是\n字符串对象 | 是 | 否 | 是\n<!-- more -->\n### split\n该方法表示将字符串按照指定的字符分开，并且装进一个数组，该方法与Array.join()相对\n```javascript\n{\n  let str = 'hello world';\n  console.log(str.split(\" \")); // [ 'hello', 'world' ]\n  console.log(str); // hello world\n} \n```\n### slice()方法使用(arr、str)\n1. 只有一个参数时，则表示从何位置开始选取，一直选取到结尾\n2. 两个参数时，指定选取的开始位置和结束位置(在一般的编程语言中，这种获取指定开始位置和结束位置元素的方法，获取的元素都是包含开始位置的值，不包含结束位置的值)\n3. 参数可以是负数（-1就是从倒数第个位置开始）\n```javascript\n{\n  // 字符串对象使用slice()方法\n  let str = \"masia\";\n  console.log(str.slice(1, 3)); // as\n  console.log(str.slice(-2, -1)); // i\n  console.log(str.slice(1)); // asia \n  console.log(str.slice(-2)); //ia \n  console.log(str); // masia slice不会改变原来的字符串\n  // 这里可以对比str.substring()方法\n  console.log(str.substring(1)); // asia\n  console.log(str.substring(1, 3)); // as\n  console.log(str.substring(3, 1)); // as 如果start参数比end参数大，则会先交换参数\n\n  // 数组对象使用slice方法\n  let arr = [1, 2, 3, 4];\n  console.log(arr.slice(1, 3)); // [ 2, 3 ]\n  console.log(arr.slice(-2, -1)); // [ 3 ]\n  console.log(arr.slice(2)); // [ 3, 4 ] 只有一个参数时，则表示从何位置开始选取，一直选取到结尾\n  console.log(arr.slice(-2)); //[ 4 ] 从倒数第二个位置开始选取，一直选取到结尾\n  console.log(arr); // [ 1, 2, 3, 4 ] slice方法不会改变原数组\n}\nconsole.log('====')\n```\n### splice()方法使用(arr)\n```javascript\n{\n  let str = 'masia';\n  // console.log(str.splice(1, 2)); 字符串没有splice()方法\n  // console.log(str);\n  let arr = [1, 2, 3, 4];\n\n  // 1. splice()不传参数，表示对原数组什么也不做，并且方法调用返回一个空数组\n  console.log(arr.splice()); // []\n  console.log(arr); // [ 1, 2, 3, 4 ]\n  // 2. splice()一个参数，表示从何位置开始删除，并且删除该位置之后的所有元素\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(1)); // [ 2, 3, 4 ]\n  console.log(arr); // [ 1 ]\n  // 3. splice()两个参数，第一个参数表示从哪个位置开始，第二个参数表示删除指定位置之后几个元素\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(1, 2)); // [ 2, 3 ]\n  console.log(arr); // [ 1, 4 ] splice会改变原来的数组\n  // 4. splice()一个参数且为负数，表示从倒数第几个位置开始删除\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(-1)); // [ 4 ]\n  console.log(arr); // [ 1, 2, 3 ] splice会改变原来的数组\n  // 5. splice()两个参数且为负数，第一个参数表示从倒数第几个位置开始删除，第二个参数表示删除几个\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(-1, 2)); // [ 4 ]\n  console.log(arr); // [ 1, 2, 3 ] splice会改变原来的数组\n  // 6. splice()三个参数，第三个参数表述用指定元素替代删除的元素\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(-2, 2, '可以', '多个', '替代', '元素')); // [ 3, 4 ]\n  console.log(arr); // [ 1, 2, '可以', '多个', '替代', '元素' ] splice会改变原来的数组\n}\n```","source":"_posts/数组和字符串易混淆方法集合.md","raw":"---\ntitle: 数组和字符串易混淆方法集合\ndate: 2019-07-08 10:49:33\ncategories:\n  - js\n  - 数组和字符串\ntags:\n  - js\n  - 数组和字符串\n---\n\n# 数组和字符串易混淆方法集合\n可使用者 | split | splice | slice\n-|-|-|-\n数组对象 | 否 | 是 | 是\n字符串对象 | 是 | 否 | 是\n<!-- more -->\n### split\n该方法表示将字符串按照指定的字符分开，并且装进一个数组，该方法与Array.join()相对\n```javascript\n{\n  let str = 'hello world';\n  console.log(str.split(\" \")); // [ 'hello', 'world' ]\n  console.log(str); // hello world\n} \n```\n### slice()方法使用(arr、str)\n1. 只有一个参数时，则表示从何位置开始选取，一直选取到结尾\n2. 两个参数时，指定选取的开始位置和结束位置(在一般的编程语言中，这种获取指定开始位置和结束位置元素的方法，获取的元素都是包含开始位置的值，不包含结束位置的值)\n3. 参数可以是负数（-1就是从倒数第个位置开始）\n```javascript\n{\n  // 字符串对象使用slice()方法\n  let str = \"masia\";\n  console.log(str.slice(1, 3)); // as\n  console.log(str.slice(-2, -1)); // i\n  console.log(str.slice(1)); // asia \n  console.log(str.slice(-2)); //ia \n  console.log(str); // masia slice不会改变原来的字符串\n  // 这里可以对比str.substring()方法\n  console.log(str.substring(1)); // asia\n  console.log(str.substring(1, 3)); // as\n  console.log(str.substring(3, 1)); // as 如果start参数比end参数大，则会先交换参数\n\n  // 数组对象使用slice方法\n  let arr = [1, 2, 3, 4];\n  console.log(arr.slice(1, 3)); // [ 2, 3 ]\n  console.log(arr.slice(-2, -1)); // [ 3 ]\n  console.log(arr.slice(2)); // [ 3, 4 ] 只有一个参数时，则表示从何位置开始选取，一直选取到结尾\n  console.log(arr.slice(-2)); //[ 4 ] 从倒数第二个位置开始选取，一直选取到结尾\n  console.log(arr); // [ 1, 2, 3, 4 ] slice方法不会改变原数组\n}\nconsole.log('====')\n```\n### splice()方法使用(arr)\n```javascript\n{\n  let str = 'masia';\n  // console.log(str.splice(1, 2)); 字符串没有splice()方法\n  // console.log(str);\n  let arr = [1, 2, 3, 4];\n\n  // 1. splice()不传参数，表示对原数组什么也不做，并且方法调用返回一个空数组\n  console.log(arr.splice()); // []\n  console.log(arr); // [ 1, 2, 3, 4 ]\n  // 2. splice()一个参数，表示从何位置开始删除，并且删除该位置之后的所有元素\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(1)); // [ 2, 3, 4 ]\n  console.log(arr); // [ 1 ]\n  // 3. splice()两个参数，第一个参数表示从哪个位置开始，第二个参数表示删除指定位置之后几个元素\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(1, 2)); // [ 2, 3 ]\n  console.log(arr); // [ 1, 4 ] splice会改变原来的数组\n  // 4. splice()一个参数且为负数，表示从倒数第几个位置开始删除\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(-1)); // [ 4 ]\n  console.log(arr); // [ 1, 2, 3 ] splice会改变原来的数组\n  // 5. splice()两个参数且为负数，第一个参数表示从倒数第几个位置开始删除，第二个参数表示删除几个\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(-1, 2)); // [ 4 ]\n  console.log(arr); // [ 1, 2, 3 ] splice会改变原来的数组\n  // 6. splice()三个参数，第三个参数表述用指定元素替代删除的元素\n  arr = [1, 2, 3, 4];\n  console.log(arr.splice(-2, 2, '可以', '多个', '替代', '元素')); // [ 3, 4 ]\n  console.log(arr); // [ 1, 2, '可以', '多个', '替代', '元素' ] splice会改变原来的数组\n}\n```","slug":"数组和字符串易混淆方法集合","published":1,"updated":"2020-01-20T07:45:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjf005flktvy70v104w"},{"title":"正则表达式","abbrlink":"13f9823b","date":"2019-04-29T06:00:00.000Z","_content":"# 正则表达式\n+ 创建正则对象的三种方式:\n<!-- more -->\n  - `let reg = new RegExp('xyz', 'i')` 第一种写法： 第一个参数是字符串，第二个参数是修饰符\n  - `let reg2 = new RegExp(/xyz/i);` 第二种写法：只有一个参数：正则表达式\n  - `let reg3 = /xyz/i` 第三种方法，字面量（直接量）语法\n+ `\"^\"`\n### 方括号[]用法\n```javascript\n{\n  let reg = /[abc]/; // 至少包含abc中的一个字符\n  console.log(reg.test('kkk')) // false\n  console.log(reg.test('a')) // true\n  console.log(reg.test('ak')) // true\n  console.log(reg.test('ab')) // true\n}\n{\n  let reg = /[^abc]/; // 匹配除了abc构成的组合以外的的任意字符，匹配到了，test()就返回true\n  console.log(reg.test('kkk')) // true\n  console.log(reg.test('a')) // false\n  console.log(reg.test('af')) // true\n  console.log(reg.test('abcg')) // true\n  console.log(reg.test('abc')) // false\n}\n```\n### \"^\"用法：\n1. 用法一：限定开头\n比如 /^a/会匹配\"abc\"中的a，但是不会匹配\"Abc\"中的A\n```javascript\n{\n  let reg = new RegExp(/^\\s/) // 匹配第一个空格\n  console.log(reg.test(' a')); // true\n}\n\n{\n  let reg = new RegExp(/^ab[0-9]*a/) // 匹配开头ab+任意位数数字组合+a\n  console.log(reg.test('ab69aafa')); // true\n  console.log(reg.test('ab69b')) // false\n}\n```\n2. 用法二：（否）取反\n\n\n```javascript\n{\n  let reg = new RegExp(/[^a-z\\s]/);\n  console.log(reg.test(\"my 3 sisters\"))\n  // 正则对象匹配到了数字字符3，则返回true\n}\n```\n+ 表示否定的示例：\n```javascript\n[^a] // 表示“匹配除了a的任意字符”。\n[^a-zA-Z0-9] // 表示“找到一个非字母也非数字的字符”。\n[\\^abc] // 表示“找到一个插入符或者a或者b或者c”。\n```\n经过对比，只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头。我这里说的是直接在”[]”中使用，不包括嵌套使用。 \n其实也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。\n\n### 量词\n```javascript\n{\n  let reg = /a{3}/g; // 匹配包含 3 个 a 的序列的字符串。\n  console.log('aabbbbaa'.match(reg)) // null\n  console.log('aaabbbbaa'.match(reg)) // 返回数组[\"aaa\"]\n  console.log('aaabbbbaaa'.match(reg)) // 返回数组[\"aaa\", \"aaa\"]\n}\n{\n  let reg = /a{2,3}/g; // 匹配包含 2 到3 个 a 的序列的字符串。注意：2和3之间不能有格式空格\n  console.log('aab'.match(reg)) // 返回数组 [\"aa\"]\n  console.log('aaabbbbaa'.match(reg)) // 返回数组[\"aaa\", \"aa\"]\n  console.log('aba'.match(reg)) // 返回 null\n}\n{\n  let reg = /a{2,}/g; // 匹配包含至少 2 个 a 的序列的字符串。\n  console.log('aab'.match(reg)) // [\"aa\"]\n  console.log('aaabbbbaa'.match(reg)) // [\"aaa\", \"aa\"]\n  console.log('aba'.match(reg)) // null\n}\n{\n  let str=\"Is this all there is\"; // 对其后紧跟 \"all\" 的 \"is\" 进行全局搜索, all之前可以有0个或者多个空格，也可以匹配到\n  let patt1=/is(?=\\s*all)/g;\n  console.log(str.match(patt1)) // 返回数组 [\"is\"]\n}\n{\n  let str=\"Is this all there is\"; // 对其后没有紧跟 \" all\" 的 \"s\" 进行全局搜索，匹配到开头Is中的s和结尾is中的s\n  let patt1=/s(?!\\s*all)/g;\n  console.log(str.match(patt1)) // 返回数组 [\"s\", \"s\"]\n}\n```\n### 修饰符 attributes\n+ `m`多行模式\n```javascript\n{\n  let str = \"abc\\nab\" \n  console.log(str) // abc\n                   // ab\n  let patt1 = /^a/g\n  let patt2 = /^a/mg // 每次换行都会匹配开头的字符a\n  console.log(str.match(patt1)) // [\"a\"]\n  console.log(str.match(patt2)) // [\"a\", \"a\"]\n}\n```\n### 正则对象的方法 compile,exec,exec\n\n1. compile方法\n功能说明：该方法可以编译指定的正则表达式，编译之后的正则表达式执行速度将会提高，如果正则表达式多次被调用，那么调用compile方法可以有效的提高代码的执行速度，如果该正则表达式只能被使用一次，则不会有明显的效果。\n```javascript\n{\n  let str=\"Every man in the world! Every woman on earth!\";\n  patt=/man/g;\n  str2=str.replace(patt,\"person\");\n  console.log(str2); // Every person in the world! Every woperson on earth!\n \n  patt=/(wo)?man/g;\n  patt.compile(patt); // //重新编译正则表达式 ，注释这一行也可以正常执行，但通常改变原有的正则对象这样效率更高\n  str2=str.replace(patt,\"person\");\n  console.log(str2); // Every person in the world! Every person on earth!\n}\n\n```\n2. exec方法\n```javascript\n{\n  let str = 'aaabbbbaabbba';\n          // aaa    aa   a\n  let patt1 = /a+/g;\n  console.log(patt1.exec(str)) // [\"aaa\", index: 0, input: \"aaabbbbaabbba\", groups: undefined]\n  console.log(patt1.exec(str)) // [\"aa\", index: 7, input: \"aaabbbbaabbba\", groups: undefined]\n  console.log(patt1.exec(str)) // [\"a\", index: 12, input: \"aaabbbbaabbba\", groups: undefined\n  console.log(patt1.exec(str)) // null\n  console.log(patt1.exec(str)) // [\"aaa\", index: 0, input: \"aaabbbbaabbba\", groups: undefined]\n  // exec()方法的使用必须是连续的，这样才能实现连续调用并且完成全局依次搜索\n}\n```\n3. test方法\n检索字符串中指定的值。返回 true 或 false。\n```javascript\n{\n  let str = 'abc'\n  let patt1 = /^a[b|c]/\n  console.log(patt1.test(str)) // true\n}\n```\n使用场景：校验手机号码\n```javascript\n{\n  function checkMobile(sMobile){ \n  return ((/^1[3|4|5|8][0-9]\\d{8}$/.test(sMobile)));\n  } \n  let sMobile = '13844444466'\n  console.log(checkMobile(sMobile)) // true\n}\n```\n\n### 支持正则表达式的 String 对象的方法\n1. search方法\n返回 stringObject 中第一个与 regexp 相匹配的子串的起始位置。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。\n```javascript\n{\n  let str = 'bbaaacccaa' \n  let patt1 = /a+/g; // 执行search()方法时，将会忽视attribute i\n  console.log(str.search(patt1)) // 2\n}\n```\n2. match方法\nmatch() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。\n```javascript\n{\n  let str = 'abaabaaa';\n  let patt1 = /a+/g; // match()方法执行依赖属性 g\n  console.log(str.match(patt1)) // 返回数组 [\"a\", \"aa\", \"aaa\"]\n  let patt2 = /a+/;\n  console.log(str.match(patt2)) // 返回 [\"a\", index: 0, input: \"abaabaaa\", groups: undefined]\n}\n```\n3. replace方法\nreplace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\nstringObject.replace(regexp/substr,replacement)，请注意如果第一个参数是，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。\n字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\n```javascript\n{\n  let str = \"Hello Microsoft, Microsoft is awesome\";\n  let newStr = str.replace(/Microsoft/, 'masia'); // 只替换第一次匹配到的Microsoft\n  console.log(str); // Hello Microsoft, Microsoft is awesome\n  console.log(newStr); // Hello masia, Microsoft is awesome\n  let newStr2 = str.replace(/Microsoft/g, 'maisa'); //执行全局替换\n  console.log(newStr2); //  Hello maisa, maisa is awesome\n}\n```\n4. split方法\nsplit() 方法用于把一个字符串分割成字符串数组。\nstringObject.split(separator,howmany)\n参数： \nseparator\t必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。\nhowmany\t可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。\n```javascript\n{\n  let str = \"Hello world, I am masia\";\n  let arr = str.split(/\\,?\\s/);\n  console.log(arr) // [\"Hello\", \"world\", \"I\", \"am\", \"masia\"]\n}\n```\nsplit的惯例用法：\n+ 注释：如果把空字符串 (\"\") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。\n+ 注释：String.split() 执行的操作与 Array.join 执行的操作是相反的。\n```javascript\n\"hello\".split(\"\") // 可返回 [\"h\", \"e\", \"l\", \"l\", \"o\"]\n\"hello\".split(\"\", 3)\t//可返回 [\"h\", \"e\", \"l\"]\n\n{\n  let str=\"How are you doing today?\"\n  console.log(str.split(\" \")) // [\"How\", \"are\", \"you\", \"doing\", \"today?\"]\n  console.log(str.split(\"\")) // [\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]\n  console.log(str.split(\" \", 3)) // [\"How\", \"are\", \"you\"] \n}\n```\n+ Array.join()\njoin() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。\narrayObject.join(separator)\nseparator\t可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。\n```javascript\n{\n  let arr = ['Hello', 'masia']\n  let str = arr.join(\" \")\n  console.log(str) // Hello masia\n}\n```\n+ 复习数组的splice方法\nsplice方法，接收两个参数， \n第一个参数是要删除元素数组项的下标（第一个参数可以位负值，-1表示从数组倒数第一个数组项开始），\n第二个参数是要删除的数量，\n返回值是切下来的元素组成的数组\n操作完成之后会改变原来的数组\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.splice(1, 2);\n  console.log(arr) // [1, 4]\n  console.log(newArr) // [2, 3]\n}\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.splice(-1, 2); // 如果第一个参数是负值的话，第二个参数则无效\n  console.log(arr) // [1, 2, 3]\n  console.log(newArr) // [4]\n}\n```\n+ 复习数组的slice方法\nslice() 方法可从已有的数组中返回选定的元素\narrayObject.slice(start,end)\nstart\t必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。\nend\t可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.slice(1); // 数组下标1的位置（包含该位置的值），一直切到结尾\n  console.log(arr); // [1, 2, 3, 4] slice方法不会改变原来的数组\n  console.log(newArr); // [2, 3, 4]\n}\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.slice(1, 2); // 从数组下标1的位置（包含此位置）之开始，切到数组下标为2的位置的前面一个位置\n  console.log(arr); // [1, 2, 3, 4]\n  console.log(newArr); // [2]\n}\n{\n  let arr = [1, 2, 3, 4]; // 从数组下标1的位置开始（包含此位置），切到-1位置前面一个位置（不包含-1这个位置）\n  let newArr = arr.slice(1, -1);\n  console.log(arr); // [1, 2, 3, 4]\n  console.log(newArr); // [2, 3]\n}\n```","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ncategories:\n  - 正则表达式\ntags:\n  - 正则表达式\nabbrlink: 13f9823b\ndate: 2019-04-29 14:00:00\n---\n# 正则表达式\n+ 创建正则对象的三种方式:\n<!-- more -->\n  - `let reg = new RegExp('xyz', 'i')` 第一种写法： 第一个参数是字符串，第二个参数是修饰符\n  - `let reg2 = new RegExp(/xyz/i);` 第二种写法：只有一个参数：正则表达式\n  - `let reg3 = /xyz/i` 第三种方法，字面量（直接量）语法\n+ `\"^\"`\n### 方括号[]用法\n```javascript\n{\n  let reg = /[abc]/; // 至少包含abc中的一个字符\n  console.log(reg.test('kkk')) // false\n  console.log(reg.test('a')) // true\n  console.log(reg.test('ak')) // true\n  console.log(reg.test('ab')) // true\n}\n{\n  let reg = /[^abc]/; // 匹配除了abc构成的组合以外的的任意字符，匹配到了，test()就返回true\n  console.log(reg.test('kkk')) // true\n  console.log(reg.test('a')) // false\n  console.log(reg.test('af')) // true\n  console.log(reg.test('abcg')) // true\n  console.log(reg.test('abc')) // false\n}\n```\n### \"^\"用法：\n1. 用法一：限定开头\n比如 /^a/会匹配\"abc\"中的a，但是不会匹配\"Abc\"中的A\n```javascript\n{\n  let reg = new RegExp(/^\\s/) // 匹配第一个空格\n  console.log(reg.test(' a')); // true\n}\n\n{\n  let reg = new RegExp(/^ab[0-9]*a/) // 匹配开头ab+任意位数数字组合+a\n  console.log(reg.test('ab69aafa')); // true\n  console.log(reg.test('ab69b')) // false\n}\n```\n2. 用法二：（否）取反\n\n\n```javascript\n{\n  let reg = new RegExp(/[^a-z\\s]/);\n  console.log(reg.test(\"my 3 sisters\"))\n  // 正则对象匹配到了数字字符3，则返回true\n}\n```\n+ 表示否定的示例：\n```javascript\n[^a] // 表示“匹配除了a的任意字符”。\n[^a-zA-Z0-9] // 表示“找到一个非字母也非数字的字符”。\n[\\^abc] // 表示“找到一个插入符或者a或者b或者c”。\n```\n经过对比，只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头。我这里说的是直接在”[]”中使用，不包括嵌套使用。 \n其实也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。\n\n### 量词\n```javascript\n{\n  let reg = /a{3}/g; // 匹配包含 3 个 a 的序列的字符串。\n  console.log('aabbbbaa'.match(reg)) // null\n  console.log('aaabbbbaa'.match(reg)) // 返回数组[\"aaa\"]\n  console.log('aaabbbbaaa'.match(reg)) // 返回数组[\"aaa\", \"aaa\"]\n}\n{\n  let reg = /a{2,3}/g; // 匹配包含 2 到3 个 a 的序列的字符串。注意：2和3之间不能有格式空格\n  console.log('aab'.match(reg)) // 返回数组 [\"aa\"]\n  console.log('aaabbbbaa'.match(reg)) // 返回数组[\"aaa\", \"aa\"]\n  console.log('aba'.match(reg)) // 返回 null\n}\n{\n  let reg = /a{2,}/g; // 匹配包含至少 2 个 a 的序列的字符串。\n  console.log('aab'.match(reg)) // [\"aa\"]\n  console.log('aaabbbbaa'.match(reg)) // [\"aaa\", \"aa\"]\n  console.log('aba'.match(reg)) // null\n}\n{\n  let str=\"Is this all there is\"; // 对其后紧跟 \"all\" 的 \"is\" 进行全局搜索, all之前可以有0个或者多个空格，也可以匹配到\n  let patt1=/is(?=\\s*all)/g;\n  console.log(str.match(patt1)) // 返回数组 [\"is\"]\n}\n{\n  let str=\"Is this all there is\"; // 对其后没有紧跟 \" all\" 的 \"s\" 进行全局搜索，匹配到开头Is中的s和结尾is中的s\n  let patt1=/s(?!\\s*all)/g;\n  console.log(str.match(patt1)) // 返回数组 [\"s\", \"s\"]\n}\n```\n### 修饰符 attributes\n+ `m`多行模式\n```javascript\n{\n  let str = \"abc\\nab\" \n  console.log(str) // abc\n                   // ab\n  let patt1 = /^a/g\n  let patt2 = /^a/mg // 每次换行都会匹配开头的字符a\n  console.log(str.match(patt1)) // [\"a\"]\n  console.log(str.match(patt2)) // [\"a\", \"a\"]\n}\n```\n### 正则对象的方法 compile,exec,exec\n\n1. compile方法\n功能说明：该方法可以编译指定的正则表达式，编译之后的正则表达式执行速度将会提高，如果正则表达式多次被调用，那么调用compile方法可以有效的提高代码的执行速度，如果该正则表达式只能被使用一次，则不会有明显的效果。\n```javascript\n{\n  let str=\"Every man in the world! Every woman on earth!\";\n  patt=/man/g;\n  str2=str.replace(patt,\"person\");\n  console.log(str2); // Every person in the world! Every woperson on earth!\n \n  patt=/(wo)?man/g;\n  patt.compile(patt); // //重新编译正则表达式 ，注释这一行也可以正常执行，但通常改变原有的正则对象这样效率更高\n  str2=str.replace(patt,\"person\");\n  console.log(str2); // Every person in the world! Every person on earth!\n}\n\n```\n2. exec方法\n```javascript\n{\n  let str = 'aaabbbbaabbba';\n          // aaa    aa   a\n  let patt1 = /a+/g;\n  console.log(patt1.exec(str)) // [\"aaa\", index: 0, input: \"aaabbbbaabbba\", groups: undefined]\n  console.log(patt1.exec(str)) // [\"aa\", index: 7, input: \"aaabbbbaabbba\", groups: undefined]\n  console.log(patt1.exec(str)) // [\"a\", index: 12, input: \"aaabbbbaabbba\", groups: undefined\n  console.log(patt1.exec(str)) // null\n  console.log(patt1.exec(str)) // [\"aaa\", index: 0, input: \"aaabbbbaabbba\", groups: undefined]\n  // exec()方法的使用必须是连续的，这样才能实现连续调用并且完成全局依次搜索\n}\n```\n3. test方法\n检索字符串中指定的值。返回 true 或 false。\n```javascript\n{\n  let str = 'abc'\n  let patt1 = /^a[b|c]/\n  console.log(patt1.test(str)) // true\n}\n```\n使用场景：校验手机号码\n```javascript\n{\n  function checkMobile(sMobile){ \n  return ((/^1[3|4|5|8][0-9]\\d{8}$/.test(sMobile)));\n  } \n  let sMobile = '13844444466'\n  console.log(checkMobile(sMobile)) // true\n}\n```\n\n### 支持正则表达式的 String 对象的方法\n1. search方法\n返回 stringObject 中第一个与 regexp 相匹配的子串的起始位置。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。\n```javascript\n{\n  let str = 'bbaaacccaa' \n  let patt1 = /a+/g; // 执行search()方法时，将会忽视attribute i\n  console.log(str.search(patt1)) // 2\n}\n```\n2. match方法\nmatch() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。\n```javascript\n{\n  let str = 'abaabaaa';\n  let patt1 = /a+/g; // match()方法执行依赖属性 g\n  console.log(str.match(patt1)) // 返回数组 [\"a\", \"aa\", \"aaa\"]\n  let patt2 = /a+/;\n  console.log(str.match(patt2)) // 返回 [\"a\", index: 0, input: \"abaabaaa\", groups: undefined]\n}\n```\n3. replace方法\nreplace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\nstringObject.replace(regexp/substr,replacement)，请注意如果第一个参数是，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。\n字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\n```javascript\n{\n  let str = \"Hello Microsoft, Microsoft is awesome\";\n  let newStr = str.replace(/Microsoft/, 'masia'); // 只替换第一次匹配到的Microsoft\n  console.log(str); // Hello Microsoft, Microsoft is awesome\n  console.log(newStr); // Hello masia, Microsoft is awesome\n  let newStr2 = str.replace(/Microsoft/g, 'maisa'); //执行全局替换\n  console.log(newStr2); //  Hello maisa, maisa is awesome\n}\n```\n4. split方法\nsplit() 方法用于把一个字符串分割成字符串数组。\nstringObject.split(separator,howmany)\n参数： \nseparator\t必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。\nhowmany\t可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。\n```javascript\n{\n  let str = \"Hello world, I am masia\";\n  let arr = str.split(/\\,?\\s/);\n  console.log(arr) // [\"Hello\", \"world\", \"I\", \"am\", \"masia\"]\n}\n```\nsplit的惯例用法：\n+ 注释：如果把空字符串 (\"\") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。\n+ 注释：String.split() 执行的操作与 Array.join 执行的操作是相反的。\n```javascript\n\"hello\".split(\"\") // 可返回 [\"h\", \"e\", \"l\", \"l\", \"o\"]\n\"hello\".split(\"\", 3)\t//可返回 [\"h\", \"e\", \"l\"]\n\n{\n  let str=\"How are you doing today?\"\n  console.log(str.split(\" \")) // [\"How\", \"are\", \"you\", \"doing\", \"today?\"]\n  console.log(str.split(\"\")) // [\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]\n  console.log(str.split(\" \", 3)) // [\"How\", \"are\", \"you\"] \n}\n```\n+ Array.join()\njoin() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。\narrayObject.join(separator)\nseparator\t可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。\n```javascript\n{\n  let arr = ['Hello', 'masia']\n  let str = arr.join(\" \")\n  console.log(str) // Hello masia\n}\n```\n+ 复习数组的splice方法\nsplice方法，接收两个参数， \n第一个参数是要删除元素数组项的下标（第一个参数可以位负值，-1表示从数组倒数第一个数组项开始），\n第二个参数是要删除的数量，\n返回值是切下来的元素组成的数组\n操作完成之后会改变原来的数组\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.splice(1, 2);\n  console.log(arr) // [1, 4]\n  console.log(newArr) // [2, 3]\n}\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.splice(-1, 2); // 如果第一个参数是负值的话，第二个参数则无效\n  console.log(arr) // [1, 2, 3]\n  console.log(newArr) // [4]\n}\n```\n+ 复习数组的slice方法\nslice() 方法可从已有的数组中返回选定的元素\narrayObject.slice(start,end)\nstart\t必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。\nend\t可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。\n```javascript\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.slice(1); // 数组下标1的位置（包含该位置的值），一直切到结尾\n  console.log(arr); // [1, 2, 3, 4] slice方法不会改变原来的数组\n  console.log(newArr); // [2, 3, 4]\n}\n{\n  let arr = [1, 2, 3, 4];\n  let newArr = arr.slice(1, 2); // 从数组下标1的位置（包含此位置）之开始，切到数组下标为2的位置的前面一个位置\n  console.log(arr); // [1, 2, 3, 4]\n  console.log(newArr); // [2]\n}\n{\n  let arr = [1, 2, 3, 4]; // 从数组下标1的位置开始（包含此位置），切到-1位置前面一个位置（不包含-1这个位置）\n  let newArr = arr.slice(1, -1);\n  console.log(arr); // [1, 2, 3, 4]\n  console.log(newArr); // [2, 3]\n}\n```","slug":"正则表达式","published":1,"updated":"2020-01-20T07:45:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjg005ilktvuxjxe10r"},{"title":"登录组件的的见解","categroies":["vue","vuex"],"date":"2019-05-30T10:05:00.000Z","_content":"目前认为登录组件中关于点击登录之后，根据返回信息的执行的各种操作，放在登录组件自身的方法中去执行比较合理。观点如下：\n<!-- more -->\n1. 登录方法使用的单一性，一个系统也许只有一个登录模块，那么也许只有这样一个模块在调用登录方法。并不像获取列表，获取个人信息等方法要被好多组件所共用。\n2. 根据接口返回的结果，直接去判断是用户名不存在，输入密码错误，还是登录成功。省去vuex中对登录状态的赋值操作。一方面麻烦，另外一方面，vuex中的改变状态的所提交的commit()方法为异步操作，所以还需要依赖监听属性去监听登录状态，再去决定执行接下来的操作，需要考虑执行顺序，容易出问题。\n\n直接把登录方法封装在登录组件之中，可以省去token在vuex中的存放，登录成功后，登录组件中的登录方法中，将token写入用户浏览器的session中，然后，可以直接根据成功登录的返回的状态码，去决定页面的跳转。\n\n总结： 登录组件的特殊性，使得直接把登录的各种操作写在vue组件里面比使用vuex更方便。","source":"_posts/登录组件的见解.md","raw":"---\ntitle: 登录组件的的见解\ncategroies:\n  - vue\n  - vuex\ntags: \n  - vue\n  - vuex\ndate: 2019-05-30 18:05:00\n---\n目前认为登录组件中关于点击登录之后，根据返回信息的执行的各种操作，放在登录组件自身的方法中去执行比较合理。观点如下：\n<!-- more -->\n1. 登录方法使用的单一性，一个系统也许只有一个登录模块，那么也许只有这样一个模块在调用登录方法。并不像获取列表，获取个人信息等方法要被好多组件所共用。\n2. 根据接口返回的结果，直接去判断是用户名不存在，输入密码错误，还是登录成功。省去vuex中对登录状态的赋值操作。一方面麻烦，另外一方面，vuex中的改变状态的所提交的commit()方法为异步操作，所以还需要依赖监听属性去监听登录状态，再去决定执行接下来的操作，需要考虑执行顺序，容易出问题。\n\n直接把登录方法封装在登录组件之中，可以省去token在vuex中的存放，登录成功后，登录组件中的登录方法中，将token写入用户浏览器的session中，然后，可以直接根据成功登录的返回的状态码，去决定页面的跳转。\n\n总结： 登录组件的特殊性，使得直接把登录的各种操作写在vue组件里面比使用vuex更方便。","slug":"登录组件的见解","published":1,"updated":"2020-01-20T07:45:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjh005klktvy7pk08d4"},{"title":"监视属性","date":"2019-06-01T03:50:00.000Z","_content":"## 监视路由 \n<!-- more -->\n#### 普通监视\n```javascript\nwatch: {\n  $route (to, form) { // 普通监视\n\n  },\n  '$route.params.id' () { // 监视route里面的参数值\n    console.log(this.$route.params.id)\n  }\n} \n```\n#### 深度监视\n```javascript\nwatch: {\n  $route: {\n    handler (newVal, oldVal) {\n      console.log('newVal', newVal)\n      console.log('oldVal', oldVal)\n    },\n    deep: true\n  }\n}\n```\n#### 监视变化，调用函数\n+ 无参数情况\n```javascript\nwatch: {\n  $route: 'getAlert'  // 注意这里的函数名必须要加引号\n},\nmethods: {\n  getAlert () {\n    console.log('路由发生变化了');\n  }\n}\n```\n+ 有参数情况\n```javascript\nwatch: {\n  $route (newVal, oldVal) {\n    this.getAlert(newVal.params.id)\n  }\n},\nmethods: {\n  getAlert (id) {\n    console.log('路由的params参数为'+ id)\n  }\n}\n```","source":"_posts/监视属性.md","raw":"---\ntitle: 监视属性\ncategories: \n  - vue\n  - watch\ntags: \n  - vue\n  - watch\ndate: 2019-06-01 11:50:00\n---\n## 监视路由 \n<!-- more -->\n#### 普通监视\n```javascript\nwatch: {\n  $route (to, form) { // 普通监视\n\n  },\n  '$route.params.id' () { // 监视route里面的参数值\n    console.log(this.$route.params.id)\n  }\n} \n```\n#### 深度监视\n```javascript\nwatch: {\n  $route: {\n    handler (newVal, oldVal) {\n      console.log('newVal', newVal)\n      console.log('oldVal', oldVal)\n    },\n    deep: true\n  }\n}\n```\n#### 监视变化，调用函数\n+ 无参数情况\n```javascript\nwatch: {\n  $route: 'getAlert'  // 注意这里的函数名必须要加引号\n},\nmethods: {\n  getAlert () {\n    console.log('路由发生变化了');\n  }\n}\n```\n+ 有参数情况\n```javascript\nwatch: {\n  $route (newVal, oldVal) {\n    this.getAlert(newVal.params.id)\n  }\n},\nmethods: {\n  getAlert (id) {\n    console.log('路由的params参数为'+ id)\n  }\n}\n```","slug":"监视属性","published":1,"updated":"2020-01-20T07:45:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gji005olktvfbxbyhz7"},{"title":"神经网络学习","tages":["神经网络"],"categroies":["神经网络"],"date":"2019-06-02T16:00:00.000Z","_content":"\n## 创业团队\n<!-- more -->\n  + 前端\n  + 后端\n  + UI\n  + 算法工程师\n\n## visual recognition\n  + 识别物体 \n   四个向量： 左上角的坐标，物体的宽和高\n## segmentation 语义分析\n## deepface 生成对抗网络 GANs","source":"_posts/神经网络学习.md","raw":"---\ntitle: 神经网络学习\ntages: \n  - 神经网络\ncategroies:\n  - 神经网络\ndate: 2019-06-03\n---\n\n## 创业团队\n<!-- more -->\n  + 前端\n  + 后端\n  + UI\n  + 算法工程师\n\n## visual recognition\n  + 识别物体 \n   四个向量： 左上角的坐标，物体的宽和高\n## segmentation 语义分析\n## deepface 生成对抗网络 GANs","slug":"神经网络学习","published":1,"updated":"2020-01-20T07:45:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjj005plktvekpap97h"},{"title":"监视属性","_content":"\n## 请求队列\n<!-- more -->\n### 问题描述\n云桌面、云主机规格价格计算\n1. 每次点击选中不同的参数时都会引起价格的重新计算（比如选择CPU规格2核、4核等），价格的计算采用的方式是调取后台的价格计算接口;\n2. 不同维度的参数具有一些依赖关系\n> + 比如，vCPU依赖资源池，内存依赖vCPU（这个也非常好理解，比如兰州这个节点下面没有性能较高的主机，那么也没有比如32核的vCPU，但是杭州这个节点下面有；不同规格的vCPU有与内存之间建立的对应关系，弹性云主机的选择比较注重cpu与内存的比例，比如cpu与内存比是1：4的，就是偏向于存储型的云主机，2：4的就是偏计算型的云主机）\n3. 每次拿到参数列表时都会默认选中一个\n> 1. 比如，选中资源池为兰州 \n> 2. -> 调取获取vCPU列表接口，重新获取vCPU的列表为 `const vCPUList = [1, 2, 4, 8, 16]`\n> 3. 执行selectVCPU(1)，默认选中第一个（1核）\n> 4. -> 调取获取内存列表接口，重新获取内存列表为`const memList = [1, 2, 4, 8]`\n> 5. 执行selectMem(1)，默认选中第一个（1G）\n> 6. 可以看出 资源池 > vCPU > Memsize 这个三个参数的选择的顺序上是同步的，并且存在从后想前的依赖关系，所以可以在`selectMem`方法体中去执行价格计算方法`calcPrice()`\n4. 不同维度的参数不具有依赖关系\n> + 比如，数据盘容量与公网带宽和上面三种参数不具有关联关系，那么当这两种参数改变的时候去哪里执行价格计算呢？\n> + 肯定是在点击事件的回调中去执行价格计算\n5. 有依赖关系的参数与没有依赖关系的参数混合起来使用的时候，该在哪里调用价格计算？\n> 1. 在第一次初始化参数的时候，假设 资源池、vCPU、内存 归结位一条参数选择线A，命名为`selectLineA` ；当然，数据盘类型和容量也分别有相应的初始值，那我们把数据盘类型、数据盘容量归结为参数选择线B，命名为`selectLineB`；\n> 当内存选择完成之后，我们称`selectLineA`完成，当数据盘容量选择完成之后，我们称`selectLineB`完成\n> 2. 虽然我们可以去强行控制这两条线的执行顺序，比如让`selectLineB`在`selectLineA`完成之后执行，但是这样其实是在强行建立无意义的依赖关系，而且执行重复的接口调用，浪费资源，比如选择了内存之后，`selectLineA`完成，又执行`selectLineB`，这样还会把用户在之前选择的数据盘类型和容量重新赋初始值，用户体验很差。\n> 3. 在那我们很容易联想到`selectLineA`和`selectLineB`都完成的时候，再去计算价格就可以了，这里我想到的思路就是使用Promise.all()去实现。但其实这种方式只适用于第一次初始化两条线的时候，比如我在初始化之后的某个时间点去改变数据盘容量，`selectLineB`，但是`selectLineA`压根就没有执行，怎么会引起Promise.all()的执行呢？\n> 4. 那我们就让`selectLineA`和`selectLineB`分别执行就好了，也不要管什么顺序了，他们完成之后分别去执行价格计算就好了，可以不?\n> 分别执行价格计算是可以的，但是不能忽略顺序，因为价格计算最后要将资源池、vCPU、内存、数据盘类型、数据盘容量等参数一起提交给后台，不然后台会返回错误信息。假设同时执行`selectLineA`和`selectLineB`，`selectLineA`已经完成，但是`selectLineB`还没有完成，这是在`selectLineA`中去执行跳去价格计算接口，数据就会返回错误，返回错误其实比较好的情况，因为至少不会给数据赋值。\n> 5. 还有一种情况，执行多次`selectLineB`，每次选中的数据盘容量不一样，但是每次选择后调取价格计算接口返回的顺序不一致，就会导致选择的容量与最后价格对不上的情况。比如：第1次选择40G，期待计算正确应该是40元，第2次选择80G，期待计算正确应该是80元，但是有可能第2次请求虽然后发，先返回了数据80元，并且给数据模型赋值80元，随后第1次请求完成，返回数据40元，并且给数据模型赋值40元。这样，程序就出现了逻辑错误，让用户觉得选中了较小的数据盘反而价格变低，当然这样不影响最后下单需要支付的费用，因为支付费用还是要根据的具体的参数算价格，这里在网页上算的价格只是展示给用户看的。\n\n### 解决方案使用请求队列\n请求队列解决多个相同异步请求的执行顺序问题和重复请求问题\n> + 假设：\n> 1. 请求A的请求时间是5s（这里稍微夸张一点），即 reqPendingTime = 5s\n> 2. 在3s的时间内依次发起请求 reqA1， reqA2， reqA3，reqA4， reqA5，显然全部发起这些请求是无意义的，因为我们只要最新的`reqA`返回的结果\n> 3. reqA就好比一个价格计算接口，reqA1 ~ reqA5 是用户在3s的时间内选择不同的参数之后执行的价格计算\n> + 解决思路：\n> 1. 在调取价格请求之前，找个数组去保存 reqA1 ~ reqA5 这样一些状态，比如：reqQue = [reqA1, reqA2, reqA3, reqA4, reqA5,];\n> 2. 如果队列长度不为0，则执行 reqA1；\n> 3. 在执行完成reqA1之后（这里不管是成功还是失败），检查队列的长度，如果大于1，说明在reqA1请求的这段时间里，有新的请求加入了队列；\n> 4. 移出包括自己在内的就请求，只留下最新的一个请求，也就是队尾的那个，我们假设此时队尾的请求为reqA5；\n> 5. 如果队列长度不为1，执行 reqA5；\n> 6. 在执行完成reqA1之后（这里不管是成功还是失败），检查队列的长度，如果大于1，重复第3步，否则，说明没有新的请求加入队列，此时清空队列。\n> + 代码模型实现：\n```javascript \nconst reqQue = [];\n\n// 调取接口前的队列检查函数\nfunction checkReqQue() { // 每次要调接口之前都会先加进队列\n  if (!reqQue.length) { // 如果队列为空，\n    reqQue.push(reqA); // 则 加入队列\n    reqQue[0](); // 且执行\n  } else { // 否则\n    reqQue.push(reqA); // 只加入队列\n  }\n\n  // 或者\n  /*\n  this.reqQue.push(this.priceCalculateNext); // 加入队列\n  if (this.reqQue.length == 1) {\n    this.reqQue[0]();\n  }\n  */\n}\n\n// 模拟请求函数\nfunction reqA(random) {\n  // 请求结果模拟，随机成功或者失败\n  const random = Math.ceil(Math.random()*10);\n  if (random < 7) { // 5分之4的概率成功\n    setTimeout(() => { // 成功回调，返回随机数\n      console.log('成功的回调');\n      // 判断请求队列\n      if (reqQue.length > 1) { // 如果请求队列长度大于1，那证明在当前请求请求的这段时间内，又有后续的请求加进来\n        reQue.splice(0, reqQue.length - 1); // 只留下最后一个请求\n        reqQue[reqQue.length - 1](); // 执行最后一个请求\n      } else { // 如果请求队列长度等于1 ，那证明当前的请求队列只包含当前请求\n        reQue.splice(0, reqQue.length); // 因为当前请求已经执行过了，所以清空给队列\n      }\n      \n      return;\n    }, 5000);\n  } else { // 5分之1概率失败\n    setTimeout(() => { // 成功回调，返回随机数\n      console.log('失败的回调');\n\n      // 判断请求队列\n      if (reqQue.length > 1) {\n        reQue.splice(0, reqQue.length - 1);\n        reqQue[reqQue.length - 1]();\n      } else {\n        reQue.splice(0, reqQue.length);\n      }\n\n      return;\n    }, 5000); \n  }\n}\n\n```\n### 请求队列与节流结合使用\n假设选择数据盘的方式是输入数字型的，每当输入的时候都会重新计算价格，那么当用户要输入的目标值是500时，首先会在键盘键入5，其次是0，然后是0，如果我们给input绑定input事件，那么就会触发3次input事件函数，如果在该函数中调用calcPrice()，实际上在短时间内调用了3次价格计算且前面两次是没有意义的。\n> 使用节流函数，当用户将要调用某一个函数的时候，延迟 500ms 的时间在去调用，如果在500ms内用户重复调用该函数，那就继续延迟500ms\n> 代码模型实现\n```javascript\nconst timer = null; // 定义一个全局的定时器\n\nfunction debounce() {\n  timer && clearTimeout(timer); // 每次调用 都会先检查全局的定时器，如果有定时任务，则清除\n  timer = setTimeout(() => { // 重新定义定时任务\n    checkReqQue(); // 执行当前定时任务任务主体\n  }, 500);\n}\n\n```","source":"_posts/请求队列应用.md","raw":"---\ntitle: 监视属性\ncategories: \n  - js\n  - vue\ntags: \n  - js\n  - vue\n---\n\n## 请求队列\n<!-- more -->\n### 问题描述\n云桌面、云主机规格价格计算\n1. 每次点击选中不同的参数时都会引起价格的重新计算（比如选择CPU规格2核、4核等），价格的计算采用的方式是调取后台的价格计算接口;\n2. 不同维度的参数具有一些依赖关系\n> + 比如，vCPU依赖资源池，内存依赖vCPU（这个也非常好理解，比如兰州这个节点下面没有性能较高的主机，那么也没有比如32核的vCPU，但是杭州这个节点下面有；不同规格的vCPU有与内存之间建立的对应关系，弹性云主机的选择比较注重cpu与内存的比例，比如cpu与内存比是1：4的，就是偏向于存储型的云主机，2：4的就是偏计算型的云主机）\n3. 每次拿到参数列表时都会默认选中一个\n> 1. 比如，选中资源池为兰州 \n> 2. -> 调取获取vCPU列表接口，重新获取vCPU的列表为 `const vCPUList = [1, 2, 4, 8, 16]`\n> 3. 执行selectVCPU(1)，默认选中第一个（1核）\n> 4. -> 调取获取内存列表接口，重新获取内存列表为`const memList = [1, 2, 4, 8]`\n> 5. 执行selectMem(1)，默认选中第一个（1G）\n> 6. 可以看出 资源池 > vCPU > Memsize 这个三个参数的选择的顺序上是同步的，并且存在从后想前的依赖关系，所以可以在`selectMem`方法体中去执行价格计算方法`calcPrice()`\n4. 不同维度的参数不具有依赖关系\n> + 比如，数据盘容量与公网带宽和上面三种参数不具有关联关系，那么当这两种参数改变的时候去哪里执行价格计算呢？\n> + 肯定是在点击事件的回调中去执行价格计算\n5. 有依赖关系的参数与没有依赖关系的参数混合起来使用的时候，该在哪里调用价格计算？\n> 1. 在第一次初始化参数的时候，假设 资源池、vCPU、内存 归结位一条参数选择线A，命名为`selectLineA` ；当然，数据盘类型和容量也分别有相应的初始值，那我们把数据盘类型、数据盘容量归结为参数选择线B，命名为`selectLineB`；\n> 当内存选择完成之后，我们称`selectLineA`完成，当数据盘容量选择完成之后，我们称`selectLineB`完成\n> 2. 虽然我们可以去强行控制这两条线的执行顺序，比如让`selectLineB`在`selectLineA`完成之后执行，但是这样其实是在强行建立无意义的依赖关系，而且执行重复的接口调用，浪费资源，比如选择了内存之后，`selectLineA`完成，又执行`selectLineB`，这样还会把用户在之前选择的数据盘类型和容量重新赋初始值，用户体验很差。\n> 3. 在那我们很容易联想到`selectLineA`和`selectLineB`都完成的时候，再去计算价格就可以了，这里我想到的思路就是使用Promise.all()去实现。但其实这种方式只适用于第一次初始化两条线的时候，比如我在初始化之后的某个时间点去改变数据盘容量，`selectLineB`，但是`selectLineA`压根就没有执行，怎么会引起Promise.all()的执行呢？\n> 4. 那我们就让`selectLineA`和`selectLineB`分别执行就好了，也不要管什么顺序了，他们完成之后分别去执行价格计算就好了，可以不?\n> 分别执行价格计算是可以的，但是不能忽略顺序，因为价格计算最后要将资源池、vCPU、内存、数据盘类型、数据盘容量等参数一起提交给后台，不然后台会返回错误信息。假设同时执行`selectLineA`和`selectLineB`，`selectLineA`已经完成，但是`selectLineB`还没有完成，这是在`selectLineA`中去执行跳去价格计算接口，数据就会返回错误，返回错误其实比较好的情况，因为至少不会给数据赋值。\n> 5. 还有一种情况，执行多次`selectLineB`，每次选中的数据盘容量不一样，但是每次选择后调取价格计算接口返回的顺序不一致，就会导致选择的容量与最后价格对不上的情况。比如：第1次选择40G，期待计算正确应该是40元，第2次选择80G，期待计算正确应该是80元，但是有可能第2次请求虽然后发，先返回了数据80元，并且给数据模型赋值80元，随后第1次请求完成，返回数据40元，并且给数据模型赋值40元。这样，程序就出现了逻辑错误，让用户觉得选中了较小的数据盘反而价格变低，当然这样不影响最后下单需要支付的费用，因为支付费用还是要根据的具体的参数算价格，这里在网页上算的价格只是展示给用户看的。\n\n### 解决方案使用请求队列\n请求队列解决多个相同异步请求的执行顺序问题和重复请求问题\n> + 假设：\n> 1. 请求A的请求时间是5s（这里稍微夸张一点），即 reqPendingTime = 5s\n> 2. 在3s的时间内依次发起请求 reqA1， reqA2， reqA3，reqA4， reqA5，显然全部发起这些请求是无意义的，因为我们只要最新的`reqA`返回的结果\n> 3. reqA就好比一个价格计算接口，reqA1 ~ reqA5 是用户在3s的时间内选择不同的参数之后执行的价格计算\n> + 解决思路：\n> 1. 在调取价格请求之前，找个数组去保存 reqA1 ~ reqA5 这样一些状态，比如：reqQue = [reqA1, reqA2, reqA3, reqA4, reqA5,];\n> 2. 如果队列长度不为0，则执行 reqA1；\n> 3. 在执行完成reqA1之后（这里不管是成功还是失败），检查队列的长度，如果大于1，说明在reqA1请求的这段时间里，有新的请求加入了队列；\n> 4. 移出包括自己在内的就请求，只留下最新的一个请求，也就是队尾的那个，我们假设此时队尾的请求为reqA5；\n> 5. 如果队列长度不为1，执行 reqA5；\n> 6. 在执行完成reqA1之后（这里不管是成功还是失败），检查队列的长度，如果大于1，重复第3步，否则，说明没有新的请求加入队列，此时清空队列。\n> + 代码模型实现：\n```javascript \nconst reqQue = [];\n\n// 调取接口前的队列检查函数\nfunction checkReqQue() { // 每次要调接口之前都会先加进队列\n  if (!reqQue.length) { // 如果队列为空，\n    reqQue.push(reqA); // 则 加入队列\n    reqQue[0](); // 且执行\n  } else { // 否则\n    reqQue.push(reqA); // 只加入队列\n  }\n\n  // 或者\n  /*\n  this.reqQue.push(this.priceCalculateNext); // 加入队列\n  if (this.reqQue.length == 1) {\n    this.reqQue[0]();\n  }\n  */\n}\n\n// 模拟请求函数\nfunction reqA(random) {\n  // 请求结果模拟，随机成功或者失败\n  const random = Math.ceil(Math.random()*10);\n  if (random < 7) { // 5分之4的概率成功\n    setTimeout(() => { // 成功回调，返回随机数\n      console.log('成功的回调');\n      // 判断请求队列\n      if (reqQue.length > 1) { // 如果请求队列长度大于1，那证明在当前请求请求的这段时间内，又有后续的请求加进来\n        reQue.splice(0, reqQue.length - 1); // 只留下最后一个请求\n        reqQue[reqQue.length - 1](); // 执行最后一个请求\n      } else { // 如果请求队列长度等于1 ，那证明当前的请求队列只包含当前请求\n        reQue.splice(0, reqQue.length); // 因为当前请求已经执行过了，所以清空给队列\n      }\n      \n      return;\n    }, 5000);\n  } else { // 5分之1概率失败\n    setTimeout(() => { // 成功回调，返回随机数\n      console.log('失败的回调');\n\n      // 判断请求队列\n      if (reqQue.length > 1) {\n        reQue.splice(0, reqQue.length - 1);\n        reqQue[reqQue.length - 1]();\n      } else {\n        reQue.splice(0, reqQue.length);\n      }\n\n      return;\n    }, 5000); \n  }\n}\n\n```\n### 请求队列与节流结合使用\n假设选择数据盘的方式是输入数字型的，每当输入的时候都会重新计算价格，那么当用户要输入的目标值是500时，首先会在键盘键入5，其次是0，然后是0，如果我们给input绑定input事件，那么就会触发3次input事件函数，如果在该函数中调用calcPrice()，实际上在短时间内调用了3次价格计算且前面两次是没有意义的。\n> 使用节流函数，当用户将要调用某一个函数的时候，延迟 500ms 的时间在去调用，如果在500ms内用户重复调用该函数，那就继续延迟500ms\n> 代码模型实现\n```javascript\nconst timer = null; // 定义一个全局的定时器\n\nfunction debounce() {\n  timer && clearTimeout(timer); // 每次调用 都会先检查全局的定时器，如果有定时任务，则清除\n  timer = setTimeout(() => { // 重新定义定时任务\n    checkReqQue(); // 执行当前定时任务任务主体\n  }, 500);\n}\n\n```","slug":"请求队列应用","published":1,"date":"2020-01-20T07:45:19.000Z","updated":"2020-01-20T07:45:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjk005tlktvqgz0a8hy"},{"title":"闭包","date":"2019-04-29T06:00:00.000Z","_content":"\n## 使用构造函数创建对象这个过程会形成闭包，因为将内部的this变量最后return出去，而且在外部还有一个变量去接收\n验证如下：\n<!-- more -->\n```javascript\n{\n  function Person () {\n    age = 0; // p.addAge()执行的时候这里的age在加加，说明在Peron()执行结束的时候，函数执行栈没有被销毁，而且还形成了一个闭包\n    this.addAge = function () {\n      console.log(++age);\n    }\n  }\n  var p = new Person();\n  p.addAge(); // 1\n  p.addAge(); // 2\n}\n\n```\n\n闭包就是在函数的执行的时候，把函数内部的引用变量保存到了外部，当然可以通过return的方式，也可以通过给外部对象的属性赋值方式。这样一来整个函数执行的栈就没有被释放。\n```javascript\n{\n  function fn () {\n  var num = 0;\n  var obj = {\n    addNum () {\n      console.log(++num);\n    }\n  }\n  return obj;\n  }\n  var obj = fn();\n  obj.addNum(); // 1\n  obj.addNum(); // 2\n}\n\n\n{\n  var outerVariable;\n  function fn () {\n    var num = 0;\n    function addNum () {\n      console.log(++num);\n    }\n    outerVariable = addNum;\n    return;\n  }\n  fn();\n  outerVariable(); // 1\n  outerVariable(); // 2\n}\n```","source":"_posts/闭包.md","raw":"---\ntitle: 闭包\ncategories:\n  - javascript\n  - 闭包\ntags:\n  - javascript\n  - 闭包\ndate: 2019-04-29 14:00:00\n---\n\n## 使用构造函数创建对象这个过程会形成闭包，因为将内部的this变量最后return出去，而且在外部还有一个变量去接收\n验证如下：\n<!-- more -->\n```javascript\n{\n  function Person () {\n    age = 0; // p.addAge()执行的时候这里的age在加加，说明在Peron()执行结束的时候，函数执行栈没有被销毁，而且还形成了一个闭包\n    this.addAge = function () {\n      console.log(++age);\n    }\n  }\n  var p = new Person();\n  p.addAge(); // 1\n  p.addAge(); // 2\n}\n\n```\n\n闭包就是在函数的执行的时候，把函数内部的引用变量保存到了外部，当然可以通过return的方式，也可以通过给外部对象的属性赋值方式。这样一来整个函数执行的栈就没有被释放。\n```javascript\n{\n  function fn () {\n  var num = 0;\n  var obj = {\n    addNum () {\n      console.log(++num);\n    }\n  }\n  return obj;\n  }\n  var obj = fn();\n  obj.addNum(); // 1\n  obj.addNum(); // 2\n}\n\n\n{\n  var outerVariable;\n  function fn () {\n    var num = 0;\n    function addNum () {\n      console.log(++num);\n    }\n    outerVariable = addNum;\n    return;\n  }\n  fn();\n  outerVariable(); // 1\n  outerVariable(); // 2\n}\n```","slug":"闭包","published":1,"updated":"2020-01-20T07:45:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5m75gjl005vlktvszkuz96s"}],"PostAsset":[{"_id":"source/_posts/ES6梳理-Generator/Generator3.png","slug":"Generator3.png","post":"ck5m75ghe0008lktv3jy65u90","modified":1,"renderable":0},{"_id":"source/_posts/React学习-组件生命周期/component_life.png","slug":"component_life.png","post":"ck5m75gi3001nlktva2kj9x4n","modified":1,"renderable":0},{"_id":"source/_posts/http-tcp/tcp3.png","slug":"tcp3.png","post":"ck5m75gi80021lktv7r5me15q","modified":1,"renderable":0},{"_id":"source/_posts/事件捕获和冒泡原理及其应用/propagation.png","slug":"propagation.png","post":"ck5m75gjc0059lktv6ghypk2b","modified":1,"renderable":0},{"_id":"source/_posts/ES6梳理-Iterator/Iterator_obj.png","post":"ck5m75ghh0009lktvnkwg064w","slug":"Iterator_obj.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-Symbol/Symbol.png","post":"ck5m75ghj000dlktvk97rl68l","slug":"Symbol.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-对象扩展/Object.entries().png","post":"ck5m75ghp000nlktv4nfgv663","slug":"Object.entries().png","modified":1,"renderable":1},{"_id":"source/_posts/js继承2/extends1.png","post":"ck5m75gic002alktvxf0z3qxy","slug":"extends1.png","modified":1,"renderable":1},{"_id":"source/_posts/请求队列应用/yun1.png","post":"ck5m75gjk005tlktvqgz0a8hy","slug":"yun1.png","modified":1,"renderable":1},{"_id":"source/_posts/ES5继承/ES5_extends.png","post":"ck5m75gh70002lktvk4aan9gm","slug":"ES5_extends.png","modified":1,"renderable":1},{"_id":"source/_posts/ES5继承/ES5_extends2.png","post":"ck5m75gh70002lktvk4aan9gm","slug":"ES5_extends2.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-数组扩展/Array.from().png","post":"ck5m75ght000xlktv2zcbbedp","slug":"Array.from().png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-数组扩展/ArrayObj.reduce().png","post":"ck5m75ght000xlktv2zcbbedp","slug":"ArrayObj.reduce().png","modified":1,"renderable":1},{"_id":"source/_posts/MVVM双向数据绑定原理/obj1.png","post":"ck5m75gi0001clktvqdkacv57","slug":"obj1.png","modified":1,"renderable":1},{"_id":"source/_posts/MVVM双向数据绑定原理/数据劫持.png","post":"ck5m75gi0001clktvqdkacv57","slug":"数据劫持.png","modified":1,"renderable":1},{"_id":"source/_posts/React学习-高阶组件/react_higher_component1.png","post":"ck5m75gi4001plktvgvg3gg82","slug":"react_higher_component1.png","modified":1,"renderable":1},{"_id":"source/_posts/React学习-高阶组件/react_higher_component2.png","post":"ck5m75gi4001plktvgvg3gg82","slug":"react_higher_component2.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-Generator/Generator1.png","post":"ck5m75ghe0008lktv3jy65u90","slug":"Generator1.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-Generator/Generator2.png","post":"ck5m75ghe0008lktv3jy65u90","slug":"Generator2.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-数据结构/Map([]).png","post":"ck5m75ghr000rlktvptxih8y4","slug":"Map([]).png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-数据结构/Set(arr).png","post":"ck5m75ghr000rlktvptxih8y4","slug":"Set(arr).png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-数据结构/WeakSet().png","post":"ck5m75ghr000rlktvptxih8y4","slug":"WeakSet().png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-数据结构/set.png","post":"ck5m75ghr000rlktvptxih8y4","slug":"set.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-类/class_compare1.png","post":"ck5m75ghx0015lktv8b5c5arg","slug":"class_compare1.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-类/class_compare2.png","post":"ck5m75ghx0015lktv8b5c5arg","slug":"class_compare2.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-类/class_compare3.png","post":"ck5m75ghx0015lktv8b5c5arg","slug":"class_compare3.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-类/class_simple.png","post":"ck5m75ghx0015lktv8b5c5arg","slug":"class_simple.png","modified":1,"renderable":1},{"_id":"source/_posts/ES6梳理-类/static1.png","post":"ck5m75ghx0015lktv8b5c5arg","slug":"static1.png","modified":1,"renderable":1},{"_id":"source/_posts/nvm安装/nvm_install1.png","post":"ck5m75giq003plktvm50dr6ay","slug":"nvm_install1.png","modified":1,"renderable":1},{"_id":"source/_posts/nvm安装/nvm_install2.png","post":"ck5m75giq003plktvm50dr6ay","slug":"nvm_install2.png","modified":1,"renderable":1},{"_id":"source/_posts/nvm安装/nvm_install3.png","post":"ck5m75giq003plktvm50dr6ay","slug":"nvm_install3.png","modified":1,"renderable":1},{"_id":"source/_posts/nvm安装/nvm_install4.png","post":"ck5m75giq003plktvm50dr6ay","slug":"nvm_install4.png","modified":1,"renderable":1},{"_id":"source/_posts/nvm安装/nvm_install5.png","post":"ck5m75giq003plktvm50dr6ay","slug":"nvm_install5.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck5m75gh70002lktvk4aan9gm","category_id":"ck5m75ghc0005lktvbx5235zl","_id":"ck5m75ghv0010lktv3mnwsvla"},{"post_id":"ck5m75gh70002lktvk4aan9gm","category_id":"ck5m75ghq000plktvfd1foc68","_id":"ck5m75ghx0013lktvxe32f2br"},{"post_id":"ck5m75ghj000dlktvk97rl68l","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi0001blktv14lcs9e3"},{"post_id":"ck5m75ghj000dlktvk97rl68l","category_id":"ck5m75ghv000zlktv6hgaq1yg","_id":"ck5m75gi1001flktv8iu257z8"},{"post_id":"ck5m75gha0004lktv8u0xikyv","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi3001jlktvbx4u666f"},{"post_id":"ck5m75gha0004lktv8u0xikyv","category_id":"ck5m75ghy0016lktv05sdtj0f","_id":"ck5m75gi4001olktv80h9qn46"},{"post_id":"ck5m75ghk000elktvxkhx5c61","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi5001qlktv4t7cscqh"},{"post_id":"ck5m75ghk000elktvxkhx5c61","category_id":"ck5m75gi1001dlktvokxbqeaz","_id":"ck5m75gi7001ulktv4qx8zvdv"},{"post_id":"ck5m75ghm000hlktv1yeoiao4","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gi8001ylktvyuvd7yo6"},{"post_id":"ck5m75ghm000hlktv1yeoiao4","category_id":"ck5m75gi3001llktvfnlz95ht","_id":"ck5m75gi90022lktvmsgvj028"},{"post_id":"ck5m75ghe0008lktv3jy65u90","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gia0024lktvksraqy2s"},{"post_id":"ck5m75ghe0008lktv3jy65u90","category_id":"ck5m75gi5001rlktvhjls8z76","_id":"ck5m75gic0029lktve5xd7lz4"},{"post_id":"ck5m75ghn000jlktvfk5v421x","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gid002elktv1vpvmyid"},{"post_id":"ck5m75ghn000jlktvfk5v421x","category_id":"ck5m75gi80020lktv05cxkkeo","_id":"ck5m75gie002hlktvhxycgbtl"},{"post_id":"ck5m75ghp000nlktv4nfgv663","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gif002klktvi0zfrsax"},{"post_id":"ck5m75ghp000nlktv4nfgv663","category_id":"ck5m75gib0027lktvqh317sut","_id":"ck5m75gig002olktvkk1q2c0k"},{"post_id":"ck5m75ghh0009lktvnkwg064w","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gih002slktv7f8x3pwj"},{"post_id":"ck5m75ghh0009lktvnkwg064w","category_id":"ck5m75gid002flktvk86vwawi","_id":"ck5m75gii002wlktv3iq2fq9n"},{"post_id":"ck5m75gig002nlktvtgk3xx0m","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gij002zlktvuye8rt9b"},{"post_id":"ck5m75ghq000olktv4vhpipq7","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gik0034lktvjvvdk66v"},{"post_id":"ck5m75ghq000olktv4vhpipq7","category_id":"ck5m75gif002llktvqpx6ssy3","_id":"ck5m75gil0037lktvgi81svtr"},{"post_id":"ck5m75ghr000rlktvptxih8y4","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gim003clktvw66d5yp8"},{"post_id":"ck5m75ghr000rlktvptxih8y4","category_id":"ck5m75gih002tlktvqljei58g","_id":"ck5m75gin003flktv2zuucq7f"},{"post_id":"ck5m75ght000xlktv2zcbbedp","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gip003klktvg6z1t97k"},{"post_id":"ck5m75ght000xlktv2zcbbedp","category_id":"ck5m75gik0033lktvaumv3flz","_id":"ck5m75gip003nlktv9rrb2fjf"},{"post_id":"ck5m75ghi000alktvcf92yx25","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gir003rlktvdbxcjky8"},{"post_id":"ck5m75ghi000alktvcf92yx25","category_id":"ck5m75gim003blktvbm5jhh2t","_id":"ck5m75gis003vlktv2x5qqfna"},{"post_id":"ck5m75ghu000ylktvd82jtisy","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75giv003zlktvyzl6comm"},{"post_id":"ck5m75ghu000ylktvd82jtisy","category_id":"ck5m75gio003jlktv8lnqefde","_id":"ck5m75giw0043lktv5whuxxmr"},{"post_id":"ck5m75ghv0011lktvv8cj14jq","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75giy0048lktv9t0mo3qq"},{"post_id":"ck5m75ghv0011lktvv8cj14jq","category_id":"ck5m75gir003slktvy7q1aq60","_id":"ck5m75giz004clktvqwsidgj4"},{"post_id":"ck5m75ghx0015lktv8b5c5arg","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gj0004glktvq2tpajd5"},{"post_id":"ck5m75ghx0015lktv8b5c5arg","category_id":"ck5m75giw0041lktvyb9nhwov","_id":"ck5m75gj2004klktv1oylne6h"},{"post_id":"ck5m75ghy0018lktvmipseua6","category_id":"ck5m75ghj000blktvnxmx6snx","_id":"ck5m75gj3004olktvfavchdo5"},{"post_id":"ck5m75ghy0018lktvmipseua6","category_id":"ck5m75giy0049lktvjci1t4hp","_id":"ck5m75gj4004slktvg4s6qac6"},{"post_id":"ck5m75gi6001tlktvwgpqjbp7","category_id":"ck5m75gjf005glktv5ppikq2e","_id":"ck5m75gjk005rlktvr8e0yy0w"},{"post_id":"ck5m75gi80021lktv7r5me15q","category_id":"ck5m75gjk005qlktv42etsx35","_id":"ck5m75gjn005zlktv76c467zm"},{"post_id":"ck5m75gid002dlktvrqfr81nt","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gjs006clktvoehlq5ja"},{"post_id":"ck5m75gie002ilktvwb60j5xt","category_id":"ck5m75gjs006blktvxpfub3k3","_id":"ck5m75gjt006ilktv3b1bmm4m"},{"post_id":"ck5m75gig002qlktv2saj50q1","category_id":"ck5m75gjt006glktvvp22di9d","_id":"ck5m75gju006nlktv3cjbkeo1"},{"post_id":"ck5m75gij002ylktv0xcbvj5w","category_id":"ck5m75gjf005glktv5ppikq2e","_id":"ck5m75gjx006vlktv9d52rebp"},{"post_id":"ck5m75gik0032lktv1p1uuhwb","category_id":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gjy006zlktvbwtmfjdt"},{"post_id":"ck5m75gil0036lktv68pfze8k","category_id":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gjz0073lktvs59hr36p"},{"post_id":"ck5m75gin003elktvd3ryz5ql","category_id":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gk0007alktv9ylhncws"},{"post_id":"ck5m75giw0040lktv5b7g9t25","category_id":"ck5m75gk3007mlktv9xbfos4e","_id":"ck5m75gk4007ulktvf87xhb5k"},{"post_id":"ck5m75ghz001alktvjrbdm9jd","category_id":"ck5m75gj1004hlktvivwo3pdp","_id":"ck5m75gk8008elktvfimdfpgx"},{"post_id":"ck5m75ghz001alktvjrbdm9jd","category_id":"ck5m75gk70088lktvqz9580ou","_id":"ck5m75gk8008glktvgot5j1ef"},{"post_id":"ck5m75gi0001clktvqdkacv57","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gk9008qlktvrgkbhosi"},{"post_id":"ck5m75gi0001clktvqdkacv57","category_id":"ck5m75gk8008hlktvw6zm5nyb","_id":"ck5m75gka008slktvkjebdahj"},{"post_id":"ck5m75gj5004wlktv06t75ruj","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gka008vlktvg1u1gzvn"},{"post_id":"ck5m75gi1001glktvwiya2ahq","category_id":"ck5m75gj1004hlktvivwo3pdp","_id":"ck5m75gkb0092lktv1x2ixzto"},{"post_id":"ck5m75gi1001glktvwiya2ahq","category_id":"ck5m75gka008ulktvggzfrcbr","_id":"ck5m75gkc0095lktvb1fnl5dm"},{"post_id":"ck5m75gi2001ilktv4zy0jhe4","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gke009dlktveu75n8gd"},{"post_id":"ck5m75gi2001ilktv4zy0jhe4","category_id":"ck5m75gkc0096lktvdnnkk166","_id":"ck5m75gke009flktvpgnq2rqx"},{"post_id":"ck5m75gjc0059lktv6ghypk2b","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkf009jlktvkhc9e8uw"},{"post_id":"ck5m75gjc0059lktv6ghypk2b","category_id":"ck5m75gkd009clktv0d0o0d3j","_id":"ck5m75gkf009mlktvqz09gd3d"},{"post_id":"ck5m75gje005elktv5p6gh01i","category_id":"ck5m75gjs006blktvxpfub3k3","_id":"ck5m75gkh009xlktvg6gf19sm"},{"post_id":"ck5m75gjf005flktvy70v104w","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gki00a2lktvq52iviud"},{"post_id":"ck5m75gjf005flktvy70v104w","category_id":"ck5m75gkf009klktvxlqt4t51","_id":"ck5m75gki00a5lktvou54hrq5"},{"post_id":"ck5m75gjg005ilktvuxjxe10r","category_id":"ck5m75gkh009ylktvkbtcmdx8","_id":"ck5m75gki00a7lktv5yc7i98x"},{"post_id":"ck5m75gi7001wlktv89xzkwu0","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkj00aelktvak352yia"},{"post_id":"ck5m75gi7001wlktv89xzkwu0","category_id":"ck5m75gki00a6lktvg9vjv1hw","_id":"ck5m75gkk00ahlktv3gzdkf6k"},{"post_id":"ck5m75gjk005tlktvqgz0a8hy","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkk00ailktvev79mi3p"},{"post_id":"ck5m75gjk005tlktvqgz0a8hy","category_id":"ck5m75gkj00ablktvkz43mf5u","_id":"ck5m75gkl00allktvmrf6m7sd"},{"post_id":"ck5m75gjl005vlktvszkuz96s","category_id":"ck5m75gj1004hlktvivwo3pdp","_id":"ck5m75gkl00amlktvx6xg1t9d"},{"post_id":"ck5m75gjl005vlktvszkuz96s","category_id":"ck5m75gkk00aglktvbjd2sgww","_id":"ck5m75gkl00aqlktvac76pe8u"},{"post_id":"ck5m75gi90023lktvr7jimmq9","category_id":"ck5m75gjm005wlktvtwp3dqjm","_id":"ck5m75gkm00atlktvtsvsofyi"},{"post_id":"ck5m75gi90023lktvr7jimmq9","category_id":"ck5m75gkk00aklktv76h59ly4","_id":"ck5m75gkm00awlktviykmixv6"},{"post_id":"ck5m75gia0026lktv35ddnwzr","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkm00aylktvmo0dcwfk"},{"post_id":"ck5m75gia0026lktv35ddnwzr","category_id":"ck5m75gkl00aolktvjhesjbsf","_id":"ck5m75gkn00b1lktvcny4vo4r"},{"post_id":"ck5m75gic002alktvxf0z3qxy","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gkn00b4lktva10zm0gq"},{"post_id":"ck5m75gic002alktvxf0z3qxy","category_id":"ck5m75gkm00aulktv8emhrsa3","_id":"ck5m75gkn00b6lktvb8bkpsm7"},{"post_id":"ck5m75gim003alktv1pr5dp4w","category_id":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gkp00belktvuhzi7ojq"},{"post_id":"ck5m75gim003alktv1pr5dp4w","category_id":"ck5m75gko00b8lktvpl5hwscp","_id":"ck5m75gkp00bglktvwm8fbb1l"},{"post_id":"ck5m75gio003hlktvpgauncnv","category_id":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gkr00bklktv9mi82a3d"},{"post_id":"ck5m75gio003hlktvpgauncnv","category_id":"ck5m75gko00bclktvj9almpx5","_id":"ck5m75gkr00bmlktv2a9e4m5c"},{"post_id":"ck5m75giq003plktvm50dr6ay","category_id":"ck5m75gjf005glktv5ppikq2e","_id":"ck5m75gks00bslktv8qp7qb8v"},{"post_id":"ck5m75giq003plktvm50dr6ay","category_id":"ck5m75gkq00bjlktv4wfxo82k","_id":"ck5m75gks00bwlktvud1tovvl"},{"post_id":"ck5m75gir003tlktv30soukyt","category_id":"ck5m75gk2007glktv9hbgeovo","_id":"ck5m75gks00bxlktvxs1ibrmj"},{"post_id":"ck5m75gir003tlktv30soukyt","category_id":"ck5m75gkr00bplktvsmt2nqi4","_id":"ck5m75gkt00c0lktvswm1wan0"},{"post_id":"ck5m75git003wlktv7kd52cp3","category_id":"ck5m75gk2007glktv9hbgeovo","_id":"ck5m75gkt00c2lktvgmagt97f"},{"post_id":"ck5m75git003wlktv7kd52cp3","category_id":"ck5m75gks00btlktvgxs247et","_id":"ck5m75gku00c6lktvs7njb9e1"},{"post_id":"ck5m75giy0047lktvg0vvdke2","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gku00cclktvg8javvvb"},{"post_id":"ck5m75giy0047lktvg0vvdke2","category_id":"ck5m75gkt00c4lktvob5gb0tx","_id":"ck5m75gkv00celktvybimdmss"},{"post_id":"ck5m75giz004blktv8zt71mlm","category_id":"ck5m75gk5007wlktvhcts5zxl","_id":"ck5m75gkv00chlktvtrbapdvq"},{"post_id":"ck5m75giz004blktv8zt71mlm","category_id":"ck5m75gku00c8lktvu53jmqgy","_id":"ck5m75gkv00cilktvuvwwe0fj"},{"post_id":"ck5m75gj1004jlktvrngpmvum","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkw00cplktvf12em9ar"},{"post_id":"ck5m75gj1004jlktvrngpmvum","category_id":"ck5m75gkv00cglktvymne60c1","_id":"ck5m75gkx00crlktveode4ntd"},{"post_id":"ck5m75gj2004mlktvoizllwkd","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gkx00cvlktv59zrvlp5"},{"post_id":"ck5m75gj2004mlktvoizllwkd","category_id":"ck5m75gkv00cglktvymne60c1","_id":"ck5m75gkx00cwlktvrm7x3u00"},{"post_id":"ck5m75gj3004qlktvhqpjd97j","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gky00cylktvv5a6xesi"},{"post_id":"ck5m75gj3004qlktvhqpjd97j","category_id":"ck5m75gkv00cglktvymne60c1","_id":"ck5m75gky00d1lktvkpfqwfvq"},{"post_id":"ck5m75gj7004zlktvkwg79tac","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl000d7lktv5aqbn355"},{"post_id":"ck5m75gj7004zlktvkwg79tac","category_id":"ck5m75gks00bylktvpthoaz4y","_id":"ck5m75gl000d9lktvxfh6p8wa"},{"post_id":"ck5m75gj80052lktv9yaabprg","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl000dclktvbe37h1cj"},{"post_id":"ck5m75gj80052lktv9yaabprg","category_id":"ck5m75gkv00cglktvymne60c1","_id":"ck5m75gl000delktv065cwwng"},{"post_id":"ck5m75gja0054lktv3xous43n","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl100dglktvoe1rmmz5"},{"post_id":"ck5m75gja0054lktv3xous43n","category_id":"ck5m75gkz00d6lktv5m548zs0","_id":"ck5m75gl100djlktvcqzbgcfk"},{"post_id":"ck5m75gjb0055lktvnryh3zwu","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl100dmlktv9ly9kli2"},{"post_id":"ck5m75gjb0055lktvnryh3zwu","category_id":"ck5m75gl000ddlktvfhqjiz46","_id":"ck5m75gl200dolktvu9mqsn0f"},{"post_id":"ck5m75gi3001nlktva2kj9x4n","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gl200dqlktvtoti507v"},{"post_id":"ck5m75gi3001nlktva2kj9x4n","category_id":"ck5m75gke009hlktvk827rs1f","_id":"ck5m75gl200dtlktvd3bkkdav"},{"post_id":"ck5m75gi3001nlktva2kj9x4n","category_id":"ck5m75gl100dhlktvyxosedu9","_id":"ck5m75gl300dwlktvqfxd4m9o"},{"post_id":"ck5m75gjd005blktv6nu1m35c","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gl300dzlktv6dbdhlbu"},{"post_id":"ck5m75gjd005blktv6nu1m35c","category_id":"ck5m75gkf009klktvxlqt4t51","_id":"ck5m75gl300e2lktv73g2uqc4"},{"post_id":"ck5m75gjd005blktv6nu1m35c","category_id":"ck5m75gl100dnlktve4vjhmgw","_id":"ck5m75gl300e4lktvjfbfkgn8"},{"post_id":"ck5m75gi4001plktvgvg3gg82","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gl400e5lktveg4trgyl"},{"post_id":"ck5m75gi4001plktvgvg3gg82","category_id":"ck5m75gke009hlktvk827rs1f","_id":"ck5m75gl400e9lktv8qtvbzer"},{"post_id":"ck5m75gi4001plktvgvg3gg82","category_id":"ck5m75gl100dhlktvyxosedu9","_id":"ck5m75gl400eblktvi5j0euxu"},{"post_id":"ck5m75gji005olktvfbxbyhz7","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl500eflktvy3sl11dv"},{"post_id":"ck5m75gji005olktvfbxbyhz7","category_id":"ck5m75gl300dxlktvhasy4hyg","_id":"ck5m75gl500ehlktvgoll2uyo"},{"post_id":"ck5m75gie002glktvzjy48kmq","category_id":"ck5m75gj3004plktvbjuyneih","_id":"ck5m75gl600ellktvhdoh5ung"},{"post_id":"ck5m75gie002glktvzjy48kmq","category_id":"ck5m75gkn00azlktvsi31huai","_id":"ck5m75gl600enlktvlcvqt375"},{"post_id":"ck5m75gie002glktvzjy48kmq","category_id":"ck5m75gl300e3lktvb7mif0t3","_id":"ck5m75gl600eplktv9mpdrzin"},{"post_id":"ck5m75gii002vlktvwxl7tk5w","category_id":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gl700eslktvsdyzbuxv"},{"post_id":"ck5m75gii002vlktvwxl7tk5w","category_id":"ck5m75gkn00b5lktvymeveawn","_id":"ck5m75gl700eulktve72655o1"},{"post_id":"ck5m75gii002vlktvwxl7tk5w","category_id":"ck5m75gl400e7lktvvv1yy68h","_id":"ck5m75gl700ewlktvij7y1q63"},{"post_id":"ck5m75gip003mlktv2o2luhqm","category_id":"ck5m75gju006jlktvqe5w0qy7","_id":"ck5m75gl800eylktvwszeuf44"},{"post_id":"ck5m75gip003mlktv2o2luhqm","category_id":"ck5m75gkn00b5lktvymeveawn","_id":"ck5m75gl800f0lktvkhqqidrf"},{"post_id":"ck5m75gip003mlktv2o2luhqm","category_id":"ck5m75gl400e7lktvvv1yy68h","_id":"ck5m75gl800f3lktvnht4nvpc"},{"post_id":"ck5m75gix0044lktvv6dpkysu","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75gl800f4lktv5miyjq4y"},{"post_id":"ck5m75gix0044lktvv6dpkysu","category_id":"ck5m75gks00bylktvpthoaz4y","_id":"ck5m75gl900f6lktv3wqh4oe4"},{"post_id":"ck5m75gix0044lktvv6dpkysu","category_id":"ck5m75gl600eklktvejhxquky","_id":"ck5m75gl900f8lktvcceuzkuz"},{"post_id":"ck5m75giz004elktvhlxzxtvn","category_id":"ck5m75gk5007wlktvhcts5zxl","_id":"ck5m75gla00fblktvpfmuo17p"},{"post_id":"ck5m75giz004elktvhlxzxtvn","category_id":"ck5m75gku00c8lktvu53jmqgy","_id":"ck5m75gla00fdlktv4r0depqo"},{"post_id":"ck5m75giz004elktvhlxzxtvn","category_id":"ck5m75gl600erlktv50fxojf8","_id":"ck5m75gla00fflktvmcb338q4"},{"post_id":"ck5m75gj4004tlktvbsv0axlw","category_id":"ck5m75gjn0060lktvzwysrb47","_id":"ck5m75glb00fhlktv6wm6296s"},{"post_id":"ck5m75gj4004tlktvbsv0axlw","category_id":"ck5m75gkx00culktvlp2bjeg4","_id":"ck5m75glb00fjlktvlq9v4dq2"},{"post_id":"ck5m75gj4004tlktvbsv0axlw","category_id":"ck5m75gl700evlktv1mm3cjae","_id":"ck5m75glb00fklktvnbu28yia"}],"PostTag":[{"post_id":"ck5m75gh70002lktvk4aan9gm","tag_id":"ck5m75ghe0006lktvvha3kt7p","_id":"ck5m75ghn000ilktv4rnp1gq8"},{"post_id":"ck5m75gh70002lktvk4aan9gm","tag_id":"ck5m75ghj000clktvq0vmb3f0","_id":"ck5m75gho000klktvidqu7h52"},{"post_id":"ck5m75gha0004lktv8u0xikyv","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75ghs000slktvgf35xxi7"},{"post_id":"ck5m75gha0004lktv8u0xikyv","tag_id":"ck5m75gho000mlktvt9j53y23","_id":"ck5m75ght000vlktvpr2l7ook"},{"post_id":"ck5m75ghe0008lktv3jy65u90","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75ghx0014lktvrqqbd27i"},{"post_id":"ck5m75ghe0008lktv3jy65u90","tag_id":"ck5m75ght000wlktvvy090lj4","_id":"ck5m75ghy0017lktvexav8y47"},{"post_id":"ck5m75ghh0009lktvnkwg064w","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gi2001hlktvpj0ag05w"},{"post_id":"ck5m75ghh0009lktvnkwg064w","tag_id":"ck5m75ghz0019lktvf53glk5s","_id":"ck5m75gi3001klktvxkodsxjg"},{"post_id":"ck5m75ghi000alktvcf92yx25","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gi7001vlktvcr2x4cmy"},{"post_id":"ck5m75ghi000alktvcf92yx25","tag_id":"ck5m75gi3001mlktvayya39rn","_id":"ck5m75gi8001xlktvi9kyjf5y"},{"post_id":"ck5m75ghj000dlktvk97rl68l","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gib0028lktv91rtloem"},{"post_id":"ck5m75ghj000dlktvk97rl68l","tag_id":"ck5m75gi8001zlktv818wvazk","_id":"ck5m75gic002blktvkitkhzrp"},{"post_id":"ck5m75ghk000elktvxkhx5c61","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gig002mlktvvwwtztxh"},{"post_id":"ck5m75ghk000elktvxkhx5c61","tag_id":"ck5m75gid002clktv03c40buq","_id":"ck5m75gig002plktvxzemb97g"},{"post_id":"ck5m75gig002nlktvtgk3xx0m","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gii002ulktvuma8n1yq"},{"post_id":"ck5m75ghm000hlktv1yeoiao4","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gii002xlktv3bjtdn9y"},{"post_id":"ck5m75ghm000hlktv1yeoiao4","tag_id":"ck5m75gif002jlktvqzn0pv67","_id":"ck5m75gij0031lktvustjwft2"},{"post_id":"ck5m75ghn000jlktvfk5v421x","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gik0035lktvryh2mqof"},{"post_id":"ck5m75ghn000jlktvfk5v421x","tag_id":"ck5m75gih002rlktvq02igfi7","_id":"ck5m75gil0039lktvy8ocjb8v"},{"post_id":"ck5m75ghp000nlktv4nfgv663","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gim003dlktveqpzmya1"},{"post_id":"ck5m75ghp000nlktv4nfgv663","tag_id":"ck5m75gij0030lktv222fkswk","_id":"ck5m75gio003glktv2u0r9kq1"},{"post_id":"ck5m75ghq000olktv4vhpipq7","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gip003llktvwkabul2g"},{"post_id":"ck5m75ghq000olktv4vhpipq7","tag_id":"ck5m75gil0038lktvs7ug8ckx","_id":"ck5m75giq003olktvk3jpd3wf"},{"post_id":"ck5m75ghr000rlktvptxih8y4","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gis003ulktvoi3yk5d3"},{"post_id":"ck5m75ghr000rlktvptxih8y4","tag_id":"ck5m75gio003ilktvdx78n8sb","_id":"ck5m75giv003xlktvniskrzaf"},{"post_id":"ck5m75ght000xlktv2zcbbedp","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75giw0042lktviaprahdg"},{"post_id":"ck5m75ght000xlktv2zcbbedp","tag_id":"ck5m75giq003qlktv46vca8sm","_id":"ck5m75gix0045lktvf2wf7jr3"},{"post_id":"ck5m75ghu000ylktvd82jtisy","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75giy004alktv5dloqmna"},{"post_id":"ck5m75ghu000ylktvd82jtisy","tag_id":"ck5m75giv003ylktvgr6asiww","_id":"ck5m75giz004dlktv730qldvt"},{"post_id":"ck5m75ghv0011lktvv8cj14jq","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gj1004ilktvhgr4ey09"},{"post_id":"ck5m75ghv0011lktvv8cj14jq","tag_id":"ck5m75gix0046lktvzmcunnxi","_id":"ck5m75gj2004llktvz9hj1u76"},{"post_id":"ck5m75ghx0015lktv8b5c5arg","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gj4004rlktvwnk97smi"},{"post_id":"ck5m75ghx0015lktv8b5c5arg","tag_id":"ck5m75gj0004flktvrcofobag","_id":"ck5m75gj5004ulktvhtdiohty"},{"post_id":"ck5m75ghy0018lktvmipseua6","tag_id":"ck5m75ghl000glktvzsj1ajl7","_id":"ck5m75gj7004ylktvzxaf8djg"},{"post_id":"ck5m75ghy0018lktvmipseua6","tag_id":"ck5m75gj3004nlktvb7seo5x1","_id":"ck5m75gj70050lktvxcco11b7"},{"post_id":"ck5m75ghz001alktvjrbdm9jd","tag_id":"ck5m75gj5004vlktviqwxfm8h","_id":"ck5m75gjc0058lktvtlzt64ij"},{"post_id":"ck5m75ghz001alktvjrbdm9jd","tag_id":"ck5m75gj80051lktvrgdbb0a8","_id":"ck5m75gjd005alktvc86whh3n"},{"post_id":"ck5m75gi0001clktvqdkacv57","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gjh005jlktvm2cnjs2l"},{"post_id":"ck5m75gi0001clktvqdkacv57","tag_id":"ck5m75gje005dlktvxbkxggnj","_id":"ck5m75gji005mlktv9nx8u7pm"},{"post_id":"ck5m75gi1001glktvwiya2ahq","tag_id":"ck5m75gj5004vlktviqwxfm8h","_id":"ck5m75gjl005ulktvxr2obwnx"},{"post_id":"ck5m75gi1001glktvwiya2ahq","tag_id":"ck5m75gji005nlktv9i6sgqi4","_id":"ck5m75gjm005xlktvg5l7fwsw"},{"post_id":"ck5m75gi2001ilktv4zy0jhe4","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gjo0062lktv2piic5hf"},{"post_id":"ck5m75gi2001ilktv4zy0jhe4","tag_id":"ck5m75gjm005ylktvr8wgw00d","_id":"ck5m75gjo0063lktvl2ymvnki"},{"post_id":"ck5m75gi3001nlktva2kj9x4n","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gjs006alktvur8dd2m4"},{"post_id":"ck5m75gi3001nlktva2kj9x4n","tag_id":"ck5m75gjo0065lktvst1n61wn","_id":"ck5m75gjs006dlktvuxvr8iyd"},{"post_id":"ck5m75gi3001nlktva2kj9x4n","tag_id":"ck5m75gjp0067lktvsjyemjy7","_id":"ck5m75gjs006flktvthnbbu06"},{"post_id":"ck5m75gi4001plktvgvg3gg82","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gju006llktvas8h6num"},{"post_id":"ck5m75gi4001plktvgvg3gg82","tag_id":"ck5m75gjo0065lktvst1n61wn","_id":"ck5m75gju006mlktvt2nzxvji"},{"post_id":"ck5m75gi4001plktvgvg3gg82","tag_id":"ck5m75gjp0067lktvsjyemjy7","_id":"ck5m75gjv006qlktvofq6hjol"},{"post_id":"ck5m75gi6001tlktvwgpqjbp7","tag_id":"ck5m75gju006klktvv353trhi","_id":"ck5m75gjw006tlktvkbhv59te"},{"post_id":"ck5m75gi6001tlktvwgpqjbp7","tag_id":"ck5m75gju006plktvugoxfk5j","_id":"ck5m75gjx006wlktviacwlsw3"},{"post_id":"ck5m75gi7001wlktv89xzkwu0","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gjy0071lktvmclfrpyb"},{"post_id":"ck5m75gi7001wlktv89xzkwu0","tag_id":"ck5m75gjx006xlktvnuet5hdx","_id":"ck5m75gjz0074lktvmetmqy7e"},{"post_id":"ck5m75gi80021lktv7r5me15q","tag_id":"ck5m75gjy0070lktvzf0mnpwq","_id":"ck5m75gjz0076lktvkhejcpc4"},{"post_id":"ck5m75gi90023lktvr7jimmq9","tag_id":"ck5m75gjz0075lktvagmr2oc4","_id":"ck5m75gk1007dlktvmqzljsv7"},{"post_id":"ck5m75gi90023lktvr7jimmq9","tag_id":"ck5m75gk00078lktvsh2ytmjf","_id":"ck5m75gk1007elktvvzas0594"},{"post_id":"ck5m75gia0026lktv35ddnwzr","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gk2007jlktvj6z6h477"},{"post_id":"ck5m75gia0026lktv35ddnwzr","tag_id":"ck5m75gk1007flktv8pgonkvs","_id":"ck5m75gk3007klktvquyg7a1c"},{"post_id":"ck5m75gic002alktvxf0z3qxy","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gk3007nlktvdqps41ll"},{"post_id":"ck5m75gic002alktvxf0z3qxy","tag_id":"ck5m75ghj000clktvq0vmb3f0","_id":"ck5m75gk3007olktvu630lyyp"},{"post_id":"ck5m75gid002dlktvrqfr81nt","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gk4007rlktvrcfs4fvf"},{"post_id":"ck5m75gie002glktvzjy48kmq","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gk5007zlktvzs7u92ft"},{"post_id":"ck5m75gie002glktvzjy48kmq","tag_id":"ck5m75gk4007slktv4q4u5v9x","_id":"ck5m75gk50080lktveqd8w1kt"},{"post_id":"ck5m75gie002glktvzjy48kmq","tag_id":"ck5m75gk4007vlktvl40qjvs0","_id":"ck5m75gk60083lktv11p65zj6"},{"post_id":"ck5m75gie002ilktvwb60j5xt","tag_id":"ck5m75gk5007xlktvxv4mzq22","_id":"ck5m75gk60084lktv8h7fe3ru"},{"post_id":"ck5m75gig002qlktv2saj50q1","tag_id":"ck5m75gjz0075lktvagmr2oc4","_id":"ck5m75gk70089lktvdxqmojmp"},{"post_id":"ck5m75gig002qlktv2saj50q1","tag_id":"ck5m75gj5004vlktviqwxfm8h","_id":"ck5m75gk7008alktv2u9tzs6t"},{"post_id":"ck5m75gii002vlktvwxl7tk5w","tag_id":"ck5m75gk70087lktvwf5bhk4y","_id":"ck5m75gk8008jlktvedzhdwq2"},{"post_id":"ck5m75gii002vlktvwxl7tk5w","tag_id":"ck5m75gk7008blktv5vs1jphi","_id":"ck5m75gk8008klktv36osgpzy"},{"post_id":"ck5m75gii002vlktvwxl7tk5w","tag_id":"ck5m75gk8008flktvqvwztgrw","_id":"ck5m75gk9008nlktvg5r88bcf"},{"post_id":"ck5m75gij002ylktv0xcbvj5w","tag_id":"ck5m75gk8008ilktv5r7vbglv","_id":"ck5m75gk9008olktv80gf7koq"},{"post_id":"ck5m75gik0032lktv1p1uuhwb","tag_id":"ck5m75gk70087lktvwf5bhk4y","_id":"ck5m75gka008tlktvhsk1r21q"},{"post_id":"ck5m75gil0036lktv68pfze8k","tag_id":"ck5m75gk70087lktvwf5bhk4y","_id":"ck5m75gkb008xlktvv78f4jox"},{"post_id":"ck5m75gim003alktv1pr5dp4w","tag_id":"ck5m75gk70087lktvwf5bhk4y","_id":"ck5m75gkb0090lktvu4msoep6"},{"post_id":"ck5m75gin003elktvd3ryz5ql","tag_id":"ck5m75gk70087lktvwf5bhk4y","_id":"ck5m75gkc0094lktvxpx0gw04"},{"post_id":"ck5m75gio003hlktvpgauncnv","tag_id":"ck5m75gk70087lktvwf5bhk4y","_id":"ck5m75gkd009alktvkyifk6g5"},{"post_id":"ck5m75gio003hlktvpgauncnv","tag_id":"ck5m75gkc0097lktvee7mwn3b","_id":"ck5m75gkd009blktvvdkew9hz"},{"post_id":"ck5m75gip003mlktv2o2luhqm","tag_id":"ck5m75gk70087lktvwf5bhk4y","_id":"ck5m75gkf009llktvv9jngdz1"},{"post_id":"ck5m75gip003mlktv2o2luhqm","tag_id":"ck5m75gk7008blktv5vs1jphi","_id":"ck5m75gkf009nlktvwck97gt5"},{"post_id":"ck5m75gip003mlktv2o2luhqm","tag_id":"ck5m75gk8008flktvqvwztgrw","_id":"ck5m75gkf009qlktvrey04dme"},{"post_id":"ck5m75giq003plktvm50dr6ay","tag_id":"ck5m75gkf009ilktv1wyup2hn","_id":"ck5m75gkg009tlktvgyjzu86a"},{"post_id":"ck5m75giq003plktvm50dr6ay","tag_id":"ck5m75gkf009olktv01z40gtc","_id":"ck5m75gkg009ulktvdhnw0m3e"},{"post_id":"ck5m75gir003tlktv30soukyt","tag_id":"ck5m75gk00078lktvsh2ytmjf","_id":"ck5m75gkh00a0lktvqojlcwjt"},{"post_id":"ck5m75gir003tlktv30soukyt","tag_id":"ck5m75gkg009vlktv3n3vxpbh","_id":"ck5m75gkh00a1lktvktm82cu8"},{"post_id":"ck5m75git003wlktv7kd52cp3","tag_id":"ck5m75gk00078lktvsh2ytmjf","_id":"ck5m75gkj00a9lktvz8u9qopl"},{"post_id":"ck5m75git003wlktv7kd52cp3","tag_id":"ck5m75gki00a3lktv9400ct1m","_id":"ck5m75gkj00aalktv5s3fx2qn"},{"post_id":"ck5m75giw0040lktv5b7g9t25","tag_id":"ck5m75gki00a8lktva58twquv","_id":"ck5m75gkj00adlktvi2kssdb2"},{"post_id":"ck5m75gix0044lktvv6dpkysu","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gkl00aplktv5k2lgqrk"},{"post_id":"ck5m75gix0044lktvv6dpkysu","tag_id":"ck5m75gkj00aflktv7d4wvm3w","_id":"ck5m75gkl00arlktvb21xa9ib"},{"post_id":"ck5m75gix0044lktvv6dpkysu","tag_id":"ck5m75gkk00ajlktv8h873jty","_id":"ck5m75gkm00avlktv7lgicpo1"},{"post_id":"ck5m75giy0047lktvg0vvdke2","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gkn00b0lktvtvbkf2cc"},{"post_id":"ck5m75giy0047lktvg0vvdke2","tag_id":"ck5m75gkl00aslktvpcn0tf79","_id":"ck5m75gkn00b2lktvx5rydq97"},{"post_id":"ck5m75giz004blktv8zt71mlm","tag_id":"ck5m75gkm00axlktvqcdwdzxk","_id":"ck5m75gko00b9lktvtnwvlbhc"},{"post_id":"ck5m75giz004blktv8zt71mlm","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gko00balktvjwlgse7g"},{"post_id":"ck5m75giz004elktvhlxzxtvn","tag_id":"ck5m75gkm00axlktvqcdwdzxk","_id":"ck5m75gkq00bilktvq35pajn5"},{"post_id":"ck5m75giz004elktvhlxzxtvn","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gkr00bllktvpynbbn00"},{"post_id":"ck5m75giz004elktvhlxzxtvn","tag_id":"ck5m75gkp00bdlktvkuq1ucu6","_id":"ck5m75gkr00bolktvttxvmsjp"},{"post_id":"ck5m75gj1004jlktvrngpmvum","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gks00brlktvkgxjux80"},{"post_id":"ck5m75gj1004jlktvrngpmvum","tag_id":"ck5m75gkp00bdlktvkuq1ucu6","_id":"ck5m75gks00bulktvzlg4wdaf"},{"post_id":"ck5m75gj2004mlktvoizllwkd","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gkt00c1lktvvbr9kt70"},{"post_id":"ck5m75gj2004mlktvoizllwkd","tag_id":"ck5m75gkp00bdlktvkuq1ucu6","_id":"ck5m75gkt00c3lktvod7bsle9"},{"post_id":"ck5m75gj3004qlktvhqpjd97j","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gku00c9lktvz2rg9cjq"},{"post_id":"ck5m75gj3004qlktvhqpjd97j","tag_id":"ck5m75gkp00bdlktvkuq1ucu6","_id":"ck5m75gku00calktvpji37d6l"},{"post_id":"ck5m75gj4004tlktvbsv0axlw","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gkw00cllktvi1sqcyl4"},{"post_id":"ck5m75gj4004tlktvbsv0axlw","tag_id":"ck5m75gku00cblktvoqjuk9za","_id":"ck5m75gkw00cmlktv1pvrdms1"},{"post_id":"ck5m75gj4004tlktvbsv0axlw","tag_id":"ck5m75gkv00cflktvp1sqmk3e","_id":"ck5m75gkx00cqlktvdkqqld7c"},{"post_id":"ck5m75gj5004wlktv06t75ruj","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gkx00cslktv0acakoho"},{"post_id":"ck5m75gj7004zlktvkwg79tac","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gky00d0lktv223cfnuw"},{"post_id":"ck5m75gj7004zlktvkwg79tac","tag_id":"ck5m75gkj00aflktv7d4wvm3w","_id":"ck5m75gky00d2lktv455mhwa3"},{"post_id":"ck5m75gj80052lktv9yaabprg","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gl000d8lktvgb1gzrr4"},{"post_id":"ck5m75gj80052lktv9yaabprg","tag_id":"ck5m75gkp00bdlktvkuq1ucu6","_id":"ck5m75gl000dalktvccu7xch0"},{"post_id":"ck5m75gja0054lktv3xous43n","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gl100dilktvfo9wzx6a"},{"post_id":"ck5m75gja0054lktv3xous43n","tag_id":"ck5m75gl000dblktvdlef67lq","_id":"ck5m75gl100dklktvbkgutdn1"},{"post_id":"ck5m75gjb0055lktvnryh3zwu","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gl200drlktvar5h27y5"},{"post_id":"ck5m75gjb0055lktvnryh3zwu","tag_id":"ck5m75gl100dllktvr3l9vwdu","_id":"ck5m75gl200dulktvov8s36mp"},{"post_id":"ck5m75gjc0059lktv6ghypk2b","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gl300dylktvurphh3d1"},{"post_id":"ck5m75gjc0059lktv6ghypk2b","tag_id":"ck5m75gl200dplktvce4kbaow","_id":"ck5m75gl300e0lktv6309xzqw"},{"post_id":"ck5m75gjd005blktv6nu1m35c","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gl400e8lktv84r68eo4"},{"post_id":"ck5m75gjd005blktv6nu1m35c","tag_id":"ck5m75gl200dvlktvycmn6lmi","_id":"ck5m75gl400ealktvwtpxz20k"},{"post_id":"ck5m75gjd005blktv6nu1m35c","tag_id":"ck5m75gl300e1lktv5wqq3g4p","_id":"ck5m75gl500edlktvtrnwazpf"},{"post_id":"ck5m75gje005elktv5p6gh01i","tag_id":"ck5m75gk5007xlktvxv4mzq22","_id":"ck5m75gl500eglktv16r4xq4q"},{"post_id":"ck5m75gjf005flktvy70v104w","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gl600ejlktvgr0z15oe"},{"post_id":"ck5m75gjf005flktvy70v104w","tag_id":"ck5m75gl200dvlktvycmn6lmi","_id":"ck5m75gl600emlktvc2jbp9dx"},{"post_id":"ck5m75gjg005ilktvuxjxe10r","tag_id":"ck5m75gl500eilktvtvzxwyze","_id":"ck5m75gl600eqlktvgqekfsax"},{"post_id":"ck5m75gjh005klktvy7pk08d4","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gl800ezlktvj5m9sr3c"},{"post_id":"ck5m75gjh005klktvy7pk08d4","tag_id":"ck5m75gkp00bdlktvkuq1ucu6","_id":"ck5m75gl800f1lktvgl3d4bn5"},{"post_id":"ck5m75gji005olktvfbxbyhz7","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gl900f7lktvifdsu7b1"},{"post_id":"ck5m75gji005olktvfbxbyhz7","tag_id":"ck5m75gl800f2lktv3pbahqbx","_id":"ck5m75gl900f9lktvjjic470a"},{"post_id":"ck5m75gjk005tlktvqgz0a8hy","tag_id":"ck5m75gjb0057lktv2k0fs372","_id":"ck5m75gla00fclktvtqkmrx9e"},{"post_id":"ck5m75gjk005tlktvqgz0a8hy","tag_id":"ck5m75gk1007blktv8rp30enz","_id":"ck5m75gla00felktvkoflf74f"},{"post_id":"ck5m75gjl005vlktvszkuz96s","tag_id":"ck5m75gj5004vlktviqwxfm8h","_id":"ck5m75gla00fglktv9lk4q6br"},{"post_id":"ck5m75gjl005vlktvszkuz96s","tag_id":"ck5m75gla00falktvxgrv4uw1","_id":"ck5m75glb00filktvau0e5c8d"}],"Tag":[{"name":"ES5","_id":"ck5m75ghe0006lktvvha3kt7p"},{"name":"继承","_id":"ck5m75ghj000clktvq0vmb3f0"},{"name":"ES6","_id":"ck5m75ghl000glktvzsj1ajl7"},{"name":"Decorator","_id":"ck5m75gho000mlktvt9j53y23"},{"name":"Generator","_id":"ck5m75ght000wlktvvy090lj4"},{"name":"Iterator","_id":"ck5m75ghz0019lktvf53glk5s"},{"name":"Proxy和Reflect","_id":"ck5m75gi3001mlktvayya39rn"},{"name":"Symbol","_id":"ck5m75gi8001zlktv818wvazk"},{"name":"Promise","_id":"ck5m75gid002clktv03c40buq"},{"name":"函数扩展","_id":"ck5m75gif002jlktvqzn0pv67"},{"name":"字符串扩展","_id":"ck5m75gih002rlktvq02igfi7"},{"name":"对象扩展","_id":"ck5m75gij0030lktv222fkswk"},{"name":"数值扩展","_id":"ck5m75gil0038lktvs7ug8ckx"},{"name":"数据结构","_id":"ck5m75gio003ilktvdx78n8sb"},{"name":"数组扩展","_id":"ck5m75giq003qlktv46vca8sm"},{"name":"模块化","_id":"ck5m75giv003ylktvgr6asiww"},{"name":"正则扩展","_id":"ck5m75gix0046lktvzmcunnxi"},{"name":"类","_id":"ck5m75gj0004flktvrcofobag"},{"name":"解构赋值","_id":"ck5m75gj3004nlktvb7seo5x1"},{"name":"javascript","_id":"ck5m75gj5004vlktviqwxfm8h"},{"name":"Function","_id":"ck5m75gj80051lktvrgdbb0a8"},{"name":"js","_id":"ck5m75gjb0057lktv2k0fs372"},{"name":"MVVM","_id":"ck5m75gje005dlktvxbkxggnj"},{"name":"Object","_id":"ck5m75gji005nlktv9i6sgqi4"},{"name":"react","_id":"ck5m75gjm005ylktvr8wgw00d"},{"name":"React","_id":"ck5m75gjo0065lktvst1n61wn"},{"name":"component","_id":"ck5m75gjp0067lktvsjyemjy7"},{"name":"闲杂","_id":"ck5m75gju006klktvv353trhi"},{"name":"Install","_id":"ck5m75gju006plktvugoxfk5j"},{"name":"async-await","_id":"ck5m75gjx006xlktvnuet5hdx"},{"name":"http","_id":"ck5m75gjy0070lktvzf0mnpwq"},{"name":"html","_id":"ck5m75gjz0075lktvagmr2oc4"},{"name":"css","_id":"ck5m75gk00078lktvsh2ytmjf"},{"name":"vue","_id":"ck5m75gk1007blktv8rp30enz"},{"name":"ie","_id":"ck5m75gk1007flktv8pgonkvs"},{"name":"设计模式","_id":"ck5m75gk4007slktv4q4u5v9x"},{"name":"面向对象","_id":"ck5m75gk4007vlktvl40qjvs0"},{"name":"数组和对象的深度复制","_id":"ck5m75gk5007xlktvxv4mzq22"},{"name":"node.js","_id":"ck5m75gk70087lktvwf5bhk4y"},{"name":"mongodb","_id":"ck5m75gk7008blktv5vs1jphi"},{"name":"mongoose","_id":"ck5m75gk8008flktvqvwztgrw"},{"name":"install","_id":"ck5m75gk8008ilktv5r7vbglv"},{"name":"加密方式","_id":"ck5m75gkc0097lktvee7mwn3b"},{"name":"安装","_id":"ck5m75gkf009ilktv1wyup2hn"},{"name":"nvm","_id":"ck5m75gkf009olktv01z40gtc"},{"name":"sass","_id":"ck5m75gkg009vlktv3n3vxpbh"},{"name":"scss","_id":"ck5m75gki00a3lktv9400ct1m"},{"name":"sublime","_id":"ck5m75gki00a8lktva58twquv"},{"name":"vue-awesome-swiper","_id":"ck5m75gkj00aflktv7d4wvm3w"},{"name":"swiper","_id":"ck5m75gkk00ajlktv8h873jty"},{"name":"vue-cli3.0","_id":"ck5m75gkl00aslktvpcn0tf79"},{"name":"总结","_id":"ck5m75gkm00axlktvqcdwdzxk"},{"name":"vuex","_id":"ck5m75gkp00bdlktvkuq1ucu6"},{"name":"axios","_id":"ck5m75gku00cblktvoqjuk9za"},{"name":"ajax","_id":"ck5m75gkv00cflktvp1sqmk3e"},{"name":"vue-router","_id":"ck5m75gl000dblktvdlef67lq"},{"name":"webpack","_id":"ck5m75gl100dllktvr3l9vwdu"},{"name":"事件","_id":"ck5m75gl200dplktvce4kbaow"},{"name":"数组和字符串","_id":"ck5m75gl200dvlktvycmn6lmi"},{"name":"字符串","_id":"ck5m75gl300e1lktv5wqq3g4p"},{"name":"正则表达式","_id":"ck5m75gl500eilktvtvzxwyze"},{"name":"watch","_id":"ck5m75gl800f2lktv3pbahqbx"},{"name":"闭包","_id":"ck5m75gla00falktvxgrv4uw1"}]}}